<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic|Lobster+Two:300,300italic,400,400italic,700,700italic|EB+Garamond:300,300italic,400,400italic,700,700italic|Roboto+Slab:300,300italic,400,400italic,700,700italic|Source+Code+Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"driverxdw.github.io","root":"/","scheme":"Muse","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="一、起源yulong-hids可以说是国内第一个比较成熟的开源hids项目，虽说项目已经发布很久，但直到几个月前才想着去学习一下其技术原理，主要是之前这块的研究需求不是很高，而且环境搭建过程较为复杂，没有一键化的脚本，自己手搭受挫了几次随即没了兴致（捂脸），最近心血来潮又来玩了一遍终于搭成功了（捂脸），果然还是成长了吗（&#x2F;&#x2F;雾）">
<meta property="og:type" content="article">
<meta property="og:title" content="Yulong-Hids架构设计与功能原理分析">
<meta property="og:url" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="in0va&#39;S Blog  JustLearnM0re">
<meta property="og:description" content="一、起源yulong-hids可以说是国内第一个比较成熟的开源hids项目，虽说项目已经发布很久，但直到几个月前才想着去学习一下其技术原理，主要是之前这块的研究需求不是很高，而且环境搭建过程较为复杂，没有一键化的脚本，自己手搭受挫了几次随即没了兴致（捂脸），最近心血来潮又来玩了一遍终于搭成功了（捂脸），果然还是成长了吗（&#x2F;&#x2F;雾）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201020221739747.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201020223936155.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201020224837799.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201020225211462.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201020230009865.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201020230244071.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/jg.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201021105112153.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201021112728528.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201021174332979.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201021174837323.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201021175031736.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201021175143860.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201021175514821.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201021175932368.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201021190200612.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201021190248527.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201021191240242.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201021191457781.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201022101107922.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201021192848216.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201021193030185.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201021193119756.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201021193203519.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201022120401573.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201022120423447.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201022120739280.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201022121056325.png">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201022121152354.png">
<meta property="article:published_time" content="2020-10-20T12:54:32.000Z">
<meta property="article:modified_time" content="2020-10-22T06:28:12.180Z">
<meta property="article:author" content="XDW">
<meta property="article:tag" content="源码分析">
<meta property="article:tag" content="二进制">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201020221739747.png">


<link rel="canonical" href="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Yulong-Hids架构设计与功能原理分析 | in0va'S Blog  JustLearnM0re</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">in0va'S Blog  JustLearnM0re</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">犯二</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">69</span></a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、起源"><span class="nav-number">1.</span> <span class="nav-text">一、起源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、功能"><span class="nav-number">2.</span> <span class="nav-text">二、功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、架构"><span class="nav-number">3.</span> <span class="nav-text">三、架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Agent"><span class="nav-number">3.1.</span> <span class="nav-text">Agent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Daemon"><span class="nav-number">3.2.</span> <span class="nav-text">Daemon</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Server"><span class="nav-number">3.3.</span> <span class="nav-text">Server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Database"><span class="nav-number">3.4.</span> <span class="nav-text">Database</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web"><span class="nav-number">3.5.</span> <span class="nav-text">Web</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、实现"><span class="nav-number">4.</span> <span class="nav-text">四、实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#源码结构"><span class="nav-number">4.1.</span> <span class="nav-text">源码结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Agent-1"><span class="nav-number">4.2.</span> <span class="nav-text">Agent</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#main"><span class="nav-number">4.2.1.</span> <span class="nav-text">main</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#client"><span class="nav-number">4.2.2.</span> <span class="nav-text">client</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#monitor"><span class="nav-number">4.2.3.</span> <span class="nav-text">monitor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collect"><span class="nav-number">4.2.4.</span> <span class="nav-text">collect</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Daemon-1"><span class="nav-number">4.3.</span> <span class="nav-text">Daemon</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#main-1"><span class="nav-number">4.3.1.</span> <span class="nav-text">main</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#task"><span class="nav-number">4.3.2.</span> <span class="nav-text">task</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Server-1"><span class="nav-number">4.4.</span> <span class="nav-text">Server</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#main-2"><span class="nav-number">4.4.1.</span> <span class="nav-text">main</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#models"><span class="nav-number">4.4.2.</span> <span class="nav-text">models</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#action"><span class="nav-number">4.4.3.</span> <span class="nav-text">action</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#safecheck"><span class="nav-number">4.4.4.</span> <span class="nav-text">safecheck</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Database-1"><span class="nav-number">4.5.</span> <span class="nav-text">Database</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mongodb"><span class="nav-number">4.5.1.</span> <span class="nav-text">mongodb</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#es"><span class="nav-number">4.5.2.</span> <span class="nav-text">es</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web-1"><span class="nav-number">4.6.</span> <span class="nav-text">Web</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、问题"><span class="nav-number">5.</span> <span class="nav-text">五、问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、总结"><span class="nav-number">6.</span> <span class="nav-text">六、总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、链接"><span class="nav-number">7.</span> <span class="nav-text">七、链接</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XDW"
      src="/images/author.jpg">
  <p class="site-author-name" itemprop="name">XDW</p>
  <div class="site-description" itemprop="description">一枚很菜但是仍在学习的二进制菜逼</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">69</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.ixuchao.cn/" title="https:&#x2F;&#x2F;blog.ixuchao.cn&#x2F;" rel="noopener" target="_blank">Archerx's Blog</a>
        </li>
    </ul>
  </div>

      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://driverxdw.github.io/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="XDW">
      <meta itemprop="description" content="一枚很菜但是仍在学习的二进制菜逼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="in0va'S Blog  JustLearnM0re">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Yulong-Hids架构设计与功能原理分析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-20 20:54:32" itemprop="dateCreated datePublished" datetime="2020-10-20T20:54:32+08:00">2020-10-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-22 14:28:12" itemprop="dateModified" datetime="2020-10-22T14:28:12+08:00">2020-10-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/HIDS/" itemprop="url" rel="index"><span itemprop="name">HIDS</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="一、起源"><a href="#一、起源" class="headerlink" title="一、起源"></a>一、起源</h2><p>yulong-hids可以说是国内第一个比较成熟的开源hids项目，虽说项目已经发布很久，但直到几个月前才想着去学习一下其技术原理，主要是之前这块的研究需求不是很高，而且环境搭建过程较为复杂，没有一键化的脚本，自己手搭受挫了几次随即没了兴致（捂脸），最近心血来潮又来玩了一遍终于搭成功了（捂脸），果然还是成长了吗（//雾）</p>
<a id="more"></a>

<h2 id="二、功能"><a href="#二、功能" class="headerlink" title="二、功能"></a>二、功能</h2><p>yulong-hids拥有的主要功能模块如下：</p>
<p>1、统计信息</p>
<p><img src="./image-20201020221739747.png" alt="image-20201020221739747"></p>
<p>此模块为产品的展示面板模块，首先包括主机数（agent）、告警数、任务数、服务器数（server）、数据总数（信息/行为）这些重要项的数量展示，其次是告警的图表展示，包括告警日期分布折线图、告警类型分布统计饼状图（告警类型为规则名）、告警数量时间分布柱状图及告警信息展示top8（按次序排列）</p>
<p>2、主机列表</p>
<p><img src="./image-20201020223936155.png" alt="image-20201020223936155"></p>
<p>此模块为agent管理模块，方便用户监控安装agent的主机行为（进程、文件、网络等）并支持agent下载安装</p>
<p>3、数据分析</p>
<p><img src="./image-20201020224837799.png" alt="image-20201020224837799"></p>
<p>此模块为溯源模块，可以从es中快速查询关键词显示，支持简单的搜索语法</p>
<p>4、告警</p>
<p><img src="./image-20201020225211462.png" alt="image-20201020225211462"></p>
<p>显示全量告警，支持自动溯源和处置响应（进程、文件、网络），允许手动变更事件状态（未处理、已处理、忽略）并支持加白/加黑处理</p>
<p>5、任务</p>
<p><img src="./image-20201020230009865.png" alt="image-20201020230009865"></p>
<p>允许用户在server端自定义一些任务下发给agent，任务指令如下：</p>
<pre><code>kill: 结束进程(传入进程名)
uninstall: 卸载自身
update: Agent更新
delete: 文件删除(传入文件路径)
exec: 自定义命令 (发布的release不支持这个功能，如需这个功能，请去掉注释，自行编译agent)
reload: 重启Agent
quit: 结束自身</code></pre><p>6、规则引擎</p>
<p><img src="./image-20201020230244071.png" alt="image-20201020230244071"></p>
<p>此模块自己实现了一套简单的规则引擎对事件进行过滤和匹配规则，支持server控制台编写、导出、修改（编辑）规则，支持已有规则的细粒度控制（开/关）</p>
<p>7、设置</p>
<p>此模块可通过修改配置影响agent及server处理</p>
<h2 id="三、架构"><a href="#三、架构" class="headerlink" title="三、架构"></a>三、架构</h2><p><img src="./jg.png" alt="jg"></p>
<p>以上为yulong的整体架构图，具体说明如下：</p>
<h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h3><p>agent为主机端探针，主要负责行为监控、信息收集、数据处理、事件上传功能，具体说明如下：</p>
<pre><code>信息收集：收集主机开启启动项、计划任务、监听端口、服务、登陆日志、用户列表等静态文件
行为监控：收集主机行为数据，包括进程行为、文件行为、网络行为，三种信息收集方式分别为
    进程监控：lkm hook（execve）（agent监控本地udp65530接收进程信息）
    文件监控：inotify
    网络监控：libpcap
数据处理：对收集的信息在格式化前进行简单的过滤和筛选处理
事件上传：将处理后的数据组成特定格式以事件形式通过rpc服务上传给server，由server进行规则解析和处理</code></pre><h3 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h3><p>daemon为agent的守护进程，负责agent热更新、进程守护、静默部署、服务指令接收等功能，具体说明如下：</p>
<pre><code>热更新：支持部署hids的主机自动从server下载更新agent
进程守护：注册daemon为服务，agent线程退出后daemon负责重启
静默部署：后台静默安装
服务指令接收：开放65512端口用于接收server端下发的指令任务</code></pre><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>server主要用于agent数据接收、数据分析、安全检测、任务下发及结果保存，具体说明如下：</p>
<pre><code>数据接收：server在33433端口部署rpc服务来接收所有agent上传的监控事件并回传agent获取配置请求结果（getinfo、putinfo）
数据分析：自动化溯源功能，server根据控制台规则去es索引数据并在web渲染显示
安全检测：利用自实现规则引擎对接收到的agent事件进行规则匹配，匹配结果入库（mongodb）
结果保存：安全检测结果入库（mongodb），全量行为事件（file、process、loginlog、connection）入es
任务下发：web控制台上新建任务会由web后端响应并通过65512端口将任务以特定数据格式下发给daemon并接收执行返回结果信息</code></pre><h3 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h3><p>yulong这块的database主要包含es、mongodb两个平台，es主要为溯源使用，mongodb则保存一些配置及具体任务、规则等静态信息，具体说明如下：</p>
<pre><code>es：
1、保存agent监控到的全量主机行为事件（file、process、loginlog、connection）
2、server的数据分析功能会从es中拉数据
mongodb：
1、web端的任务新建、规则修改等动作会由web后端响应并修改mongodb相关库表（增删改查）
2、web前端的动作生效后，server可以从mongodb中获取变更的配置、任务、规则等
3、agent通过rpc调用利用server读写mongo
4、server根据数据分析结果增删改查mongo</code></pre><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p>web主要负责集中管理、安全分析、警报处理、配置等项，功能基本可以在web前端看到，不再赘述；后端等后续填坑</p>
<h2 id="四、实现"><a href="#四、实现" class="headerlink" title="四、实现"></a>四、实现</h2><h3 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h3><pre><code>├─agent // Agent工程
│  ├─client // RPC client 传输模块
│  ├─common
│  ├─collect // 信息收集（开机启动项、计划任务、监听端口、服务、登录日志、用户列表）
│  └─monitor // 行为监控（文件操作、网络连接、执行命令）
├─bin
│  ├─linux-64 // Linux 64位的依赖包
│  ├─win-32 // Windows 32位的依赖包
│  └─win-64 // Windows 64位的依赖包
├─daemon // Daemon工程
│  ├─common
│  ├─install // 安装Agent和相关依赖
│  └─task // 任务接收
├─docs // 说明文档
├─driver // Windows 命令监控驱动
├─server // Server节点工程
│  ├─action // Server基本功能
│  ├─models // 数据库相关
│  └─safecheck // 安全检测模块（黑白名单，规则解析引擎）
├─syscall_hook # 监控执行命令的Linux内核代码
│  └─test_bench // 方便调试的
└─web // Web控制台项目
    ├─conf // web端配置文件
    ├─controllers // 控制器，负责转发请求，对请求进行处理
    ├─httpscert // https证书和RSA私钥，内置的会在向导过程中自动更新
    ├─models // 模型，数据管理和数据库设计
    ├─routers // 路由
    ├─settings // 部分全局变量
    ├─static // 静态文件
    ├─upload_files // agent、daemon、依赖包文件
    ├─utils // 功能模块
    └─views // 视图层，前端模板</code></pre><h3 id="Agent-1"><a href="#Agent-1" class="headerlink" title="Agent"></a>Agent</h3><h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><p>从agent.go中的main开始看起：</p>
<pre><code>func main() {
    if len(os.Args) &lt;= 1 {
        fmt.Println(&quot;Usage: agent[.exe] ServerIP [debug]&quot;)
        fmt.Println(&quot;Example: agent 8.8.8.8 debug&quot;)
        return
    }
    if runtime.GOOS == &quot;linux&quot; {
        out, _ := common.CmdExec(fmt.Sprintf(&quot;lsmod|grep syshook_execve&quot;))
        if out == &quot;&quot; {
            common.CmdExec(fmt.Sprintf(&quot;insmod %s/syshook_execve.ko&quot;, common.InstallPath))
        }
    }
    var agent client.Agent
    agent.ServerNetLoc = os.Args[1]
    if len(os.Args) == 3 &amp;&amp; os.Args[2] == &quot;debug&quot; {
        log.Println(&quot;DEBUG MODE&quot;)
        agent.IsDebug = true
    }
    agent.Run()
}</code></pre><p>首先检测参数数量，要求参数至少有两个，逻辑上要求参数之一必须是server所在ip，但这边有个bug，没有校验os.Args[1]的格式，导致如果第一个参数为debug，agent将无法启动：</p>
<p><img src="./image-20201021105112153.png" alt="image-20201021105112153"></p>
<p>继续往下看，之后检测运行环境是否是linux，若是，调go的exec函数执行bash命令检测进程监控所用的lkm模块（syshook_execve）是否已经加载，若加载，继续后续流程，若未加载，则调insmod加载，加载的内核模块路径在daemon模块中的common.go中指定为/usr/yulong-hids，daemon会负责agent运行环境的依赖检测和内核模块的编译及放置在指定位置等，这个之后再详述；</p>
<p>检测是否开启debug模式，若是，则给全局结构体agent的IsDebug状态位置true，之后调用agent.Run()正式启动agent</p>
<h4 id="client"><a href="#client" class="headerlink" title="client"></a>client</h4><p>现在控制流到了client模块</p>
<pre><code>// Run 启动agent
func (a *Agent) Run() {

    // agent 初始化
    // 请求Web API，获取Server地址，初始化RPC客户端，获取客户端IP等
    a.init()

    // 每隔一段时间更新初始化配置
    a.configRefresh()

    // 开启各个监控流程 文件监控，网络监控，进程监控
    a.monitor()

    // 每隔一段时间获取系统信息
    // 监听端口，服务信息，用户信息，开机启动项，计划任务，登录信息，进程列表等
    a.getInfo()
}</code></pre><p>run函数功能划分在注释中已经说的很清楚了，分别进入每一个模块：</p>
<p><strong>init</strong></p>
<pre><code>func (a *Agent) init() {
    a.ServerList, err = a.getServerList()
    if err != nil {
        a.log(&quot;GetServerList error:&quot;, err)
        panic(1)
    }
    a.ctx = context.WithValue(context.Background(), share.ReqMetaDataKey, make(map[string]string))
    a.log(&quot;Available server node:&quot;, a.ServerList)
    if len(a.ServerList) == 0 {
        time.Sleep(time.Second * 30)
        a.log(&quot;No server node available&quot;)
        panic(1)
    }
    a.newClient()
    if common.LocalIP == &quot;&quot; {
        a.log(&quot;Can not get local address&quot;)
        panic(1)
    }
    a.Mutex = new(sync.Mutex)
    err := a.Client.Call(a.ctx, &quot;GetInfo&quot;, &amp;common.ServerInfo, &amp;common.Config)
    if err != nil {
        a.log(&quot;RPC Client Call Error:&quot;, err.Error())
        panic(1)
    }
    a.log(&quot;Common Client Config:&quot;, common.Config)
}</code></pre><p>首先寻找server地址，相关逻辑在getServerList函数中，如下：</p>
<pre><code>func (a Agent) getServerList() ([]string, error) {
    var serlist []string
    var url string
    if TESTMODE {
        url = &quot;http://&quot; + a.ServerNetLoc + SERVER_API
    } else {
        url = &quot;https://&quot; + a.ServerNetLoc + SERVER_API
    }
    a.log(&quot;Web API:&quot;, url)
    request, _ := http.NewRequest(&quot;GET&quot;, url, nil)
    request.Close = true
    resp, err := httpClient.Do(request)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    result, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        return nil, err
    }
    err = json.Unmarshal([]byte(result), &amp;serlist)
    if err != nil {
        return nil, err
    }
    return serlist, nil
}</code></pre><p>a.ServerNetLoc其实就是agent启动参数中用户指定的serverip，SERVER_API在client中config.go中定义为/json/serverlist，二者拼接之后向server发送请求，返回结果为serverip:port的列表格式，此处暂时不考虑server集群的情况</p>
<p><img src="./image-20201021112728528.png" alt="image-20201021112728528"></p>
<p>对getServerList的结果进行异常处理之后进入newclient模块</p>
<pre><code>func (a *Agent) newClient() {
    var servers []*client.KVPair
    for _, server := range a.ServerList {
        common.ServerIPList = append(common.ServerIPList, strings.Split(server, &quot;:&quot;)[0])
        s := client.KVPair{Key: server}
        servers = append(servers, &amp;s)
        if common.LocalIP == &quot;&quot; {
            a.setLocalIP(server)
            common.ServerInfo = collect.GetComInfo()
            a.log(&quot;Host Information:&quot;, common.ServerInfo)
        }
    }
    conf := &amp;tls.Config{
        InsecureSkipVerify: true,
    }
    option := client.DefaultOption
    option.TLSConfig = conf
    serverd := client.NewMultipleServersDiscovery(servers)
    a.Client = client.NewXClient(&quot;Watcher&quot;, FAILMODE, client.RandomSelect, serverd, option)
    a.Client.Auth(AUTH_TOKEN)
}</code></pre><p>newclient模块主要负责获取部署agent所在主机的相关信息以及部分配置信息，获取项在agent/common/common.go中</p>
<pre><code>type ClientConfig struct {
    Cycle  int    // 信息传输频率，单位：分钟
    UDP    bool   // 是否记录UDP请求
    LAN    bool   // 是否本地网络请求
    Mode   string // 模式，考虑中
    Filter struct {
        File    []string // 文件hash、文件名
        IP      []string // IP地址
        Process []string // 进程名、参数
    } // 直接过滤不回传的规则
    MonitorPath []string // 监控目录列表
    Lasttime    string   // 最后一条登录日志时间
}

// ComputerInfo 计算机信息结构
type ComputerInfo struct {
    IP       string   // IP地址
    System   string   // 操作系统
    Hostname string   // 计算机名
    Type     string   // 服务器类型
    Path     []string // WEB目录
}

var (
    // Config 配置信息
    Config ClientConfig
    // LocalIP 本机活跃IP
    LocalIP string
    // ServerInfo 主机相关信息
    ServerInfo ComputerInfo
    // ServerIPList 服务端列表
    ServerIPList []string
)</code></pre><p>获取主机相关信息后调用rpc_getinfo去server初步拉配置，具体配置项在server模块中有说明：</p>
<pre><code>    if common.LocalIP == &quot;&quot; {
        a.log(&quot;Can not get local address&quot;)
        panic(1)
    }
    a.Mutex = new(sync.Mutex)
    err := a.Client.Call(a.ctx, &quot;GetInfo&quot;, &amp;common.ServerInfo, &amp;common.Config)
    if err != nil {
        a.log(&quot;RPC Client Call Error:&quot;, err.Error())
        panic(1)
    }
    a.log(&quot;Common Client Config:&quot;, common.Config</code></pre><p><strong>configRefresh</strong></p>
<p>起一个线程，每60s调一次rpc_getinfo去数据库拉一次配置，保证控制台配置变更后尽快生效：</p>
<pre><code>func (a *Agent) configRefresh() {
    ticker := time.NewTicker(time.Second * time.Duration(CONFIGR_REF_INTERVAL))
    go func() {
        for _ = range ticker.C {
            ch := make(chan bool)
            go func() {
                err = a.Client.Call(a.ctx, &quot;GetInfo&quot;, &amp;common.ServerInfo, &amp;common.Config)
                if err != nil {
                    a.log(&quot;RPC Client Call:&quot;, err.Error())
                    return
                }
                ch &lt;- true
            }()</code></pre><p><strong>monitor</strong></p>
<p>monitor函数主要用于agent所在主机的行为监控，可以看到monitor调用agent/monitor/中的函数起了三个线程，看函数名可知分别为网络嗅探、进程监控、文件监控，跟进monitor模块分析；行为监控的结果调rpc_putinfo上传server处理：</p>
<pre><code>func (a *Agent) monitor() {
    resultChan := make(chan map[string]string, 16)
    go monitor.StartNetSniff(resultChan)
    go monitor.StartProcessMonitor(resultChan)
    go monitor.StartFileMonitor(resultChan)
    go func(result chan map[string]string) {
        var resultdata []map[string]string
        var data map[string]string
        for {
            data = &lt;-result
            data[&quot;time&quot;] = fmt.Sprintf(&quot;%d&quot;, time.Now().Unix())
            a.log(&quot;Monitor data: &quot;, data)
            source := data[&quot;source&quot;]
            delete(data, &quot;source&quot;)
            a.Mutex.Lock()
            a.PutData = dataInfo{common.LocalIP, source, runtime.GOOS, append(resultdata, data)}
            a.put()
            a.Mutex.Unlock()
        }
    }(resultChan)
}</code></pre><pre><code>func (a Agent) put() {
    _, err := a.Client.Go(a.ctx, &quot;PutInfo&quot;, &amp;a.PutData, &amp;a.Reply, nil)
    if err != nil {
        a.log(&quot;PutInfo error:&quot;, err.Error())
    }
}</code></pre><h4 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h4><p><strong>StartNetSniff</strong></p>
<p>先贴下代码：</p>
<pre><code>func StartNetSniff(resultChan chan map[string]string) {
    var pkt *pcap.Packet
    var resultdata map[string]string
    h, err := getPcapHandle(common.LocalIP)
    if err != nil {
        return
    }
    for {
        pkt = h.Next()
        if pkt == nil {
            continue
        }
        pkt.Decode()
        var port int
        var ip string
        var localPort int
        resultdata = map[string]string{
            &quot;source&quot;:   &quot;&quot;,
            &quot;dir&quot;:      &quot;&quot;,
            &quot;protocol&quot;: &quot;&quot;,
            &quot;remote&quot;:   &quot;&quot;,
            &quot;local&quot;:    &quot;&quot;,
            &quot;pid&quot;:      &quot;&quot;,
            &quot;name&quot;:     &quot;&quot;,
        }
        //不记录跟安全中心的连接记录
        if pkt.IP != nil &amp;&amp; (common.LocalIP == pkt.IP.SrcAddr() || common.LocalIP == pkt.IP.DestAddr()) &amp;&amp;
            !common.InArray(common.ServerIPList, pkt.IP.SrcAddr(), false) &amp;&amp;
            !common.InArray(common.ServerIPList, pkt.IP.DestAddr(), false) {
            resultdata[&quot;source&quot;] = &quot;connection&quot;
            if common.LocalIP == pkt.IP.SrcAddr() {
                ip = pkt.IP.DestAddr()
                resultdata[&quot;dir&quot;] = &quot;out&quot;
            } else {
                ip = pkt.IP.SrcAddr()
                resultdata[&quot;dir&quot;] = &quot;in&quot;
            }
            if common.ServerInfo.Type == &quot;web&quot; &amp;&amp; resultdata[&quot;dir&quot;] == &quot;in&quot; {
                continue
            }
            //如果内网记录为关闭则进行IP判断
            if !common.Config.LAN &amp;&amp; isLan(ip) {
                continue
            }
            //白名单
            if common.InArray(common.Config.Filter.IP, ip, false) {
                continue
            }
            if pkt.IP.Protocol == UDP {
                if common.Config.UDP == false {
                    continue
                }
                resultdata[&quot;protocol&quot;] = &quot;udp&quot;
                if resultdata[&quot;dir&quot;] == &quot;out&quot; {
                    port = int(pkt.UDP.DestPort)
                    localPort = int(pkt.UDP.SrcPort)
                } else {
                    port = int(pkt.UDP.SrcPort)
                    localPort = int(pkt.UDP.DestPort)
                }
                if isFilterPort(port) || isFilterPort(localPort) {
                    continue
                }
                resultdata[&quot;remote&quot;] = fmt.Sprintf(&quot;%s:%d&quot;, ip, port) //UDP
                resultdata[&quot;local&quot;] = fmt.Sprintf(&quot;%s:%d&quot;, common.LocalIP, localPort)
            } else if pkt.IP.Protocol == TCP &amp;&amp; strings.Contains(pkt.String(), &quot;[syn]&quot;) {
                resultdata[&quot;protocol&quot;] = &quot;tcp&quot;
                if resultdata[&quot;dir&quot;] == &quot;out&quot; {
                    port = int(pkt.TCP.DestPort)
                    localPort = int(pkt.TCP.SrcPort)
                } else {
                    port = int(pkt.TCP.SrcPort)
                    localPort = int(pkt.TCP.DestPort)
                }
                if isFilterPort(port) || isFilterPort(localPort) {
                    continue
                }
                resultdata[&quot;remote&quot;] = fmt.Sprintf(&quot;%s:%d&quot;, ip, port) //TCP
                conName := C.GoString(C.filter(C.CString(ip), C.int(port)))
                if conName != &quot;&quot; {
                    resultdata[&quot;pid&quot;] = strings.SplitN(conName, &quot;/&quot;, 2)[0]
                    resultdata[&quot;name&quot;] = strings.SplitN(conName, &quot;/&quot;, 2)[1]
                }
                resultdata[&quot;local&quot;] = fmt.Sprintf(&quot;%s:%d&quot;, common.LocalIP, localPort)
            } else {
                continue
            }
            resultChan &lt;- resultdata
        }
    }
}</code></pre><p>使用gopcap库调libpcap api实时捕获流量包，保存在pkt数据报结构里，并调用pkt.Decode进行raw data的字段解析；</p>
<pre><code>var pkt *pcap.Packet
    var resultdata map[string]string
    h, err := getPcapHandle(common.LocalIP)
    if err != nil {
        return
    }
    for {
        pkt = h.Next()
        if pkt == nil {
            continue
        }
        pkt.Decode()</code></pre><p>定义好结果数据格式：</p>
<pre><code>        resultdata = map[string]string{
            &quot;source&quot;:   &quot;&quot;,
            &quot;dir&quot;:      &quot;&quot;,
            &quot;protocol&quot;: &quot;&quot;,
            &quot;remote&quot;:   &quot;&quot;,
            &quot;local&quot;:    &quot;&quot;,
            &quot;pid&quot;:      &quot;&quot;,
            &quot;name&quot;:     &quot;&quot;,
        }</code></pre><p>首先过滤掉srcAddr和DstAddr都是自己的数据包，确保捕获的都是外联的流量事件，其次过滤掉srcAddr和DstAddr为serverip的流量，保证捕获的流量是除与Serverip通信之外的流量</p>
<pre><code>if pkt.IP != nil &amp;&amp; (common.LocalIP == pkt.IP.SrcAddr() || common.LocalIP == pkt.IP.DestAddr()) &amp;&amp;
            !common.InArray(common.ServerIPList, pkt.IP.SrcAddr(), false) &amp;&amp;
            !common.InArray(common.ServerIPList, pkt.IP.DestAddr(), false) {</code></pre><p>resultdata中的source标明事件类型：connection，通过将流量srcAddr与agentLocalIp比较来判断流量流向；判断主机是否是web类型服务器，如果是，则一切流入的流量都过滤</p>
<pre><code>            resultdata[&quot;source&quot;] = &quot;connection&quot;
            if common.LocalIP == pkt.IP.SrcAddr() {
                ip = pkt.IP.DestAddr()
                resultdata[&quot;dir&quot;] = &quot;out&quot;
            } else {
                ip = pkt.IP.SrcAddr()
                resultdata[&quot;dir&quot;] = &quot;in&quot;
            }
            if common.ServerInfo.Type == &quot;web&quot; &amp;&amp; resultdata[&quot;dir&quot;] == &quot;in&quot; {
                continue
            }</code></pre><p>判断是否打开记录内网流量事件的配置同时判断流量ip是否是内网，若是，且内网记录配置未开启，则过滤；判断流量ip是否在ip白名单中，若是，则过滤</p>
<pre><code>
            if !common.Config.LAN &amp;&amp; isLan(ip) {
                continue
            }
            if common.InArray(common.Config.Filter.IP, ip, false) {
                continue
            }</code></pre><p>判断ip数据报协议类型是否为udp，若是，继续判断控制台记录udp选项是否开启，若未开启，则过滤；若开启，则继续判断流向，并根据流向将解析后的数据包中的源/目的地址分别赋值给port及locaport；之后判断流量所在端口是否在硬编码的白名单端口中，若是，则过滤；最终，将ip、port与localip、localport分别拼接保存在remote、local两个变量中</p>
<pre><code>if pkt.IP.Protocol == UDP {
                if common.Config.UDP == false {
                    continue
                }
                resultdata[&quot;protocol&quot;] = &quot;udp&quot;
                if resultdata[&quot;dir&quot;] == &quot;out&quot; {
                    port = int(pkt.UDP.DestPort)
                    localPort = int(pkt.UDP.SrcPort)
                } else {
                    port = int(pkt.UDP.SrcPort)
                    localPort = int(pkt.UDP.DestPort)
                }
                if isFilterPort(port) || isFilterPort(localPort) {
                    continue
                }
                resultdata[&quot;remote&quot;] = fmt.Sprintf(&quot;%s:%d&quot;, ip, port) //UDP
                resultdata[&quot;local&quot;] = fmt.Sprintf(&quot;%s:%d&quot;, common.LocalIP, localPort)
            } </code></pre><pre><code>func isFilterPort(port int) bool {
    for _, v := range filter.Port {
        if v == port {
            return true
        }
    }
    return false
}</code></pre><pre><code>func init() {
    // 硬编码白名单
    filter.Port = []int{137, 139, 445}
    filter.File = []string{`c:\windows\temp`}
}</code></pre><p>tcp和udp逻辑类似，不同之处在于tcp流量记录是默认开启的（没有配置），且只判断握手包中的syn包，其它基本一致</p>
<pre><code> else if pkt.IP.Protocol == TCP &amp;&amp; strings.Contains(pkt.String(), &quot;[syn]&quot;) {
                resultdata[&quot;protocol&quot;] = &quot;tcp&quot;
                if resultdata[&quot;dir&quot;] == &quot;out&quot; {
                    port = int(pkt.TCP.DestPort)
                    localPort = int(pkt.TCP.SrcPort)
                } else {
                    port = int(pkt.TCP.SrcPort)
                    localPort = int(pkt.TCP.DestPort)
                }
                if isFilterPort(port) || isFilterPort(localPort) {
                    continue
                }
                resultdata[&quot;remote&quot;] = fmt.Sprintf(&quot;%s:%d&quot;, ip, port) //TCP</code></pre><p>将流量关联到进程；go调c代码中的filter函数，将remote ip和remote port作为参数，返回包含pid和cmdline的字符串，调用层对其进行分割，保存到map中</p>
<pre><code>                conName := C.GoString(C.filter(C.CString(ip), C.int(port)))
                if conName != &quot;&quot; {
                    resultdata[&quot;pid&quot;] = strings.SplitN(conName, &quot;/&quot;, 2)[0]
                    resultdata[&quot;name&quot;] = strings.SplitN(conName, &quot;/&quot;, 2)[1]
                }
                resultdata[&quot;local&quot;] = fmt.Sprintf(&quot;%s:%d&quot;, common.LocalIP, localPort)</code></pre><p>具体关联方式需要参考项目中的c代码，先贴下：</p>
<pre><code>/*
#include &lt;arpa/inet.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pwd.h&gt;
#include &lt;errno.h&gt;
#include &lt;dirent.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

typedef union iaddr iaddr;

union iaddr {
    unsigned u;
    unsigned char b[4];
};

#define PRG_LOCAL_ADDRESS &quot;local_address&quot;
#define PRG_INODE     &quot;inode&quot;
#define PRG_SOCKET_PFX    &quot;socket:[&quot;
#define PRG_SOCKET_PFXl (strlen(PRG_SOCKET_PFX))
#define PRG_SOCKET_PFX2   &quot;[0000]:&quot;
#define PRG_SOCKET_PFX2l  (strlen(PRG_SOCKET_PFX2))

#ifndef LINE_MAX
#define LINE_MAX 4096
#endif

#define PATH_PROC       &quot;/proc&quot;
#define PATH_FD_SUFF    &quot;fd&quot;
#define PATH_FD_SUFFl       strlen(PATH_FD_SUFF)
#define PATH_PROC_X_FD      PATH_PROC &quot;/%s/&quot; PATH_FD_SUFF
#define PATH_CMDLINE    &quot;cmdline&quot;
#define PATH_CMDLINEl       strlen(PATH_CMDLINE)

#undef  DIRENT_HAVE_D_TYPE_WORKS


#define ADDR_LEN INET6_ADDRSTRLEN + 1 + 5 + 1

static void addr2str(int af, const void *addr, unsigned port, char *buf)
{
    if (inet_ntop(af, addr, buf, ADDR_LEN) == NULL) {
        *buf = &#39;\0&#39;;
        return;
    }
}
#define PROGNAME_WIDTH 20

#define PRG_HASH_SIZE 211
#define PRG_HASHIT(x) ((x) % PRG_HASH_SIZE)

static char finbuf[PROGNAME_WIDTH];

static void extract_type_1_socket_inode(const char lname[], long * inode_p) {

    if (lname[strlen(lname) - 1] != &#39;]&#39;) *inode_p = -1;
    else {
        char inode_str[strlen(lname + 1)];
        const int inode_str_len = strlen(lname) - PRG_SOCKET_PFXl - 1;
        char *serr;

        strncpy(inode_str, lname + PRG_SOCKET_PFXl, inode_str_len);
        inode_str[inode_str_len] = &#39;\0&#39;;
        *inode_p = strtol(inode_str, &amp;serr, 0);
        if (!serr || *serr || *inode_p &lt; 0 || *inode_p &gt;= 2147483647)
            *inode_p = -1;
    }
}


static char * pget(unsigned uid,long inode) {
    DIR *d = opendir(&quot;/proc&quot;);
    if(NULL == d) return &quot;&quot;;
    long inode_p;
    char statline[1024];
    char cmdline[1024];
    struct dirent *de;
    struct stat stats;
    struct passwd *pw;
    int fd, i = 0; int procfdlen, fd_last, cmdllen, lnamelen;
    char line[LINE_MAX], eacces = 0;
    char lname[30], cmdlbuf[512];
    DIR *dirproc = NULL, *dirfd = NULL;
    struct dirent *direproc, *direfd;
    cmdlbuf[sizeof(cmdlbuf)-1] = &#39;\0&#39;;
    const char *cs, *cmdlp;
    if (!(dirproc = opendir(PATH_PROC)))
    {
        printf(&quot;error&quot;);
        return &quot;&quot;;
    }
    while (direproc = readdir(dirproc)) {
        for (cs = direproc-&gt;d_name; *cs; cs++)
        if (!isdigit(*cs))
            break;
        if (*cs)
            continue;

        procfdlen = snprintf(line, sizeof(line), PATH_PROC_X_FD, direproc-&gt;d_name);
        if (procfdlen &lt;= 0 || procfdlen &gt;= sizeof(line)-5)
            continue;
        errno = 0;
        dirfd = opendir(line);
        if (!dirfd) {
            if (errno ==1 )
                eacces = 1;
            continue;
        }
        line[procfdlen] = &#39;/&#39;;
        cmdlp = NULL;

        while ((direfd = readdir(dirfd))) {
            if (procfdlen + 1 + strlen(direfd-&gt;d_name) + 1&gt;sizeof(line))
                continue;
            memcpy(line + procfdlen - PATH_FD_SUFFl, PATH_FD_SUFF &quot;/&quot;,
                PATH_FD_SUFFl + 1);
            strcpy(line + procfdlen + 1, direfd-&gt;d_name);
            lnamelen = readlink(line, lname, sizeof(lname)-1);
            lname[lnamelen] = &#39;\0&#39;;
            extract_type_1_socket_inode(lname, &amp;inode_p);
            if (inode_p == inode)
            {
                if (!cmdlp) {
                    if (procfdlen - PATH_FD_SUFFl + PATH_CMDLINEl &gt;=
                        sizeof(line)-5)
                        continue;
                    strcpy(line + procfdlen - PATH_FD_SUFFl, PATH_CMDLINE);
                    fd = open(line, O_RDONLY);
                    if (fd &lt; 0)
                        continue;
                    cmdllen = read(fd, cmdlbuf, sizeof(cmdlbuf)-1);
                    if (close(fd))
                        continue;
                    if (cmdllen == -1)
                        continue;
                    if (cmdllen &lt; sizeof(cmdlbuf)-1)
                        cmdlbuf[cmdllen] = &#39;\0&#39;;
                    if ((cmdlp = strrchr(cmdlbuf, &#39;/&#39;)))
                        cmdlp++;
                    else
                        cmdlp = cmdlbuf;
                }

                snprintf(finbuf, sizeof(finbuf), &quot;%s/%s&quot;, direproc-&gt;d_name, cmdlp);
                return finbuf;
            }
        }
    }
    return &quot;&quot;;
}
char *s;
static char * filter(char *host, int port) {
    char *filename = &quot;/proc/net/tcp&quot;;
    char *label = &quot;tcp&quot;;
    memset(finbuf,0,PROGNAME_WIDTH);
    FILE *fp = fopen(filename, &quot;r&quot;);
    if (fp == NULL) return;
    long inode;
    char buf[BUFSIZ];
    fgets(buf, BUFSIZ, fp);
    while (fgets(buf, BUFSIZ, fp)){
        char lip[ADDR_LEN];
        char rip[ADDR_LEN];
        char more[512];
        iaddr laddr, raddr;
        unsigned lport, rport, state, txq, rxq, num, tr, tm_when, retrnsmt, uid;
        int timeout;
        int n = sscanf(buf, &quot; %d: %x:%x %x:%x %x %x:%x %x:%x %x %d %d %ld %512s&quot;,
                       &amp;num, &amp;laddr.u, &amp;lport, &amp;raddr.u, &amp;rport,
                       &amp;state, &amp;txq, &amp;rxq, &amp;tr, &amp;tm_when, &amp;retrnsmt, &amp;uid, &amp;timeout, &amp;inode, more);
        if (n == 15) {
            addr2str(AF_INET, &amp;laddr, lport, lip);
            addr2str(AF_INET, &amp;raddr, rport, rip);
            if ( (int)rport == port)
            {
                pget(uid, inode);
                fclose(fp);
                return finbuf;
            }
        }
    }
    fclose(fp);
    return &quot;&quot;;
}
*/</code></pre><p>代码比较简单，大致说下，利用传递进filter函数的remote ip、port的参数去/proc/net/tcp下筛出连接对应的inode1，在pget函数利用readdir遍历/proc下全量pid子目录，获取/proc/pid/fd/下对应文件描述符指向的inode2，拿此inode2与inode1进行对比，若相等，取出对应pid下的cmdline并和pid拼接，最终返回拼接后的字符串给调用方的conName，调用层再进行进一步拆解赋值组合成指定格式的网络事件，网络行为监控这块基本如上所示</p>
<p><strong>StartProcessMonitor</strong></p>
<p>这边的进程监控稍微有一点复杂，放到另外一章去记录</p>
<p><strong>StartFileMonitor</strong></p>
<p>文件监控用的fsnotify库，封装了inotify api，进程读写动作会触发回调生成文件事件；拿到文件操作事件后模块里还有一个自定义的获取hash操作并归并到文件事件：</p>
<pre><code>func StartFileMonitor(resultChan chan map[string]string) {
    log.Println(&quot;StartFileMonitor&quot;)
    var pathList []string
    watcher, err := fsnotify.NewWatcher()
    if err != nil {
        return
    }
    defer watcher.Close()
    for _, path := range common.Config.MonitorPath {
        if path == &quot;%web%&quot; {
            iterationWatcher(common.ServerInfo.Path, watcher, pathList)
            continue
        }
        if strings.HasPrefix(path, &quot;/&quot;) {
            pathList = append(pathList, path)
            if strings.HasSuffix(path, &quot;*&quot;) {
                iterationWatcher([]string{strings.Replace(path, &quot;*&quot;, &quot;&quot;, 1)}, watcher, pathList)
            } else {
                watcher.Add(path)
            }
        }
    }
    var resultdata map[string]string
    for {
        select {
        case event := &lt;-watcher.Events:
            resultdata = make(map[string]string)
            if common.InArray(filter.File, strings.ToLower(event.Name), false) ||
                common.InArray(pathList, strings.ToLower(event.Name), false) ||
                common.InArray(common.Config.Filter.File, strings.ToLower(event.Name), true) {
                continue
            }
            if len(event.Name) == 0 {
                continue
            }
            resultdata[&quot;source&quot;] = &quot;file&quot;
            resultdata[&quot;action&quot;] = event.Op.String()
            resultdata[&quot;path&quot;] = event.Name
            resultdata[&quot;hash&quot;] = &quot;&quot;
            resultdata[&quot;user&quot;] = &quot;&quot;
            f, err := os.Stat(event.Name)
            if err == nil &amp;&amp; !f.IsDir() {
                if f.Size() &lt;= fileSize {
                    if hash, err := getFileMD5(event.Name); err == nil {
                        resultdata[&quot;hash&quot;] = hash
                        if common.InArray(common.Config.Filter.File, strings.ToLower(hash), false) {
                            continue
                        }
                    }
                }
                if user, err := getFileUser(event.Name); err == nil {
                    resultdata[&quot;user&quot;] = user
                }
            }
            if isFileWhite(resultdata) {
                continue
            }
            resultChan &lt;- resultdata
        case err := &lt;-watcher.Errors:
            log.Println(&quot;error:&quot;, err)
        }
    }
}</code></pre><h4 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h4><p><strong>getInfo</strong></p>
<p>collect主要是信息收集相关的模块，与进程、文件、网络这些行为监控不同的是，为了性能和其它一些情况考虑，这块一般不是实时的；yulong这块是在控制台配置了收集型信息的回传间隔放到数据库里并提供rpc api，agent调configRefresh去拉配置并根据配置好的间隔时间（单位：min）进行sleep，确保回传不会太频繁；getinfo调用getallinfo，在其内部调用collect的具体收集子模块；返回信息存放在alldata中，数据处理后rpc调用远端的putinfo方法上传事件：</p>
<pre><code>func (a *Agent) getInfo() {
    historyCache := make(map[string][]map[string]string)
    for {
        if len(common.Config.MonitorPath) == 0 {
            time.Sleep(time.Second)
            a.log(&quot;Failed to get the configuration information&quot;)
            continue
        }
        allData := collect.GetAllInfo()
        for k, v := range allData {
            if len(v) == 0 || a.mapComparison(v, historyCache[k]) {
                a.log(&quot;GetInfo Data:&quot;, k, &quot;No change&quot;)
                continue
            } else {
                a.Mutex.Lock()
                a.PutData = dataInfo{common.LocalIP, k, runtime.GOOS, v}
                a.put()
                a.Mutex.Unlock()
                if k != &quot;service&quot; {
                    a.log(&quot;Data details:&quot;, k, a.PutData)
                }
                historyCache[k] = v
            }
        }
        if common.Config.Cycle == 0 {
            common.Config.Cycle = 1
        }
        time.Sleep(time.Second * time.Duration(common.Config.Cycle) * 60)
    }
}

func (a Agent) put() {
    _, err := a.Client.Go(a.ctx, &quot;PutInfo&quot;, &amp;a.PutData, &amp;a.Reply, nil)
    if err != nil {
        a.log(&quot;PutInfo error:&quot;, err.Error())
    }
}</code></pre><pre><code>func GetAllInfo() map[string][]map[string]string {
    allInfo[&quot;listening&quot;] = GetListening()
    allInfo[&quot;service&quot;] = GetServiceInfo()
    allInfo[&quot;userlist&quot;] = GetUser()
    allInfo[&quot;startup&quot;] = GetStartup()
    allInfo[&quot;crontab&quot;] = GetCrontab()
    allInfo[&quot;loginlog&quot;] = GetLoginLog()
    allInfo[&quot;processlist&quot;] = GetProcessList()
    return allInfo
}</code></pre><p>各子模块功能如下：</p>
<p><strong>Computerinfo_linux</strong></p>
<p>获取agent部署主机的内核版本、架构等计算机信息存放到info结构体内；并在最后调用discern函数获取web服务路径，这个在init.go函数中有说明：</p>
<pre><code>func GetComInfo() (info common.ComputerInfo) {
    info.IP = common.LocalIP
    info.Hostname, _ = os.Hostname()
    out := common.Cmdexec(&quot;uname -r&quot;)
    dat, err := ioutil.ReadFile(&quot;/etc/redhat-release&quot;)
    if err != nil {
        dat, _ = ioutil.ReadFile(&quot;/etc/issue&quot;)
        issue := strings.SplitN(string(dat), &quot;\n&quot;, 2)[0]
        out2 := common.Cmdexec(&quot;uname -m&quot;)
        info.System = issue + &quot; &quot; + out + out2
    } else {
        info.System = string(dat) + &quot; &quot; + out
    }
    discern(&amp;info)
    return info
}</code></pre><p><strong>crontab_linux</strong></p>
<p>获取agent所在主机的系统及用户计划任务，并分字段解析</p>
<pre><code>func GetCrontab() (resultData []map[string]string) {
    //系统计划任务
    dat, err := ioutil.ReadFile(&quot;/etc/crontab&quot;)
    if err != nil {
        return resultData
    }
    cronList := strings.Split(string(dat), &quot;\n&quot;)
    for _, info := range cronList {
        if strings.HasPrefix(info, &quot;#&quot;) || strings.Count(info, &quot; &quot;) &lt; 6 {
            continue
        }
        s := strings.SplitN(info, &quot; &quot;, 7)
        rule := strings.Split(info, &quot; &quot;+s[5])[0]
        m := map[string]string{&quot;command&quot;: s[6], &quot;user&quot;: s[5], &quot;rule&quot;: rule}
        resultData = append(resultData, m)
    }

    //用户计划任务
    dir, err := ioutil.ReadDir(&quot;/var/spool/cron/&quot;)
    if err != nil {
        return resultData
    }
    for _, f := range dir {
        if f.IsDir() {
            continue
        }
        dat, err = ioutil.ReadFile(&quot;/var/spool/cron/&quot; + f.Name())
        if err != nil {
            continue
        }
        cronList = strings.Split(string(dat), &quot;\n&quot;)
        for _, info := range cronList {
            if strings.HasPrefix(info, &quot;#&quot;) || strings.Count(info, &quot; &quot;) &lt; 5 {
                continue
            }
            s := strings.SplitN(info, &quot; &quot;, 6)
            rule := strings.Split(info, &quot; &quot;+s[5])[0]
            m := map[string]string{&quot;command&quot;: s[5], &quot;user&quot;: f.Name(), &quot;rule&quot;: rule}
            resultData = append(resultData, m)
        }
    }
    return resultData</code></pre><p><strong>Listen_linux</strong></p>
<p>调ss -nltp获取当前主机监听的所有tcp连接，过滤掉127.0.0.1，检测local address：port字段中是否存在::或*特殊字符，若有，换成0.0.0.0，其它过滤等等，最终将address、pid、pname放到map中</p>
<pre><code>func GetListening() (resultData []map[string]string) {
    listeningStr := common.Cmdexec(&quot;ss -nltp&quot;)
    listeningList := strings.Split(listeningStr, &quot;\n&quot;)
    if len(listeningList) &lt; 2 {
        return
    }
    for _, info := range listeningList[1 : len(listeningList)-1] {
        if strings.Contains(info, &quot;127.0.0.1&quot;) {
            continue
        }
        m := make(map[string]string)
        reg := regexp.MustCompile(&quot;\\s+&quot;)
        info = reg.ReplaceAllString(strings.TrimSpace(info), &quot; &quot;)
        s := strings.Split(info, &quot; &quot;)
        if len(s) &lt; 6 {
            continue
        }
        m[&quot;proto&quot;] = &quot;TCP&quot;
        if strings.Contains(s[3],&quot;::&quot;){
            m[&quot;address&quot;] = strings.Replace(s[3], &quot;::&quot;, &quot;0.0.0.0&quot;, 1)
        }else{
            m[&quot;address&quot;] = strings.Replace(s[3], &quot;*&quot;, &quot;0.0.0.0&quot;, 1)
        }
        b := false
        for _,v:= range resultData{
            if v[&quot;address&quot;] == m[&quot;address&quot;]{
                b = true
                break
            }
        }
        if b{
            continue
        }
        reg = regexp.MustCompile(`users:\(\(&quot;(.*?)&quot;,(.*?),.*?\)`)
        r := reg.FindSubmatch([]byte(s[5]))
        if strings.Contains(string(r[2]), &quot;=&quot;) {
            m[&quot;pid&quot;] = strings.SplitN(string(r[2]), &quot;=&quot;, 2)[1]
        } else {
            m[&quot;pid&quot;] = string(r[2])
        }
        m[&quot;name&quot;] = string(r[1])
        resultData = append(resultData, m)
    }
    return resultData
}</code></pre><p><strong>login_log</strong></p>
<p>解析/var/log/wtmp或运行lastb命令获取当前主机所有用户登陆信息：</p>
<pre><code>type utmp struct {
    UtType uint32
    UtPid  uint32    // PID of login process
    UtLine [32]byte  // device name of tty - &quot;/dev/&quot;
    UtID   [4]byte   // init id or abbrev. ttyname
    UtUser [32]byte  // user name
    UtHost [256]byte // hostname for remote login
    UtExit struct {
        ETermination uint16 // process termination status
        EExit        uint16 // process exit status
    }
    UtSession uint32 // Session ID, used for windowing
    UtTv      struct {
        TvSec  uint32 /* Seconds */
        TvUsec uint32 /* Microseconds */
    }
    UtAddrV6 [4]uint32 // IP address of remote host
    Unused   [20]byte  // Reserved for future use
}

func getLast(t string) (result []map[string]string) {
    var timestamp int64
    if t == &quot;all&quot; {
        timestamp = 615147123
    } else {
        ti, _ := time.Parse(&quot;2006-01-02T15:04:05Z07:00&quot;, t)
        timestamp = ti.Unix()
    }
    wtmpFile, err := os.Open(&quot;/var/log/wtmp&quot;)
    if err != nil {
        log.Println(err.Error())
        return
    }
    defer wtmpFile.Close()
    for {
        wtmp := new(utmp)
        err = binary.Read(wtmpFile, binary.LittleEndian, wtmp)
        if err != nil {
            break
        }
        if wtmp.UtType == 7 &amp;&amp; int64(wtmp.UtTv.TvSec) &gt; timestamp {
            m := make(map[string]string)
            m[&quot;status&quot;] = &quot;true&quot;
            m[&quot;remote&quot;] = string(bytes.TrimRight(wtmp.UtHost[:], &quot;\x00&quot;))
            if m[&quot;remote&quot;] == &quot;&quot; {
                continue
            }
            m[&quot;username&quot;] = string(bytes.TrimRight(wtmp.UtUser[:], &quot;\x00&quot;))
            m[&quot;time&quot;] = time.Unix(int64(wtmp.UtTv.TvSec), 0).Format(&quot;2006-01-02T15:04:05Z07:00&quot;)
            result = append(result, m)
        }
    }
    return result
}
func getLastb(t string) (result []map[string]string) {
    var cmd string
    ti, _ := time.Parse(&quot;2006-01-02T15:04:05Z07:00&quot;, t)
    if t == &quot;all&quot; {
        cmd = &quot;lastb --time-format iso&quot;
    } else {
        cmd = fmt.Sprintf(&quot;lastb -s %s --time-format iso&quot;, ti.Format(&quot;20060102150405&quot;))
    }
    out := common.Cmdexec(cmd)
    logList := strings.Split(out, &quot;\n&quot;)
    for _, v := range logList[0 : len(logList)-3] {
        m := make(map[string]string)
        reg := regexp.MustCompile(&quot;\\s+&quot;)
        v = reg.ReplaceAllString(strings.TrimSpace(v), &quot; &quot;)
        s := strings.Split(v, &quot; &quot;)
        if len(s) &lt; 4 {
            continue
        }
        m[&quot;status&quot;] = &quot;false&quot;
        m[&quot;username&quot;] = s[0]
        m[&quot;remote&quot;] = s[2]
        t, _ := time.Parse(&quot;2006-01-02T15:04:05Z0700&quot;, s[3])
        m[&quot;time&quot;] = t.Format(&quot;2006-01-02T15:04:05Z07:00&quot;)
        result = append(result, m)
    }
    return
}
func GetLoginLog() (resultData []map[string]string) {
    resultData = getLast(common.Config.Lasttime)
    resultData = append(resultData, getLastb(common.Config.Lasttime)...)
    return
}</code></pre><p><strong>process_linux</strong></p>
<p>getprocesslist函数解析当前主机/proc目录获取当前运行的所有进程信息缓存全局变量中；getcmdline函数根据pid获取指定进程cmdline；getstatus函数解析/proc/pid/status中的信息；dirsUnder函数调用readdir返回/proc/子目录方便getprocesslist进行遍历：</p>
<pre><code>func GetProcessList() (resultData []map[string]string) {
    var dirs []string
    var err error
    dirs, err = dirsUnder(&quot;/proc&quot;)
    if err != nil || len(dirs) == 0 {
        return
    }
    for _, v := range dirs {
        pid, err := strconv.Atoi(v)
        if err != nil {
            continue
        }
        statusInfo := getStatus(pid)
        command := getcmdline(pid)
        m := make(map[string]string)
        m[&quot;pid&quot;] = v
        m[&quot;ppid&quot;] = statusInfo[&quot;PPid&quot;]
        m[&quot;name&quot;] = statusInfo[&quot;Name&quot;]
        m[&quot;command&quot;] = command
        resultData = append(resultData, m)
    }
    return
}
func getcmdline(pid int) string {
    cmdlineFile := fmt.Sprintf(&quot;/proc/%d/cmdline&quot;, pid)
    cmdlineBytes, e := ioutil.ReadFile(cmdlineFile)
    if e != nil {
        return &quot;&quot;
    }
    cmdlineBytesLen := len(cmdlineBytes)
    if cmdlineBytesLen == 0 {
        return &quot;&quot;
    }
    for i, v := range cmdlineBytes {
        if v == 0 {
            cmdlineBytes[i] = 0x20
        }
    }
    return strings.TrimSpace(string(cmdlineBytes))
}
func getStatus(pid int) (status map[string]string) {
    status = make(map[string]string)
    statusFile := fmt.Sprintf(&quot;/proc/%d/status&quot;, pid)
    var content []byte
    var err error
    content, err = ioutil.ReadFile(statusFile)
    if err != nil {
        return
    }
    for _, line := range strings.Split(string(content), &quot;\n&quot;) {
        if strings.Contains(line, &quot;:&quot;) {
            kv := strings.SplitN(line, &quot;:&quot;, 2)
            status[kv[0]] = strings.TrimSpace(kv[1])
        }
    }
    return
}

func dirsUnder(dirPath string) ([]string, error) {
    fs, err := ioutil.ReadDir(dirPath)
    if err != nil {
        return []string{}, err
    }

    sz := len(fs)
    if sz == 0 {
        return []string{}, nil
    }
    ret := make([]string, 0, sz)
    for i := 0; i &lt; sz; i++ {
        if fs[i].IsDir() {
            name := fs[i].Name()
            if name != &quot;.&quot; &amp;&amp; name != &quot;..&quot; {
                ret = append(ret, name)
            }
        }
    }
    return ret, nil
}</code></pre><p><strong>user_linux</strong></p>
<p>解析/etc/passwd中所有用户，过滤掉默认bash为nologin的用户，即无权限登陆的用户，最终返回用户名和描述组成的map：</p>
<pre><code>// GetUser 获取系统用户列表
func GetUser() (resultData []map[string]string) {
    dat, err := ioutil.ReadFile(&quot;/etc/passwd&quot;)
    if err != nil {
        return resultData
    }
    userList := strings.Split(string(dat), &quot;\n&quot;)
    if len(userList) &lt; 2 {
        return
    }
    for _, info := range userList[0 : len(userList)-2] {
        if strings.Contains(info, &quot;/nologin&quot;) {
            continue
        }
        s := strings.SplitN(info, &quot;:&quot;, 2)
        m := map[string]string{&quot;name&quot;: s[0], &quot;description&quot;: s[1]}
        resultData = append(resultData, m)
    }
    return resultData
}</code></pre><p><strong>web_path</strong></p>
<p>检测参数是否与apache、httpd、nginx字符串相似（正则匹配），若相似，说明主机上可能存在此服务，此时就可以直接调用命令获取当前主机的所有web路径，最终返回当前主机所有web服务路径列表：</p>
<pre><code>func getWebPath(webCommand string) ([]string, error) {
    var pathList []string
    if ok, _ := regexp.MatchString(`httpd|apache`, webCommand); ok {
        out := common.Cmdexec(&quot;apachectl -V&quot;)
        if !strings.Contains(string(out), &quot;SERVER_CONFIG_FILE&quot;) {
            return pathList, errors.New(&quot;Get ConfigFilePath Error!&quot;)
        }
        reg2 := regexp.MustCompile(`HTTPD_ROOT=&quot;(.*?)&quot;`)
        reg := regexp.MustCompile(`SERVER_CONFIG_FILE=&quot;(.*?)&quot;`)
        configFilePath := reg2.FindStringSubmatch(string(out))[1] + &quot;/&quot; + reg.FindStringSubmatch(string(out))[1]
        if configFilePath != &quot;/&quot; {
            dat, err := ioutil.ReadFile(configFilePath)
            if err != nil {
                return pathList, err
            }
            reg = regexp.MustCompile(`&lt;Directory &quot;(.*?)&quot;&gt;`)
            pathM := reg.FindAllSubmatch([]byte(dat), -1)
            for _, info := range pathM {
                pathList = append(pathList, string(info[1]))
            }
        }
    } else if strings.Contains(webCommand, &quot;nginx&quot;) {
        out := common.Cmdexec(&quot;nginx -V&quot;)
        regex, _ := regexp.Compile(`\-\-conf\-path\=(.*?)[ |$]`)
        result := regex.FindStringSubmatch(out)
        if len(result) &gt;= 2 {
            configFilePath := result[1]
            dat, err := ioutil.ReadFile(configFilePath)
            if err != nil {
                return pathList, err
            }
            pathRegex, _ := regexp.Compile(`root (.*?)\;`)
            pathResult := pathRegex.FindStringSubmatch(string(dat))
            if len(pathResult) &gt;= 2 {
                pathList = append(pathList, pathResult[1])
            }
            sitePath := filepath.Dir(configFilePath) + &quot;/sites-available/&quot;
            dirList, _ := ioutil.ReadDir(sitePath)
            for _, v := range dirList {
                if v.IsDir() {
                    continue
                }
                dat, err := ioutil.ReadFile(sitePath + v.Name())
                if err != nil {
                    continue
                }
                pathResult = pathRegex.FindStringSubmatch(string(dat))
                if len(pathResult) &gt;= 2 {
                    pathList = append(pathList, pathResult[1])
                }
            }
        }
    }
    return pathList, nil</code></pre><p><strong>Init</strong></p>
<p>GetAllInfo函数调用collect模块的各子模块获取主机信息；discern函数调用GetProcessList缓存进程信息后与硬编码服务信息进行匹配，若检测到缓存的进程信息中存在硬编码中指定的进程名，则认定当前主机存在此服务，若同时此agent部署主机类型为web，则调用getWebPath根据不同服务类型解析具体服务路径信息；removeDuplicatesAndEmpty这个去重模块好像没有调用者；另外需要注意的是，此函数内部起了一个线程每1h调用一次GetComInfo获取系统信息等：</p>
<pre><code>var allInfo = make(map[string][]map[string]string)

var tagMap = map[string]string{
    &quot;web&quot;: `nginx|httpd|apache|w3wp\.exe|tomcat|weblogic|jboss|jetty`,
    &quot;db&quot;:  `mysql|mongo|sqlservr\.exe|oracle|elasticsearch|postgres|redis|cassandra|teradata|solr|HMaster|hbase|mariadb`,
}

func init() {
    go func() {
        time.Sleep(time.Second * 3600)
        common.ServerInfo = GetComInfo()
    }()
}

// GetAllInfo 获取所有收集的信息
func GetAllInfo() map[string][]map[string]string {
    allInfo[&quot;listening&quot;] = GetListening()
    allInfo[&quot;service&quot;] = GetServiceInfo()
    allInfo[&quot;userlist&quot;] = GetUser()
    allInfo[&quot;startup&quot;] = GetStartup()
    allInfo[&quot;crontab&quot;] = GetCrontab()
    allInfo[&quot;loginlog&quot;] = GetLoginLog()
    allInfo[&quot;processlist&quot;] = GetProcessList()
    return allInfo
}

func discern(info *common.ComputerInfo) {
    for k, v := range tagMap {
        for _, p := range GetProcessList() {
            if p[&quot;command&quot;] == &quot;&quot; {
                continue
            }
            if ok, _ := regexp.MatchString(v, p[&quot;command&quot;]); ok {
                info.Type = k
                if k == &quot;web&quot; {
                    info.Path, _ = getWebPath(p[&quot;command&quot;])
                    // web优先，匹配到web就退出，其他一直匹配下去
                    return
                }
            }
        }
    }
}

func removeDuplicatesAndEmpty(list []string) (ret []string) {
    listLen := len(list)
    for i := 0; i &lt; listLen; i++ {
        if (i &gt; 0 &amp;&amp; list[i-1] == list[i]) || len(list[i]) == 0 {
            continue
        }
        ret = append(ret, list[i])
    }
    return
}</code></pre><p><strong>getInfo</strong></p>
<p>agent模块的init子模块函数的调用者为agent/client/agent.go中的a.getInfo()，函数内部调用了agent/collect/init.go中的GetAllInfo()函数，</p>
<pre><code>func (a *Agent) getInfo() {
    historyCache := make(map[string][]map[string]string)
    for {
        if len(common.Config.MonitorPath) == 0 {
            time.Sleep(time.Second)
            a.log(&quot;Failed to get the configuration information&quot;)
            continue
        }
        allData := collect.GetAllInfo()</code></pre><h3 id="Daemon-1"><a href="#Daemon-1" class="headerlink" title="Daemon"></a>Daemon</h3><h4 id="main-1"><a href="#main-1" class="headerlink" title="main"></a>main</h4><p>先从main开始看，和agent类似，最开始是参数解析，不过这块应该不是同一个人写的，daemon这边直接用flag库去做解析了；daemon支持install、uninstall、register及netloc string三种参数运行；参数解析结果分别存放到对应变量中：</p>
<pre><code>flag.StringVar(&amp;common.ServerIP, &quot;netloc&quot;, &quot;&quot;, &quot;* WebServer 192.168.1.100:443&quot;)
    installBool = flag.Bool(&quot;install&quot;, false, &quot;Install yulong-hids service&quot;)
    uninstallBool = flag.Bool(&quot;uninstall&quot;, false, &quot;Remove yulong-hids service&quot;)
    registeredBool = flag.Bool(&quot;register&quot;, false, &quot;Registration yulong-hids service&quot;)
    flag.Parse()</code></pre><h4 id="task"><a href="#task" class="headerlink" title="task"></a>task</h4><p><strong>uninstall</strong></p>
<p>若检测到正确的uninstall参数，daemon首先卸载进程监控的lkm，之后kill掉agent，然后卸载掉daemon自身注册的服务，最后os.exit(1)退出：</p>
<pre><code>    if *uninstallBool {
        task.UnInstallALL()
        return
    }</code></pre><pre><code>// UnInstallALL 卸载
func UnInstallALL() {
    if runtime.GOOS == &quot;windows&quot; {
        common.CmdExec(&quot;net stop pro&quot;)
        // common.CmdExec(&quot;net stop npf&quot;)
        common.CmdExec(&quot;sc delete pro&quot;)
        // common.CmdExec(&quot;sc delete npf&quot;)
    } else {
        common.CmdExec(&quot;rmmod syshook_execve&quot;)
    }
    common.KillAgent()
    if err := common.Service.Uninstall(); err != nil {
        log.Println(&quot;Uninstall yulong-hids error:&quot;, err.Error())
    }
    log.Println(&quot;Uninstall completed&quot;)
    os.Exit(1)
}</code></pre><pre><code>func KillAgent() error {
    if AgentStatus {
        return Cmd.Process.Kill()
    }
    return nil
}</code></pre><p><strong>install</strong></p>
<p>若参数为install，则进入daemon的静默安装流程；首先检测路径硬编码的daemon安装路径是否存在（common.go中定义），若不存在，则mkdir新建；之后调用install.Dependency函数进行依赖环境的安装：</p>
<pre><code>    if *installBool {
        // 依赖环境安装
        if _, err = os.Stat(common.InstallPath); err != nil {
            os.Mkdir(common.InstallPath, 0)
            err = install.Dependency(common.ServerIP, common.InstallPath, common.Arch)
            if err != nil {
                log.Println(&quot;Install dependency, service error:&quot;, err.Error())
                return
            }
        }</code></pre><p>跟进此agent/daemon/install/dependence_linux.go中的Dependency函数，首先发现daemon会从server下载进程监控对应lkm的压缩包到指定目录下，里面包含不同内核版本下的内核模块；之后会将内核模块名与主机uname -r的结果进行比较，若解压后的压缩包内存在内核模块文件名与当前主机系统内核版本一致，则进行insmod安装：</p>
<pre><code>
func Dependency(ip string, installPath string, arch string) error {
    // _, err := os.Stat(&quot;/usr/lib64/libpcap.so.1&quot;)
    // if err != nil {
    //     return err
    // }
    url := fmt.Sprintf(&quot;%s://%s/json/download?system=linux&amp;platform=%s&amp;type=data&amp;action=download&quot;, common.Proto, ip, arch)
    pcappath := installPath + &quot;data.zip&quot;
    log.Println(&quot;Download dependent environment package&quot;)
    err := downFile(url, pcappath)
    if err != nil {
        return err
    }
    rc, err := zip.OpenReader(pcappath)
    if err != nil {
        return err
    }
    defer rc.Close()
    out, err := common.CmdExec(&quot;uname -r&quot;)
    if err != nil || strings.Count(out, &quot;.&quot;) &lt; 2 {
        return errors.New(&quot;Get kernel version identification&quot;)
    }
    ver := strings.Join(strings.Split(strings.Trim(out, &quot;\n&quot;), &quot;.&quot;)[0:3], &quot;.&quot;)
    for _, _file := range rc.File {
        if _file.Name == &quot;syshook_&quot;+ver+&quot;.ko&quot; {
            f, _ := _file.Open()
            desfile, err := os.OpenFile(installPath+&quot;syshook_execve.ko&quot;, os.O_CREATE|os.O_WRONLY, os.ModePerm)
            if err != nil {
                return err
            }
            io.CopyN(desfile, f, int64(_file.UncompressedSize64))
            desfile.Close()
            log.Println(&quot;Use syshook_&quot; + ver)
            out, err = common.CmdExec(fmt.Sprintf(&quot;insmod %s/syshook_execve.ko&quot;, installPath))
            if err != nil {
                return err
            }
            if !strings.Contains(out, &quot;ERROR&quot;) {
                log.Println(&quot;Insmod syshook_execve succeeded&quot;)
            } else {
                log.Println(&quot;Insmod syshook_execve error, command output:&quot;, out)
            }
        }
    }
    return nil
}</code></pre><p>安装完依赖之后开始安装agent：</p>
<pre><code>        err := install.Agent(common.ServerIP, common.InstallPath, common.Arch)
        if err != nil {
            log.Println(&quot;Install agent error:&quot;, err.Error())
            return
        }
        log.Println(&quot;Installed!&quot;)
        return
    }</code></pre><p>跟进agent/daemon/install/agent_linux.go中的Agent函数，发现它会调用同目录下lib.go中的DownAgent从server下载编译好的agent执行文件并拷贝到对应项目安装目录，同时将安装目录下的daemon注册为服务，并在最终启动服务：</p>
<pre><code>
func Agent(ip string, installPath string, arch string) error {
    // 下载agent
    log.Println(&quot;Download Agent&quot;)
    err := DownAgent(ip, installPath+&quot;agent&quot;, arch)
    if err != nil {
        return err
    }
    // 拷贝自身到安装目录
    log.Println(&quot;Copy the daemon to the installation directory&quot;)
    err = copyMe(installPath)
    if err != nil {
        return err
    }
    // 安装daemon为服务
    os.Chmod(installPath+&quot;daemon&quot;, 0750)
    cmd := installPath + &quot;daemon -register -netloc &quot; + ip
    out, err := common.CmdExec(cmd)
    if err != nil {
        return err
    }
    //启动服务
    log.Println(&quot;Start the service&quot;)
    cmd = &quot;systemctl start yulong-hids&quot;
    out, err = common.CmdExec(cmd)
    if err == nil &amp;&amp; len(out) == 0 {
        log.Println(&quot;Start service successfully&quot;)
    }
    return nil
}</code></pre><pre><code>func DownAgent(ip string, agentPath string, arch string) error {
    var err error
    url := fmt.Sprintf(&quot;%s://%s/json/download?system=%s&amp;platform=%s&amp;type=agent&amp;action=download&quot;, common.Proto, ip, runtime.GOOS, arch)

    // Agent 下载检查和重试, 重试三次，功能性考虑
    times := 3
    for {
        err = downFile(url, agentPath)
        // 检查文件hash是否匹配
        if err == nil {
            mstr, _ := FileMD5String(agentPath)
            log.Println(&quot;Agent file MD5:&quot;, mstr)
            if CheckAgentHash(mstr, ip, arch) {
                log.Println(&quot;Agent download finished, hash check passed&quot;)
                return nil
            } else {
                log.Println(&quot;Agent is broken, retry the downloader again&quot;)
            }
        }
        if times--; times == 0 {
            break
        }
    }

    return errors.New(&quot;Agent Download Error&quot;)
}</code></pre><pre><code>func downFile(url string, svaepath string) error {
    request, _ := http.NewRequest(&quot;GET&quot;, url, nil)
    request.Close = true
    if res, err := common.HTTPClient.Do(request); err == nil {
        defer res.Body.Close()
        file, err := os.Create(svaepath)
        if err != nil {
            return err
        }
        io.Copy(file, res.Body)
        file.Close()
        if runtime.GOOS == &quot;linux&quot; {
            os.Chmod(svaepath, 0750)
        }
        fileInfo, err := os.Stat(svaepath)
        // log.Println(res.ContentLength, fileInfo.Size())
        if err != nil || fileInfo.Size() != res.ContentLength {
            log.Println(&quot;File download error:&quot;, err.Error())
            return errors.New(&quot;downfile error&quot;)
        }
    } else {
        return err
    }
    return nil
}</code></pre><p><strong>register</strong></p>
<p>注册daemon为系统服务，调用了kardianos开源项目api，本质上封装了linux系统systemd相关；若注册成功，则启动服务：</p>
<pre><code>    if *registeredBool {
        err = common.Service.Install()
        if err != nil {
            log.Println(&quot;Install daemon as service error:&quot;, err.Error())
        } else {
            if err = common.Service.Start(); err != nil {
                log.Println(&quot;Service start error:&quot;, err.Error())
            } else {
                log.Println(&quot;Install as a service&quot;, &quot;ok&quot;)
            }
        }
        return
    }</code></pre><p><strong>run</strong></p>
<p>运行daemon服务进程：</p>
<pre><code>    err = common.Service.Run()
    if err != nil {
        log.Println(&quot;Service run error:&quot;, err.Error())
    }</code></pre><p>起一个线程调用exec启动agent，线程运行期间有一些加锁操作，猜测是防止线程抢占；启动成功后，agentstatus置位，线程等待agent执行完毕，一旦检测到agent线程退出，则主线程从wait状态中被唤醒，重新运行agent：</p>
<pre><code>func (p *program) Start(s service.Service) error {
    go p.run()
    return nil
}

func (p *program) run() {
    go task.WaitThread()
    var agentFilePath string
    if runtime.GOOS == &quot;windows&quot; {
        agentFilePath = common.InstallPath + &quot;agent.exe&quot;
    } else {
        agentFilePath = common.InstallPath + &quot;agent&quot;
    }
    for {
        common.M.Lock()
        log.Println(&quot;Start Agent&quot;)
        common.Cmd = exec.Command(agentFilePath, common.ServerIP)
        err := common.Cmd.Start()
        common.M.Unlock()
        if err == nil {
            common.AgentStatus = true
            log.Println(&quot;Start Agent successful&quot;)
            err = common.Cmd.Wait()
            if err != nil {
                common.AgentStatus = false
                log.Println(&quot;Agent to exit：&quot;, err.Error())
            }
        } else {
            log.Println(&quot;Startup Agent failed&quot;, err.Error())
        }
        time.Sleep(time.Second * 10)
    }
}</code></pre><p>daemon启动接收任务的线程：</p>
<pre><code>    go task.WaitThread()</code></pre><p>启动线程做了这么几件事，首先调listen函数绑定65512端口并进行监听和等待accept；一旦有连接ip，确认是否为server，若是，则调用tcppipe进入通信阶段：</p>
<pre><code>func WaitThread() {
    setPublicKey()
    var t taskServer
    t.run()
}

func (t *taskServer) run() {
    err := t.listen()
    if err != nil {
        return
    }
    log.Println(&quot;Start the task listener thread&quot;)
    for {
        tcpConn, err := t.TCPListener.Accept()
        if err != nil {
            fmt.Println(&quot;Accept new TCP listener error:&quot;, err.Error())
            continue
        }
        t.ServerIP = strings.SplitN(tcpConn.RemoteAddr().String(), &quot;:&quot;, 2)[0]
        if t.isServer() {
            t.tcpPipe(tcpConn)
        } else {
            tcpConn.Close()
        }
    }
}</code></pre><p><strong>tcpPipe</strong></p>
<p>对从socket接收到的信息进行rsaDecrypt并将字符串数据转为json；之后对格式转换后的数据进行解析，取出type、command（任务类型、任务任务）两个字段信息，并将返回结果result字段和前两个字段组合传入传入task接收任务的结构体中，调用Run函数后将结果写入socket：</p>
<pre><code>func (t *taskServer) tcpPipe(conn net.Conn) {
    defer conn.Close()
    reader := bufio.NewReader(conn)
    message, err := reader.ReadBytes(&#39;\n&#39;)
    if err != nil {
        return
    }
    decodeBytes, _ := base64.RawStdEncoding.DecodeString(string(message))
    decryptdata, err := rsaDecrypt(decodeBytes)
    if err != nil {
        log.Println(&quot;Decrypt rsa text in tcpPipe error:&quot;, err.Error())
        return
    }
    var taskData map[string]string
    err = json.Unmarshal(decryptdata, &amp;taskData)
    if err != nil {
        log.Println(&quot;Unmarshal json text in tcpPipe error&quot;, err.Error())
        return
    }
    var taskType string
    var data string
    if _, ok := taskData[&quot;type&quot;]; ok {
        taskType = taskData[&quot;type&quot;]
    }
    if _, ok := taskData[&quot;command&quot;]; ok {
        data = taskData[&quot;command&quot;]
    }
    result := map[string]string{&quot;status&quot;: &quot;false&quot;, &quot;data&quot;: &quot;&quot;}
    T := Task{taskType, data, result}
    if sendResult := T.Run(); len(sendResult) != 0 {
        conn.Write(sendResult)
    }
}</code></pre><p><strong>tcp</strong></p>
<p>之后是根据任务类型（type）进行不同的逻辑处理，并将返回值存入结构体的result字段中返回给调用层：</p>
<pre><code>func (t *Task) Run() []byte {
    switch t.Type {
    case &quot;reload&quot;:
        t.reload()
    case &quot;quit&quot;:
        t.quit()
    case &quot;kill&quot;:
        t.kill()
    case &quot;uninstall&quot;:
        t.uninstall()
    case &quot;update&quot;:
        t.update()
    case &quot;delete&quot;:
        t.delete()
        // case &quot;exec&quot;:
        //     t.exec()
    }
    var sendResult []byte
    if b, err := json.Marshal(t.Result); err == nil {
        msg := string(b) + &quot;\n&quot;
        sendResult = []byte(msg)
    }
    return sendResult
}
func (t *Task) reload() {
    t.Result[&quot;status&quot;] = &quot;true&quot;
    if err := common.KillAgent(); err != nil {
        t.Result[&quot;status&quot;] = &quot;false&quot;
        t.Result[&quot;data&quot;] = err.Error()
    }
}
func (t *Task) quit() {
    if common.AgentStatus {
        common.Cmd.Process.Kill()
    }
    panic(1)
}
func (t *Task) kill() {
    if redata := KillProcess(t.Command); redata != &quot;&quot; {
        t.Result[&quot;status&quot;] = &quot;true&quot;
        t.Result[&quot;data&quot;] = redata
    }
}
func (t *Task) uninstall() {
    UnInstallALL()
}
func (t *Task) update() {
    if ok, err := agentUpdate(common.ServerIP, common.InstallPath, common.Arch); err == nil {
        if ok {
            t.Result[&quot;status&quot;] = &quot;true&quot;
            t.Result[&quot;data&quot;] = &quot;更新完毕&quot;
        } else {
            t.Result[&quot;status&quot;] = &quot;true&quot;
            t.Result[&quot;data&quot;] = &quot;已经是最新版本&quot;
        }
    } else {
        t.Result[&quot;data&quot;] = err.Error()
    }
}
func (t *Task) delete() {
    if err := os.Remove(t.Command); err == nil {
        t.Result[&quot;status&quot;] = &quot;true&quot;
        t.Result[&quot;data&quot;] = t.Command + &quot; 删除成功&quot;
    } else {
        t.Result[&quot;data&quot;] = err.Error()
    }
}
func (t *Task) exec() {
    if dat, err := common.CmdExec(t.Command); err == nil {
        t.Result[&quot;status&quot;] = &quot;true&quot;
        t.Result[&quot;data&quot;] = dat
    } else {
        t.Result[&quot;data&quot;] = err.Error()
    }
}</code></pre><h3 id="Server-1"><a href="#Server-1" class="headerlink" title="Server"></a>Server</h3><h4 id="main-2"><a href="#main-2" class="headerlink" title="main"></a>main</h4><p>加载证书，注册watcher为rpc服务，暴露出33433的tcp通信端口：</p>
<pre><code>func main() {
    cert, err := tls.LoadX509KeyPair(&quot;cert.pem&quot;, &quot;private.pem&quot;)
    if err != nil {
        log.Println(&quot;cert error!&quot;)
        return
    }
    config := &amp;tls.Config{Certificates: []tls.Certificate{cert}}
    s := server.NewServer(server.WithTLSConfig(config))
    s.AuthFunc = auth
    s.RegisterName(&quot;Watcher&quot;, new(Watcher), &quot;&quot;)
    log.Println(&quot;RPC Server started&quot;)
    err = s.Serve(&quot;tcp&quot;, &quot;:33433&quot;)
    if err != nil {
        log.Println(err.Error())
    }
}</code></pre><p>watcher类型的函数有getinfo和putinfo；前者用于根据agent提供的主机信息获取此主机具体配置返回给agent；后者用于接收agent产生的事件数据：</p>
<pre><code>func (w *Watcher) GetInfo(ctx context.Context, info *action.ComputerInfo, result *action.ClientConfig) error {
    action.ComputerInfoSave(*info)
    config := action.GetAgentConfig(info.IP)
    log.Println(&quot;getconfig:&quot;, info.IP)
    *result = config
    return nil
}
func (w *Watcher) PutInfo(ctx context.Context, datainfo *models.DataInfo, result *int) error {
    //保证数据正常
    if len(datainfo.Data) == 0 {
        return nil
    }
    datainfo.Uptime = time.Now()
    log.Println(&quot;putinfo:&quot;, datainfo.IP, datainfo.Type)
    err := action.ResultSave(*datainfo)
    if err != nil {
        log.Println(err)
    }
    err = action.ResultStat(*datainfo)
    if err != nil {
        log.Println(err)
    }
    safecheck.ScanChan &lt;- *datainfo
    *result = 1
    return nil
}</code></pre><p>跟进具体函数内部（server/action/）,发现是封装的一些事件统计、增删改查mongo和写es的操作，不再详述：</p>
<pre><code>func ComputerInfoSave(info ComputerInfo) {
    c := models.DB.C(&quot;client&quot;)
    info.Uptime = time.Now()
    c.Upsert(bson.M{&quot;ip&quot;: info.IP}, bson.M{&quot;$set&quot;: &amp;info})
    c.Update(bson.M{&quot;ip&quot;: info.IP, &quot;$or&quot;: []bson.M{bson.M{&quot;health&quot;: 1}, bson.M{&quot;health&quot;: nil}}}, bson.M{&quot;$set&quot;: bson.M{&quot;health&quot;: 0}})
}
func GetAgentConfig(ip string) ClientConfig {
    var clientRes client
    c := models.DB.C(&quot;config&quot;)
    c.Find(bson.M{&quot;type&quot;: &quot;client&quot;}).One(&amp;clientRes)
    config := clientRes.DIC
    var res filterres
    c.Find(bson.M{&quot;type&quot;: &quot;filter&quot;}).One(&amp;res)
    config.Filter = res.Dic
    lastTime, err := models.QueryLogLastTime(ip)
    if err != nil {
        log.Println(err.Error())
        config.Lasttime = &quot;all&quot;
    } else {
        config.Lasttime = lastTime
    }
    return config
}
func ResultSave(datainfo models.DataInfo) error {
    var err error
    // 登录日志、网络连接、进程创建、文件操作 存放在es，其余保存在mongodb
    if datainfo.Type == &quot;loginlog&quot; || datainfo.Type == &quot;connection&quot; || datainfo.Type == &quot;process&quot; || datainfo.Type == &quot;file&quot; {
        if datainfo.Type == &quot;loginlog&quot; {
            for _, logininfo := range datainfo.Data {
                time, _ := time.Parse(&quot;2006-01-02T15:04:05Z07:00&quot;, logininfo[&quot;time&quot;])
                delete(logininfo, &quot;time&quot;)
                esdata := models.ESSave{
                    IP:   datainfo.IP,
                    Data: logininfo,
                    Time: time,
                }
                models.InsertEs(datainfo.Type, esdata)
            }
        } else {
            dataTimeInt, err := strconv.Atoi(datainfo.Data[0][&quot;time&quot;])
            if err != nil {
                return err
            }
            delete(datainfo.Data[0], &quot;time&quot;)
            esdata := models.ESSave{
                IP:   datainfo.IP,
                Data: datainfo.Data[0],
                Time: time.Unix(int64(dataTimeInt), 0),
            }
            models.InsertEs(datainfo.Type, esdata)
        }
    } else {
        c := models.DB.C(&quot;info&quot;)
        count, _ := c.Find(bson.M{&quot;ip&quot;: datainfo.IP, &quot;type&quot;: datainfo.Type}).Count()
        if count &gt;= 1 {
            err = c.Update(bson.M{&quot;ip&quot;: datainfo.IP, &quot;type&quot;: datainfo.Type},
                bson.M{&quot;$set&quot;: bson.M{&quot;data&quot;: datainfo.Data, &quot;uptime&quot;: datainfo.Uptime}})
        } else {
            err = c.Insert(&amp;datainfo)
        }
        return err
    }
    return nil
}
func ResultStat(datainfo models.DataInfo) error {
    var err error
    c := models.DB.C(&quot;statistics&quot;)
    mainMapping := map[string]string{
        &quot;process&quot;:    &quot;name&quot;,
        &quot;userlist&quot;:   &quot;name&quot;,
        &quot;listening&quot;:  &quot;address&quot;,
        &quot;connection&quot;: &quot;remote&quot;,
        &quot;loginlog&quot;:   &quot;remote&quot;,
        &quot;startup&quot;:    &quot;name&quot;,
        &quot;crontab&quot;:    &quot;command&quot;,
        &quot;service&quot;:    &quot;name&quot;,
        // &quot;processlist&quot;: &quot;name&quot;,
    }
    if _, ok := mainMapping[datainfo.Type]; !ok {
        return nil
    }
    k := mainMapping[datainfo.Type]
    ip := datainfo.IP
    for _, v := range datainfo.Data {
        if datainfo.Type == &quot;connection&quot; {
            v[k] = strings.Split(v[k], &quot;:&quot;)[0]
        }
        count, _ := c.Find(bson.M{&quot;info&quot;: v[k], &quot;type&quot;: datainfo.Type}).Count()
        if count &gt;= 1 {
            err = c.Update(bson.M{&quot;info&quot;: v[k], &quot;type&quot;: datainfo.Type}, bson.M{
                &quot;$set&quot;:      bson.M{&quot;uptime&quot;: datainfo.Uptime},
                &quot;$inc&quot;:      bson.M{&quot;count&quot;: 1},
                &quot;$addToSet&quot;: bson.M{&quot;server_list&quot;: ip}})
        } else {
            serverList := []string{ip}
            err = c.Insert(bson.M{&quot;type&quot;: datainfo.Type, &quot;info&quot;: v[k], &quot;count&quot;: 1,
                &quot;server_list&quot;: serverList, &quot;uptime&quot;: datainfo.Uptime})
        }
    }
    return err
}</code></pre><p><strong>intit</strong></p>
<p>分别跟进models.heartbeat、action.taskthread、safecheck.scanmonitorthread、safecheck.HealthCheckThread及models.insertthread五个重要调用：</p>
<pre><code>func init() {
    log.Println(models.Config)
    // 从数据库获取证书和RSA私钥
    ioutil.WriteFile(&quot;cert.pem&quot;, []byte(models.Config.Cert), 0666)
    ioutil.WriteFile(&quot;private.pem&quot;, []byte(models.Config.Private), 0666)
    // 启动心跳线程
    go models.Heartbeat()
    // 启动推送任务线程
    go action.TaskThread()
    // 启动安全检测线程
    go safecheck.ScanMonitorThread()
    // 启动客户端健康检测线程
    go safecheck.HealthCheckThread()
    // ES异步写入线程
    go models.InsertThread()
}</code></pre><h4 id="models"><a href="#models" class="headerlink" title="models"></a>models</h4><p><strong>init</strong></p>
<p>参数解析不再详述，server启动后首先连接到mongodb的agent库，然后调setconfig获取数据库中的相关配置信息（控制台相关），调setrules获取异常规则，调用结果保存在全局变量中：</p>
<pre><code>func init() {
    mongodb = flag.String(&quot;db&quot;, &quot;&quot;, &quot;mongodb ip:port&quot;)
    es = flag.String(&quot;es&quot;, &quot;&quot;, &quot;elasticsearch ip:port&quot;)
    flag.Parse()
    if len(os.Args) &lt;= 2 {
        flag.PrintDefaults()
        os.Exit(1)
    }
    if strings.HasPrefix(*mongodb, &quot;127.&quot;) || strings.HasPrefix(*mongodb, &quot;localhost&quot;) {
        log.Println(&quot;mongodb Can not be 127.0.0.1&quot;)
        os.Exit(1)
    }
    DB, err = conn(*mongodb, &quot;agent&quot;)
    if err != nil {
        log.Println(err.Error())
        flag.PrintDefaults()
        os.Exit(1)
    }
    LocalIP, err = getLocalIP(*mongodb)
    if err != nil {
        log.Println(err)
        os.Exit(1)
    }
    log.Println(&quot;Get Config&quot;)
    setConfig()
    setRules()
    go esCheckThread()
}</code></pre><pre><code>func setConfig() {
    c := DB.C(&quot;config&quot;)
    res := configres{}
    c.Find(bson.M{&quot;type&quot;: &quot;server&quot;}).One(&amp;res)

    res2 := intelligencegres{}
    c.Find(bson.M{&quot;type&quot;: &quot;intelligence&quot;}).One(&amp;res2)

    res3 := blackListres{}
    c.Find(bson.M{&quot;type&quot;: &quot;blacklist&quot;}).One(&amp;res3)

    res4 := whiteListres{}
    c.Find(bson.M{&quot;type&quot;: &quot;whitelist&quot;}).One(&amp;res4)

    res5 := noticeres{}
    c.Find(bson.M{&quot;type&quot;: &quot;notice&quot;}).One(&amp;res5)

    Config = res.Dic
    Config.Intelligence = res2.Dic
    Config.BlackList = res3.Dic
    Config.WhiteList = res4.Dic
    Config.Notice = res5.Dic
}</code></pre><pre><code>func setRules() {
    c := DB.C(&quot;rules&quot;)
    c.Find(bson.M{&quot;enabled&quot;: true}).All(&amp;RuleDB)
}</code></pre><p>然后起一个线程跑escheckthread检测es中是否存在monitor_2020的索引表，1h跑一次，若没有此索引，则新建：</p>
<pre><code>func esCheckThread() {
    ticker := time.NewTicker(time.Second * 3600)
    for _ = range ticker.C {
        nowDate := time.Now().Local().Format(&quot;2006_01&quot;)
        nowindicesName = &quot;monitor&quot; + nowDate
        indexNameList, err := Client.IndexNames()
        if err != nil {
            continue
        }
        if inArray(indexNameList, nowindicesName, false) {
            if time.Now().Local().Day() &gt;= 28 {
                nextData := time.Now().Local().AddDate(0, 1, 0).Format(&quot;2006_01&quot;)
                indicesName := &quot;monitor&quot; + nextData
                if !inArray(indexNameList, indicesName, false) {
                    newIndex(indicesName)
                }
            }
        } else {
            newIndex(nowindicesName)
        }
    }
}</code></pre><p><strong>heartbeat</strong></p>
<p>心跳线程，有四个函数调用，线程调度周期为30s：</p>
<pre><code>func Heartbeat() {
    log.Println(&quot;Start heartbeat thread&quot;)
    for {
        mgoCheck()
        regServer()
        setConfig()
        setRules()
        time.Sleep(time.Second * 30)
    }
}</code></pre><p><strong>mgocheck</strong></p>
<p>检测mongodb session是否过期，若过期，则刷新session：</p>
<pre><code>func mgoCheck() {
    err := DB.Session.Ping()
    if err != nil {
        log.Println(err.Error())
        DB.Session.Refresh()
    }
}</code></pre><p><strong>regServer</strong></p>
<p>修改mongo中的server表项更新server信息：</p>
<pre><code>func regServer() {
    c := DB.C(&quot;server&quot;)
    _, err := c.Upsert(bson.M{&quot;netloc&quot;: LocalIP + &quot;:33433&quot;}, bson.M{&quot;$set&quot;: bson.M{&quot;uptime&quot;: time.Now()}})
    if err != nil {
        log.Println(err.Error())
    }
}</code></pre><p>setconfig与setrules在init中已有说明</p>
<h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><p><strong>taskthread</strong></p>
<p>开启任务线程，从mongo中的queue表中获取每一条任务，调用sendtask进行任务下发：</p>
<pre><code>func TaskThread() {
    log.Println(&quot;Start Task Thread&quot;)
    threadpool = make(chan bool, 100)
    for {
        res := queue{}
        change := mgo.Change{
            Remove: true,
        }
        models.DB.C(&quot;queue&quot;).Find(bson.M{}).Limit(1).Apply(change, &amp;res)
        if res.IP == &quot;&quot; {
            time.Sleep(time.Second * 10)
            continue
        }
        threadpool &lt;- true
        go sendTask(res, threadpool)
    }
}
</code></pre><p><strong>sendtask</strong></p>
<p>向client的daemon守护进程所在的tcp：65512端口主动发起连接，并将经rsa加密过后的任务事件压入socket中发送给daemon，并从socket中接收来自daemon的返回结果，格式化后写入task_result表中：</p>
<pre><code>func sendTask(task queue, threadpool chan bool) {
    defer func() {
        &lt;-threadpool
    }()
    sendData := map[string]string{&quot;type&quot;: task.Type, &quot;command&quot;: task.Command}
    if data, err := json.Marshal(sendData); err == nil {
        conn, err := net.DialTimeout(&quot;tcp&quot;, task.IP+&quot;:65512&quot;, time.Second*3)
        log.Println(&quot;sendtask:&quot;, task.IP, sendData)
        if err != nil {
            saveError(task, err.Error())
            return
        }
        defer conn.Close()
        encryptData, err := rsaEncrypt(data)
        if err != nil {
            saveError(task, err.Error())
            return
        }
        conn.Write([]byte(base64.RawStdEncoding.EncodeToString(encryptData) + &quot;\n&quot;))
        reader := bufio.NewReader(conn)
        msg, err := reader.ReadString(&#39;\n&#39;)
        if err != nil || len(msg) == 0 {
            saveError(task, err.Error())
            return
        }
        log.Println(conn.RemoteAddr().String(), msg)
        res := taskResult{}
        err = json.Unmarshal([]byte(msg), &amp;res)
        if err != nil {
            saveError(task, err.Error())
            return
        }
        res.TaskID = task.TaskID
        res.Time = time.Now()
        res.IP = task.IP
        c := models.DB.C(&quot;task_result&quot;)
        err = c.Insert(&amp;res)
        if err != nil {
            saveError(task, err.Error())
            return
        }
    }
}</code></pre><h4 id="safecheck"><a href="#safecheck" class="headerlink" title="safecheck"></a>safecheck</h4><p><strong>ScanMonitorThread</strong></p>
<p>开启监控扫描线程，此线程又创建10个子线程，每个线程调用run函数进行检查：</p>
<pre><code>func ScanMonitorThread() {
    log.Println(&quot;Start Scan Thread&quot;)
    // 10个检测goroutine
    for i := 0; i &lt; 10; i++ {
        go func() {
            c := new(Check)
            c.CStatistics = models.DB.C(&quot;statistics&quot;)
            c.CNoice = models.DB.C(&quot;notice&quot;)
            for {
                c.Info = &lt;-ScanChan
                c.Run()
            }
        }()
    }
    ticker := time.NewTicker(time.Second * 60)
    for _ = range ticker.C {
        cache = []string{}
    }
}</code></pre><pre><code>func (c *Check) Run() {
    for _, c.V = range c.Info.Data {
        c.BlackFilter()
        if c.WhiteFilter() {
            continue
        }
        c.Rules()
        c.Intelligence()
    }
}</code></pre><p>info.data为agent传给server的所有事件，对其进行黑白名单的匹配，黑白名单在server初始化时从mongo中获取，即setconfig、setrules等函数，不再赘述；c.rules进行规则匹配，以下为本项目的规则引擎：</p>
<pre><code>func (c *Check) Rules() {
    for _, r := range models.RuleDB {
        var vulInfo []string
        if (c.Info.System != r.System &amp;&amp; r.System != &quot;all&quot;) || c.Info.Type != r.Source {
            continue
        }
        i := len(r.Rules)
        // log.Println(r.Rules)
        for k, rule := range r.Rules {
            switch rule.Type {
            case &quot;regex&quot;:
                reg := regexp.MustCompile(rule.Data)
                if reg.MatchString(strings.ToLower(c.V[k])) {
                    i--
                    vulInfo = append(vulInfo, c.V[k])
                }
            case &quot;non-regex&quot;:
                reg := regexp.MustCompile(rule.Data)
                if c.V[k] != &quot;&quot; &amp;&amp; !reg.MatchString(strings.ToLower(c.V[k])) {
                    i--
                    vulInfo = append(vulInfo, c.V[k])
                }
            case &quot;string&quot;:
                if strings.ToLower(c.V[k]) == strings.ToLower(rule.Data) {
                    i--
                    vulInfo = append(vulInfo, c.V[k])
                }
            case &quot;count&quot;:
                if models.Config.Learn {
                    i--
                    vulInfo = append(vulInfo, c.V[k])
                    continue
                }
                var statsinfo stats
                var keyword string
                if c.Info.Type == &quot;connection&quot; {
                    keyword = strings.Split(c.V[k], &quot;:&quot;)[0]
                } else {
                    keyword = c.V[k]
                }
                err := c.CStatistics.Find(bson.M{&quot;type&quot;: r.Source, &quot;info&quot;: keyword}).One(&amp;statsinfo)
                if err != nil {
                    log.Println(err.Error(), r.Source, keyword)
                    break
                }
                n, err := strconv.Atoi(rule.Data)
                if err != nil {
                    log.Println(err.Error())
                    break
                }
                if statsinfo.Count == n {
                    i--
                    vulInfo = append(vulInfo, c.V[k])
                }
            }
        }
        if r.And {
            if i == 0 {
                c.Source = r.Meta.Name
                c.Level = r.Meta.Level
                c.Description = r.Meta.Description
                sort.Strings(vulInfo)
                c.Value = strings.Join(vulInfo, &quot;|&quot;)
                c.warning()
            }
        } else if i &lt; len(r.Rules) {
            c.Source = r.Meta.Name
            c.Level = r.Meta.Level
            c.Description = r.Meta.Description
            sort.Strings(vulInfo)
            c.Value = strings.Join(vulInfo, &quot;|&quot;)
            c.warning()
        }
    }
}</code></pre><p><strong>intelligence</strong></p>
<p>首先判断威胁情报的配置开关是否开启，若未开启，则直接结束；从网络事件/登陆事件/文件事件中取出remote_ip/hash，格式化后提交到自定义的威胁情报接口（控制台），通过自定义威胁正则与威胁情报api返回结果的正则匹配判断具体事件对应的ip/文件是否为恶意：</p>
<pre><code>func (c *Check) Intelligence() {
    if !models.Config.Intelligence.Switch {
        return
    }
    if c.Info.Type == &quot;connection&quot; || c.Info.Type == &quot;loginlog&quot; {
        ip := strings.Split(c.V[&quot;remote&quot;], &quot;:&quot;)[0]
        if isLan(ip) {
            return
        }
        if inArray(cache, c.Info.Type+c.Info.IP+ip, false) {
            return
        }
        cache = append(cache, c.Info.Type+c.Info.IP+ip)
        url := strings.Replace(models.Config.Intelligence.IPAPI, &quot;{$ip}&quot;, ip, 1)
        resp, err := http.Get(url)
        if err != nil {
            return
        }
        defer resp.Body.Close()
        body, _ := ioutil.ReadAll(resp.Body)
        reg := regexp.MustCompile(models.Config.Intelligence.Regex)
        if reg.Match(body) {
            c.Source = &quot;威胁情报接口&quot;
            c.Level = 0
            c.Description = &quot;威胁情报接口显示此IP存在风险&quot;
            c.Value = ip
            c.warning()
        }
    } else if c.Info.Type == &quot;file&quot; {
        if c.V[&quot;hash&quot;] != &quot;&quot; {
            if inArray(cache, c.Info.Type+c.Info.IP+c.V[&quot;hash&quot;], false) {
                return
            }
            cache = append(cache, c.Info.Type+c.Info.IP+c.V[&quot;hash&quot;])
            url := strings.Replace(models.Config.Intelligence.FileAPI, &quot;{$hash}&quot;, c.V[&quot;hash&quot;], 1)
            resp, err := http.Get(url)
            if err != nil {
                return
            }
            defer resp.Body.Close()
            body, _ := ioutil.ReadAll(resp.Body)
            reg := regexp.MustCompile(models.Config.Intelligence.Regex)
            if reg.Match(body) {
                c.Source = &quot;威胁情报接口&quot;
                c.Level = 0
                c.Description = &quot;威胁情报接口显示此文件存在风险&quot;
                c.Value = c.V[&quot;hash&quot;]
                c.warning()
            }
        }
    }
}</code></pre><p><strong>healthcheckthread</strong></p>
<p>客户端健康状态检测线程，包含离线检测、自动清理、连通性检测：</p>
<pre><code>func HealthCheckThread() {
    log.Println(&quot;Start Health Check Thread&quot;)
    go offlineCheckThread()
    go cleanThread()
    firewallCheckThread()
}</code></pre><p><strong>offlinecheckthread</strong></p>
<p>离线检测告警，离线场景判定，健康状态设定（0、1、2）：</p>
<pre><code>func offlineCheckThread() {
    var oneMinuteAgo time.Time
    var offlineIPList []string
    var msg string
    var cache []string
    client := models.DB.C(&quot;client&quot;)
    go func() {
        ticker := time.NewTicker(time.Hour * 24)
        for _ = range ticker.C {
            cache = []string{}
        }
    }()
    for {
        oneMinuteAgo = time.Now().Add(time.Minute * time.Duration(-5))
        err := client.Find(bson.M{&quot;uptime&quot;: bson.M{&quot;$lte&quot;: oneMinuteAgo}}).Distinct(&quot;ip&quot;, &amp;offlineIPList)
        if err != nil {
            log.Println(err.Error())
        }
        // 超过20台掉线直接告警
        if len(offlineIPList) &gt;= 20 {
            err = models.DB.C(&quot;notice&quot;).Insert(bson.M{&quot;type&quot;: &quot;abnormal&quot;, &quot;ip&quot;: offlineIPList[0], &quot;source&quot;: &quot;服务异常&quot;, &quot;level&quot;: 1,
                &quot;info&quot;: offlineIPList[0], &quot;description&quot;: &quot;大量主机异常下线，需尽快排查原因。&quot;, &quot;status&quot;: 0, &quot;time&quot;: time.Now()})
            if err == nil {
                msg = fmt.Sprintf(&quot;IP:%s,Type:%s,Info:大量主机异常下线，需尽快排查原因。&quot;, offlineIPList[0], &quot;abnormal&quot;)
                sendNotice(0, msg)
            }
        }
        for _, ip := range offlineIPList {
            // 健康状态设置为离线 (0健康 1离线 2存在防火墙阻拦)
            client.Update(bson.M{&quot;ip&quot;: ip}, bson.M{&quot;$set&quot;: bson.M{&quot;health&quot;: 1}})

            // 如果开启了离线检测通知才进行ICMP判断并写入警告
            if !models.Config.OfflineCheck || len(offlineIPList) &gt;= 20 {
                continue
            }
            // 机器存活但服务中断5分钟
            if ping.Ping(ip, 3) {
                if inArray(cache, ip, false) {
                    continue
                }
                cache = append(cache, ip)
                err = models.DB.C(&quot;notice&quot;).Insert(bson.M{&quot;type&quot;: &quot;abnormal&quot;, &quot;ip&quot;: ip, &quot;source&quot;: &quot;服务异常&quot;, &quot;level&quot;: 1,
                    &quot;info&quot;: ip, &quot;description&quot;: &quot;主机存活但服务未正常工作，可能为被入侵者关闭。&quot;, &quot;status&quot;: 0, &quot;time&quot;: time.Now()})
                if err == nil {
                    msg = fmt.Sprintf(&quot;IP:%s,Type:%s,Info:主机存活但服务未正常工作，可能为被入侵者关闭。&quot;, ip, &quot;abnormal&quot;)
                    sendNotice(0, msg)
                } else {
                    log.Println(err.Error())
                }
            }
        }
        time.Sleep(time.Second * 30)
    }
}</code></pre><p><strong>cleanThread</strong></p>
<p>离线超过72h从mongo的client表中删除对应主机信息，若已离线主机超过100台，则停止修改client表：</p>
<pre><code>func cleanThread() {
    client := models.DB.C(&quot;client&quot;)
    for {
        var offlineIPList []string
        err := client.Find(bson.M{&quot;uptime&quot;: bson.M{&quot;$lte&quot;: time.Now().Add(time.Hour * time.Duration(-72))}}).Distinct(&quot;ip&quot;, &amp;offlineIPList)
        if err != nil {
            log.Println(&quot;Mongodb query error in cleanThread:&quot;, err.Error())
        }
        if len(offlineIPList) &gt;= 100 {
            time.Sleep(time.Second * 60)
            continue
        }
        for _, ip := range offlineIPList {
            err = models.DB.C(&quot;client&quot;).Remove(bson.M{&quot;ip&quot;: ip})
            if err != nil {
                log.Println(&quot;Mongodb remove error in cleanThread:&quot;, err.Error())
            }
        }

        time.Sleep(time.Second * 60)
    }
}</code></pre><p><strong>firewallcheckthread</strong></p>
<p>检测mongo client表中健康的主机ip：65512端口能否连接，即检测与daemon的连接能力，若无法连接，则修改client的health状态为2；反之若health状态为2的主机发现可以联通，则恢复健康状态：</p>
<pre><code>func firewallCheckThread() {
    client := models.DB.C(&quot;client&quot;)
    var onlineIPList []string
    var errIPList []string
    ticker := time.NewTicker(time.Second * 60)
    for _ = range ticker.C {
        client.Find(bson.M{&quot;health&quot;: 0}).Distinct(&quot;ip&quot;, &amp;onlineIPList)
        for _, ip := range onlineIPList {
            conn, err := net.DialTimeout(&quot;tcp&quot;, ip+&quot;:65512&quot;, time.Second*3)
            if err != nil {
                client.Update(bson.M{&quot;ip&quot;: ip}, bson.M{&quot;$set&quot;: bson.M{&quot;health&quot;: 2}})
            } else {
                conn.Close()
            }
        }

        // 恢复状态
        client.Find(bson.M{&quot;health&quot;: 2}).Distinct(&quot;ip&quot;, &amp;errIPList)
        for _, ip := range errIPList {
            conn, err := net.DialTimeout(&quot;tcp&quot;, ip+&quot;:65512&quot;, time.Second*3)
            if err == nil {
                client.Update(bson.M{&quot;ip&quot;: ip}, bson.M{&quot;$set&quot;: bson.M{&quot;health&quot;: 0}})
                conn.Close()
            }
        }
    }
}</code></pre><p><strong>insertthread</strong></p>
<p>异步的es写入线程，如果请求数量&gt;100或者请求体大小大于2MB则进行提交写入；同时每30s也进行一次写入：</p>
<pre><code>func InsertThread() {
    var data esData
    p, err := Client.BulkProcessor().
        Name(&quot;YulongWorker-1&quot;).
        Workers(2).
        BulkActions(100).                // commit if # requests &gt;= 100
        BulkSize(2 &lt;&lt; 20).               // commit if size of requests &gt;= 2 MB
        FlushInterval(30 * time.Second). // commit every 30s
        Do(context.Background())
    if err != nil {
        log.Println(&quot;start BulkProcessor: &quot;, err)
    }
    for {
        data = &lt;-esChan
        p.Add(elastic.NewBulkIndexRequest().Index(nowindicesName).Type(data.dataType).Doc(data.data))
    }
}</code></pre><h3 id="Database-1"><a href="#Database-1" class="headerlink" title="Database"></a>Database</h3><h4 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h4><p>数据存放在agent库，库中有client、config、file、info、notice、queue、rules、server、statistics、task、task_result几张表：</p>
<p><img src="./image-20201021174332979.png" alt="image-20201021174332979"></p>
<p><strong>client</strong></p>
<p>保存agent所在主机信息，client相对于server而言：</p>
<p><img src="./image-20201021174837323.png" alt="image-20201021174837323"></p>
<p><strong>config</strong></p>
<p>保存控制台设置中的所有配置信息：</p>
<p><img src="./image-20201021175031736.png" alt="image-20201021175031736"></p>
<p><strong>file</strong></p>
<p>创建服务时上传的build好的文件（agent、daemon、data.zip）:</p>
<p><img src="./image-20201021175143860.png" alt="image-20201021175143860"></p>
<p><strong>info</strong></p>
<p>存储agent定时收集的主机信息，即agent/collect中子模块中收集的部分数据（userlist、listening、processlist），在主机列表/信息/界面下可以看到渲染后的数据：</p>
<p><img src="./image-20201021175514821.png" alt="image-20201021175514821"></p>
<p><strong>notice</strong></p>
<p>notice存放规则匹配的告警事件，status标识处理状态，0表示未处理，1表示已处理，2表示忽略：</p>
<p><img src="./image-20201021175932368.png" alt="image-20201021175932368"></p>
<p><strong>queue</strong></p>
<p>猜测是server创建任务时当作任务队列用的，可能取的速度很快，所以每次看queue里面都没有数据</p>
<p><strong>rules</strong></p>
<p>存放server端存储的规则：</p>
<p><img src="./image-20201021190200612.png" alt="image-20201021190200612"></p>
<p><strong>server</strong></p>
<p>服务启动信息：</p>
<p><img src="./image-20201021190248527.png" alt="image-20201021190248527"></p>
<p><strong>statistics</strong></p>
<p>存放事件统计后的结果表</p>
<p><strong>task</strong></p>
<p>server创建和下发的任务具体数据和字段：</p>
<p><img src="./image-20201021191240242.png" alt="image-20201021191240242"></p>
<p><strong>task_result</strong></p>
<p>存放任务执行后的结果，在任务/查看结果/界面可以看到具体被渲染后的任务结果数据：</p>
<p><img src="./image-20201021191457781.png" alt="image-20201021191457781"></p>
<h4 id="es"><a href="#es" class="headerlink" title="es"></a>es</h4><p>es中的事件类型能看到的有file、process、loginlog，应该还能有connection事件的，但是这边没有看到emmmm</p>
<p><img src="./image-20201022101107922.png" alt="image-20201022101107922"></p>
<p><img src="./image-20201021192848216.png" alt="image-20201021192848216"></p>
<p>文件操作事件字段：</p>
<p><img src="./image-20201021193030185.png" alt="image-20201021193030185"></p>
<p>进程操作事件字段：</p>
<p><img src="./image-20201021193119756.png" alt="image-20201021193119756"></p>
<p>登陆日志事件字段：</p>
<p><img src="./image-20201021193203519.png" alt="image-20201021193203519"></p>
<h3 id="Web-1"><a href="#Web-1" class="headerlink" title="Web"></a>Web</h3><p>to be continued</p>
<h2 id="五、问题"><a href="#五、问题" class="headerlink" title="五、问题"></a>五、问题</h2><p>yulong作为国内第一个开源hids项目虽然给人带来不少惊喜，但是不可否认还是存在很多问题的，后续不再维护确实很可惜；通过对源码的分析总结出来如下一些问题：</p>
<p>1、技术选型</p>
<p>spoock师傅说过，不谈场景，说合适不合适那都是耍流氓，hook execve的lkm在甲方安全建设的场景中确实无可厚非，甲方对内部资产的熟悉掌握和控制本来就是其优势所在，这点不能说啥；问题主要在于用libpcap的流量回调方式去捕获事件实在是非常粗糙，首先有非常大的可能存在数据丢失（遍历/proc花费大量时间，丢失pid），其次拿流量做信号去遍历/proc，流量少还好，流量一多，负载会高到爆炸，这点有测过，cpu主要占用在遍历那一块了，而且本身libpcap没有比较可控的接口；然后文件监控这块用的是inotify，问题是这样就拿不到pid了，只能做文件完整性检测，不太好做后续分析、关联等等</p>
<p>2、规则</p>
<p>项目提供的默认规则太简单和宽泛了，甚至包含一些错误，比如：</p>
<p><img src="./image-20201022120401573.png" alt="image-20201022120401573"></p>
<p><img src="./image-20201022120423447.png" alt="image-20201022120423447"></p>
<p>有些不太精确，比如：</p>
<p><img src="./image-20201022120739280.png" alt="image-20201022120739280"></p>
<p>另外规则引擎的匹配算法没有做优化，规则或者事件一旦多起来，server的负载会很高</p>
<p>有些太宽泛导致误报非常高：</p>
<p><img src="./image-20201022121056325.png" alt="image-20201022121056325"></p>
<p><img src="./image-20201022121152354.png" alt="image-20201022121152354"></p>
<p>agent在测试机才装2天就有近6w条告警，这是无法运营的，当然，规则支持细粒度控制（开关）还是很不错的</p>
<p>3、功能</p>
<p>功能类型较少，功能模块划分不够细，比如没有单独的入侵检测模块，无法根据危险等级筛选告警，只能一个个去看，根据规则类型判断是否是入侵事件，没有针对性的审计告警是非常耗时的，特别是在告警数量特别庞大的情况下；</p>
<p>4、etc.</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>针对yulong-hids的功能原理、架构设计、代码结构、源码实现进行了比较粗糙的剖析，大致熟悉了一个经典hids的内部构造；分析的过程就像是读一部从未读过的经典小说，各函数间的层层调用就像小说情节的环环相扣，而作为一个读者，就在这一个个函数、一层层调用间感受作者的真意；读完全部源码后依稀有点恋恋不舍，不禁感叹工程之美，感叹源码之美，感叹设计之美；</p>
<p>针对本篇中未分析的process_monitor模块，后续将在其它篇中继续进行分析</p>
<h2 id="七、链接"><a href="#七、链接" class="headerlink" title="七、链接"></a>七、链接</h2><p><a href="https://github.com/ysrc/yulong-hids/" target="_blank" rel="noopener">https://github.com/ysrc/yulong-hids/</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag"># 源码分析</a>
              <a href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" rel="tag"># 二进制</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/09/24/Linux%E7%8E%AF%E5%A2%83%E4%B8%8BELF%E6%97%A0%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C%E4%B8%8E%E6%A3%80%E6%B5%8B/" rel="prev" title="Linux环境下ELF无文件执行与检测">
                  <i class="fa fa-chevron-left"></i> Linux环境下ELF无文件执行与检测
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/10/22/Yulong-Hids-Process-Monitor-Principle-Analysis/" rel="next" title="Yulong-Hids Process Monitor Principle Analysis">
                  Yulong-Hids Process Monitor Principle Analysis <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XDW</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>



    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/prismjs@1.21.0/components/prism-core.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/prismjs@1.21.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  















  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  

</body>
</html>
