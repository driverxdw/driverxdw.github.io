<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic|Lobster+Two:300,300italic,400,400italic,700,700italic|EB+Garamond:300,300italic,400,400italic,700,700italic|Roboto+Slab:300,300italic,400,400italic,700,700italic|Source+Code+Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"driverxdw.github.io","root":"/","scheme":"Muse","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="一、起源之前针对yulong-hids的分析还剩下进程监控模块，因为此模块有点复杂且涉及内核，所以单独整一篇过来分析下">
<meta property="og:type" content="article">
<meta property="og:title" content="Yulong-Hids Process Monitor Principle Analysis">
<meta property="og:url" content="https://driverxdw.github.io/2020/10/22/Yulong-Hids-Process-Monitor-Principle-Analysis/index.html">
<meta property="og:site_name" content="in0va&#39;S Blog  JustLearnM0re">
<meta property="og:description" content="一、起源之前针对yulong-hids的分析还剩下进程监控模块，因为此模块有点复杂且涉及内核，所以单独整一篇过来分析下">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://driverxdw.github.io/2020/10/22/Yulong-Hids-Process-Monitor-Principle-Analysis/image-20201023183519589.png">
<meta property="article:published_time" content="2020-10-22T02:05:49.000Z">
<meta property="article:modified_time" content="2020-10-24T16:27:20.884Z">
<meta property="article:author" content="XDW">
<meta property="article:tag" content="源码分析">
<meta property="article:tag" content="二进制">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://driverxdw.github.io/2020/10/22/Yulong-Hids-Process-Monitor-Principle-Analysis/image-20201023183519589.png">


<link rel="canonical" href="https://driverxdw.github.io/2020/10/22/Yulong-Hids-Process-Monitor-Principle-Analysis/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Yulong-Hids Process Monitor Principle Analysis | in0va'S Blog  JustLearnM0re</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">in0va'S Blog  JustLearnM0re</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">犯二</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">69</span></a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、起源"><span class="nav-number">1.</span> <span class="nav-text">一、起源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、源码分析"><span class="nav-number">2.</span> <span class="nav-text">二、源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#go"><span class="nav-number">2.1.</span> <span class="nav-text">go</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c"><span class="nav-number">2.2.</span> <span class="nav-text">c</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kernel"><span class="nav-number">2.3.</span> <span class="nav-text">kernel</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、总结"><span class="nav-number">3.</span> <span class="nav-text">三、总结</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XDW"
      src="/images/author.jpg">
  <p class="site-author-name" itemprop="name">XDW</p>
  <div class="site-description" itemprop="description">一枚很菜但是仍在学习的二进制菜逼</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">69</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.ixuchao.cn/" title="https:&#x2F;&#x2F;blog.ixuchao.cn&#x2F;" rel="noopener" target="_blank">Archerx's Blog</a>
        </li>
    </ul>
  </div>

      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://driverxdw.github.io/2020/10/22/Yulong-Hids-Process-Monitor-Principle-Analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="XDW">
      <meta itemprop="description" content="一枚很菜但是仍在学习的二进制菜逼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="in0va'S Blog  JustLearnM0re">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Yulong-Hids Process Monitor Principle Analysis
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-22 10:05:49" itemprop="dateCreated datePublished" datetime="2020-10-22T10:05:49+08:00">2020-10-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-25 00:27:20" itemprop="dateModified" datetime="2020-10-25T00:27:20+08:00">2020-10-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/HIDS/" itemprop="url" rel="index"><span itemprop="name">HIDS</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="一、起源"><a href="#一、起源" class="headerlink" title="一、起源"></a>一、起源</h2><p>之前针对yulong-hids的分析还剩下进程监控模块，因为此模块有点复杂且涉及内核，所以单独整一篇过来分析下</p>
<a id="more"></a>

<h2 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h2><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><p>agent/monitor/process_linux.go模块是execve hook lkm的调用者，从此模块开始分析：</p>
<p><strong>StartProcessMonitor</strong></p>
<p>首先起一个线程调c实现的CapturePrecess函数（感觉应该是编码的师傅写错了 应该是captureprocess才对），根据注释大致可以猜到是connect netlink的操作</p>
<pre><code>func StartProcessMonitor(resultChan chan map[string]string) {
    log.Println(&quot;StartProcessMonitor&quot;)
    var buf [255]byte
    //开启进程监控提取线程
    go func() {
        ok := C.CapturePrecess()
        if ok &lt; 0 {
            log.Println(&quot;connect syshook netlink error&quot;)
        }
    }()
</code></pre><p>其次监听本地udp：65530端口，并不断从中读数据，这边有点好奇为啥要从本地端口读数据，按理说直接对接用户态netlink socket就能取到数据了，猜测是调的captureprecess中间做了一层转发，至于为什么要做这层转发目前还不清楚：</p>
<pre><code>localaddress, _ := net.ResolveUDPAddr(&quot;udp&quot;, &quot;127.0.0.1:65530&quot;)
    udplistener, err := net.ListenUDP(&quot;udp&quot;, localaddress)
    if err != nil {
        log.Print(err.Error())
        return
    }
    defer udplistener.Close()
    var resultdata map[string]string
    for {
        n, _, err := udplistener.ReadFromUDP(buf[0:])
        if err != nil {
            log.Println(err.Error())
            return
        }</code></pre><p>在上层对从65530读出来的数据做切割和解析，并将解析出的数据填充进特定格式的进程事件变量resultdata，并将结果返回给更上层调用：</p>
<pre><code>proList := strings.Split(string(buf[0:n-1]), string(0x01))
        if len(proList) &lt;= 5 {
            log.Println(string(buf[0:n]))
            continue
        }
        //不记录agent执行的命令  || s == os.Getppid()
        if s, _ := strconv.Atoi(proList[4]); s == os.Getpid() {
            continue
        }
        //白名单的不记录
        if common.InArray(common.Config.Filter.Process, strings.ToLower(resultdata[&quot;name&quot;]), true) ||
            common.InArray(common.Config.Filter.Process, strings.ToLower(resultdata[&quot;command&quot;]), true) {
            continue
        }
        resultdata = make(map[string]string)
        resultdata[&quot;source&quot;] = &quot;process&quot;
        //resultdata[&quot;type&quot;] = proList[0]
        resultdata[&quot;name&quot;] = proList[0]
        resultdata[&quot;command&quot;] = proList[0] + &quot; &quot; + proList[1]
        resultdata[&quot;pid&quot;] = proList[2]
        resultdata[&quot;parentname&quot;] = proList[3]
        resultdata[&quot;ppid&quot;] = proList[4]
        resultdata[&quot;info&quot;] = &quot;&quot;
        if len(proList) == 6 {
            resultdata[&quot;info&quot;] = proList[5]
        }
        // fmt.Println(resultdata)
        resultChan &lt;- resultdata
        //fmt.Print(string(buf[0:n]))</code></pre><h3 id="c"><a href="#c" class="headerlink" title="c"></a>c</h3><p>贴下代码，主要关注下captureprecess函数：</p>
<pre><code>#include &lt;sys/socket.h&gt;
#include &lt;linux/netlink.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

#define NETLINK_USER 31

#define MAX_PAYLOAD 2048
struct sockaddr_nl src_addr, dest_addr;
struct nlmsghdr *nlh = NULL;
struct iovec iov;
struct msghdr msg;

#define PORT  65530
int CapturePrecess()
{
    //udp sock
    int sock;
    int payload_max_len = 0;

    payload_max_len = pathconf(&quot;/&quot;, _PC_PATH_MAX);
    if(payload_max_len &lt; 0) {
        return -1;
    }

    payload_max_len += MAX_PAYLOAD;

    sock = socket(AF_INET, SOCK_DGRAM, 0);
    if(sock &lt; 0) {
        return -1;
    }
    struct sockaddr_in sockaddrin;
    memset(&amp;sockaddrin, 0, sizeof(sockaddrin));
    sockaddrin.sin_family = AF_INET;
    sockaddrin.sin_port = htons(PORT);
    sockaddrin.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);

    //netlink sock
    int sock_fd;
    sock_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_USER);
    if (sock_fd &lt; 0) {
        return -1;
    }

    memset(&amp;src_addr, 0, sizeof(src_addr));
    memset(&amp;msg, 0, sizeof(msg));

    src_addr.nl_family = AF_NETLINK;
    src_addr.nl_pid = getpid();
    src_addr.nl_groups = 1;
    bind(sock_fd, (struct sockaddr*)&amp;src_addr, sizeof(src_addr));
    memset(&amp;dest_addr, 0, sizeof(dest_addr));
    nlh = (struct nlmsghdr *)malloc(NLMSG_SPACE(payload_max_len));
    memset(nlh, 0, NLMSG_SPACE(payload_max_len));

    iov.iov_base = (void *)nlh;
    iov.iov_len = NLMSG_SPACE(payload_max_len);
    msg.msg_name = (void *)&amp;dest_addr;
    msg.msg_namelen = sizeof(dest_addr);
    msg.msg_iov = &amp;iov;
    msg.msg_iovlen = 1;

    while (1)
    {
        recvmsg(sock_fd, &amp;msg, 0);
        sendto(sock, (char *)NLMSG_DATA(nlh), strlen((char *)NLMSG_DATA(nlh)), 0, (struct sockaddr *)&amp;sockaddrin, sizeof(sockaddrin));
        memset((char *)NLMSG_DATA(nlh), 0, strlen((char *)NLMSG_DATA(nlh)));
    }
    close(sock_fd);
    close(sock);
    return 0;
}</code></pre><p>captureprecess主要负责进程获取，但本质上它还是一个caller；首先函数调用socket(AF_INET, SOCK_DGRAM, 0);创建udp的socket，返回socket描述符（句柄）到sock，之后设置要通信的服务器地址和端口，初始化要绑定的网络地址结构，项目中设置的是本地的65530端口：</p>
<pre><code>int CapturePrecess()
{
    //udp sock
    int sock;
    int payload_max_len = 0;

    payload_max_len = pathconf(&quot;/&quot;, _PC_PATH_MAX);
    if(payload_max_len &lt; 0) {
        return -1;
    }

    payload_max_len += MAX_PAYLOAD;

    sock = socket(AF_INET, SOCK_DGRAM, 0);
    if(sock &lt; 0) {
        return -1;
    }
  struct sockaddr_in sockaddrin;
    memset(&amp;sockaddrin, 0, sizeof(sockaddrin));
    sockaddrin.sin_family = AF_INET;
    sockaddrin.sin_port = htons(PORT);
    sockaddrin.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;)</code></pre><p>然后创建netlink socket，这边自定义了一个netlink协议用于数据传输，协议号为31，创建好socket后和agent进程进行绑定，之后定义数据传输格式，分配消息数据存储空间：</p>
<pre><code>//netlink sock
    int sock_fd;
    sock_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_USER);
    if (sock_fd &lt; 0) {
        return -1;
    }

    memset(&amp;src_addr, 0, sizeof(src_addr));
  memset(&amp;msg, 0, sizeof(msg));

  src_addr.nl_family = AF_NETLINK;
  src_addr.nl_pid = getpid();
  src_addr.nl_groups = 1;
  bind(sock_fd, (struct sockaddr*)&amp;src_addr, sizeof(src_addr));
  memset(&amp;dest_addr, 0, sizeof(dest_addr));
  nlh = (struct nlmsghdr *)malloc(NLMSG_SPACE(payload_max_len));
  memset(nlh, 0, NLMSG_SPACE(payload_max_len));

  iov.iov_base = (void *)nlh;
  iov.iov_len = NLMSG_SPACE(payload_max_len);
  msg.msg_name = (void *)&amp;dest_addr;
  msg.msg_namelen = sizeof(dest_addr);
  msg.msg_iov = &amp;iov;
  msg.msg_iovlen = 1;</code></pre><p>最后在一个while循环里不断从netlink socket中读取事件信息放到msg中，再向创建udp socket时绑定的ip和端口发送接收到的msg数据，每次发送完会用NLMSG_DATA()获取nlmsghdr指向的payload地址，并将其所在地址空间置位：</p>
<pre><code>    while (1)
    {
        recvmsg(sock_fd, &amp;msg, 0);
        sendto(sock, (char *)NLMSG_DATA(nlh), strlen((char *)NLMSG_DATA(nlh)), 0, (struct sockaddr *)&amp;sockaddrin, sizeof(sockaddrin));
        memset((char *)NLMSG_DATA(nlh), 0, strlen((char *)NLMSG_DATA(nlh)));
    }
    close(sock_fd);
    close(sock);
    return 0;</code></pre><h3 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h3><p>这边是比较核心的一个点，以上两块本质上都是caller，lkm才是进程事件捕获的真正实现方，首先贴下代码：</p>
<p><strong>syscall_hook.c</strong></p>
<pre><code>#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/syscalls.h&gt;
#include &lt;linux/delay.h&gt;
#include &lt;linux/file.h&gt;
#include &lt;asm/paravirt.h&gt;
#include &lt;asm/syscall.h&gt;
#include &lt;linux/sys.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/kallsyms.h&gt;
#include &lt;linux/binfmts.h&gt;
#include &lt;linux/version.h&gt;
#include &lt;net/sock.h&gt;
#include &lt;net/netlink.h&gt;

unsigned long **sys_call_table_ptr;
unsigned long original_cr0;
void *orig_sys_call_table [NR_syscalls];

struct sock *syshook_nl_sk = NULL;
#define SYSHOOK_NL_NUM  31

#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 10, 0)
    struct user_arg_ptr {
    #ifdef CONFIG_COMPAT
        bool is_compat;
    #endif
        union {
            const char __user *const __user *native;
    #ifdef CONFIG_COMPAT
            const compat_uptr_t __user *compat;
    #endif
        } ptr;
    };
    struct filename *(*tmp_getname)(const char __user * filename);
    void (*tmp_putname)(struct filename *name);
    typedef asmlinkage long (*func_execve)(const char __user *,
                                           const char __user * const __user *,
                                           const char __user *const  __user *);
    extern asmlinkage long monitor_stub_execve_hook (const char __user *,
                                                     const char __user *const __user *,
                                                     const char __user *const __user *);
#elif LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 32)
    typedef asmlinkage long (*func_execve)(const char __user *,
                                           const char __user * const __user *,
                                           const char __user *const  __user *,
                                           struct pt_regs *);
    extern asmlinkage long monitor_stub_execve_hook(const char __user *,
                                                    const char __user * const __user *,
                                                    const char __user *const  __user *,
                                                    struct pt_regs *);
#endif

func_execve orig_stub_execve;

unsigned long **find_sys_call_table(void) {
    unsigned long ptr;
    unsigned long *p;

    pr_err(&quot;Start found sys_call_table.\n&quot;);

    for (ptr = (unsigned long)sys_close;
         ptr &lt; (unsigned long)&amp;loops_per_jiffy;
         ptr += sizeof(void *)) {

        p = (unsigned long *)ptr;

        if (p[__NR_close] == (unsigned long)sys_close) {
            pr_err(&quot;Found the sys_call_table!!! __NR_close[%d] sys_close[%lx]\n&quot;
                    &quot; __NR_execve[%d] sct[__NR_execve][0x%lx]\n&quot;,
                    __NR_close,
                    (unsigned long)sys_close,
                    __NR_execve,
                    p[__NR_execve]);
            return (unsigned long **)p;
        }
    }

    return NULL;
}



#if LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 32)
static int tmp_count(char __user * __user * argv, int max)
{
    int i = 0;

    if (argv != NULL) {
        for (;;) {
            char __user * p;

            if (get_user(p, argv))
                return -EFAULT;
            if (!p)
                break;
            argv++;
            if (i++ &gt;= max)
                return -E2BIG;

            if (fatal_signal_pending(current))
                return -ERESTARTNOHAND;
            cond_resched();
        }
    }
    return i;
}

asmlinkage long monitor_execve_hook(char __user *name,
                                   char __user * __user *argv,
                                   char __user * __user *envp, 
                                   struct pt_regs *regs)
{
    long error = 0;
    struct filename *path = NULL;
    char __user * native = NULL;
    int tmp_argc = 0, tmp_envpc =  0;
    int i = 0, len = 0, offset = 0, max_len = 0;
    int total_argc_len = 0, total_envpc_len = 0;
    char *total_argc_ptr = NULL, *total_envpc_ptr = NULL;
    char *per_envp = NULL;
    int nl_send_len = 0;
    struct sk_buff *skb = NULL;
    struct nlmsghdr *nlh = NULL;
    struct file *file = NULL;
    char *tmp = kmalloc(PATH_MAX, GFP_KERNEL);
    char *path1 = NULL;


    path = getname(name);
    error = PTR_ERR(path);
    if (IS_ERR(path)) {
        pr_err(&quot;get path failed.\n&quot;);
        goto err;
    }

    file = open_exec(path-&gt;name);
    if (!IS_ERR(file) &amp;&amp; tmp) {
        memset(tmp, 0, PATH_MAX);
        path1 = d_path(&amp;file-&gt;f_path, tmp, PATH_MAX);
        if (IS_ERR(path1)) {
            path1 = NULL;
        }

        fput(file);
    }

    error = 0;
    tmp_argc = tmp_count(argv, MAX_ARG_STRINGS);
    if(tmp_argc &lt; 0) {
        error = tmp_argc;
        goto err;
    }

    for(i = 0; i &lt; tmp_argc; i ++) {
        if(get_user(native, argv + i)) {
            error = -EFAULT;
            goto err;
        }

        len = strnlen_user(native, MAX_ARG_STRLEN);
        if(!len) {
            error = -EFAULT;
            goto err;
        }

        total_argc_len += len;
    }

    total_argc_ptr = kmalloc(total_argc_len + 16 * tmp_argc, GFP_ATOMIC);
    if(!total_argc_ptr) {
        error = -ENOMEM;
        goto err;
    }
    memset(total_argc_ptr, 0, total_argc_len + 16 * tmp_argc);

    for(i = 0; i &lt; tmp_argc; i ++) {
        if(i == 0) {
            continue;
        }
        if(get_user(native, argv + i)) {
            error = -EFAULT;
            goto err;
        }

        len = strnlen_user(native, MAX_ARG_STRLEN);
        if(!len) {
            error = -EFAULT;
            goto err;
        }

        if(offset + len &gt; total_argc_len + 16 * tmp_argc) {
            break;
        }

        if (copy_from_user(total_argc_ptr + offset, native, len)) {
            error = -EFAULT;
            goto err;
        }

        offset += len - 1;
        *(total_argc_ptr + offset) = &#39; &#39;;
        offset += 1;
    }

    /*--------envp--------------*/
    len = 0;
    offset = 0;
    tmp_envpc = tmp_count(envp, MAX_ARG_STRINGS);
    if(tmp_envpc &lt; 0) {
        error = tmp_envpc;
        goto err;
    }

    for(i = 0; i &lt; tmp_envpc; i ++) {
        if(get_user(native, envp + i)) {
            error = -EFAULT;
            goto err;
        }

        len = strnlen_user(native, MAX_ARG_STRLEN);
        if(!len) {
            error = -EFAULT;
            goto err;
        }

        if(len &gt; max_len) {
            max_len = len;
        }
        total_envpc_len += len;
    }

    per_envp = kmalloc(max_len + 16, GFP_KERNEL);
    if(!per_envp) {
        error = -ENOMEM;
        goto err;
    }

    total_envpc_ptr = kmalloc(total_envpc_len + 16 * tmp_envpc, GFP_ATOMIC);
    if(!total_envpc_ptr) {
        error = -ENOMEM;
        goto err;
    }
    memset(total_envpc_ptr, 0, total_envpc_len + 16 * tmp_envpc);

    for(i = 0; i &lt; tmp_envpc; i ++) {
        if(get_user(native, envp + i)) {
            error = -EFAULT;
            goto err;
        }

        len = strnlen_user(native, MAX_ARG_STRLEN);
        if(!len) {
            error = -EFAULT;
            goto err;
        }

        if(offset + len &gt; total_envpc_len + 16 * tmp_envpc) {
            break;
        }

        memset(per_envp, 0, max_len);
        if(copy_from_user(per_envp, native, len)) {
            error = -EFAULT;
            goto err;
        }

        if(!strstr(per_envp, &quot;PWD&quot;) &amp;&amp; !strstr(per_envp, &quot;LOGNAME&quot;) &amp;&amp; !strstr(per_envp, &quot;USER&quot;)) {
            continue;
        }

        if (copy_from_user(total_envpc_ptr + offset, native, len)) {
            error = -EFAULT;
            goto err;
        }

        offset += len - 1;
        *(total_envpc_ptr + offset) = &#39; &#39;;
        offset += 1;
    }

    nl_send_len = (path1 != NULL ? strlen(path1) : strlen(path-&gt;name)) + strlen(current-&gt;parent-&gt;comm) + 128;
    if(!ZERO_OR_NULL_PTR(total_envpc_ptr)) {
        nl_send_len += strlen(total_envpc_ptr);
    }
    if(!ZERO_OR_NULL_PTR(total_argc_ptr)) {
        nl_send_len += strlen(total_argc_ptr);
    }

    nl_send_len = nl_send_len &lt; PATH_MAX + 2048 ? nl_send_len : PATH_MAX + 2048;
    skb = alloc_skb(NLMSG_SPACE(nl_send_len), GFP_ATOMIC);
    if(!skb) {
        error = -ENOMEM;
        goto err;
    }

    nlh = (struct nlmsghdr *)skb-&gt;data;
    nlh-&gt;nlmsg_len = NLMSG_SPACE(nl_send_len);
    nlh-&gt;nlmsg_pid = 0; 
    nlh-&gt;nlmsg_flags = 0;
    nlh = nlmsg_put(skb, 0, 0, 0, NLMSG_SPACE(nl_send_len) - sizeof (struct nlmsghdr), 0);
    if(!nlh) {
        kfree_skb(skb);
        pr_err(&quot;nlh get failed.\n&quot;);
        goto err;
    }

    snprintf(NLMSG_DATA(nlh), nl_send_len, &quot;%s%c%s%c%u%c%s%c%d%c%s&quot;, path1 != NULL ? path1 : path-&gt;name, 0x1, (uint64_t)total_argc_ptr == 0x10 ? &quot;N/A&quot; : total_argc_ptr, 0x1, current-&gt;tgid, 0x1, current-&gt;parent-&gt;comm, 0x1, current-&gt;parent-&gt;tgid, 0x1, (uint64_t)total_envpc_ptr == 0x10 ? &quot;N/A&quot; : total_envpc_ptr);
    NETLINK_CB(skb).pid = 0;
    NETLINK_CB(skb).dst_group = 1;
    error = netlink_broadcast(syshook_nl_sk, skb, 0, 1, GFP_KERNEL);
    if(error != 0 &amp;&amp; error != -3) {
        pr_err(&quot;send nl broadcast failed.\n&quot;);
        goto err;
    }

    //pr_err(&quot;%s|%s|%u|%s|%d|%s\n&quot;, path1 != NULL ? path1 : path-&gt;name, total_argc_ptr, current-&gt;tgid, current-&gt;parent-&gt;comm, current-&gt;parent-&gt;tgid, total_envpc_ptr);

err:
    if(tmp) {
        kfree(tmp);
        tmp = NULL;
    }
    if(total_envpc_ptr) {
        kfree(total_envpc_ptr);
        total_envpc_ptr = NULL;
    }
    if(per_envp) {
        kfree(per_envp);
        per_envp = NULL; 
    }
    if(total_argc_ptr) {
        kfree(total_argc_ptr);
        total_argc_ptr = NULL;
    }
    putname(path);
    return 0;
}
#elif LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 10, 0)
static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr) 
{
    const char __user *native;

#ifdef CONFIG_COMPAT
    if (unlikely(argv.is_compat)) {
        compat_uptr_t compat;

        if (get_user(compat, argv.ptr.compat + nr))
            return ERR_PTR(-EFAULT);

        return compat_ptr(compat);
    }   
#endif

    if (get_user(native, argv.ptr.native + nr))
        return ERR_PTR(-EFAULT);

    return native;
}

static int tmp_count(struct user_arg_ptr argv, int max)
{
    int i = 0;

    if (argv.ptr.native != NULL) {
        for (;;) {
            const char __user *p = get_user_arg_ptr(argv, i); 

            if (!p)
                break;

            if (IS_ERR(p))
                return -EFAULT;

            if (i &gt;= max)
                return -E2BIG;
            ++i;

            if (fatal_signal_pending(current))
                return -ERESTARTNOHAND;
            cond_resched();
        }   
    }   
    return i;
}

asmlinkage long monitor_execve_hook(const char __user *filename, 
                          const char __user *const __user *argv,
                          const char __user *const __user *envp)
{
    int error = 0, i = 0, len = 0, offset = 0, max_len = 0;
    struct filename *path = NULL;
    const char __user * native = NULL;
    char *total_argc_ptr = NULL;
    char *total_envpc_ptr = NULL;
    char *per_envp = NULL;
    int tmp_argc = 0, total_argc_len = 0;
    int tmp_envpc = 0, total_envpc_len = 0;
    struct user_arg_ptr argvx = { .ptr.native = argv };
    struct user_arg_ptr envpx = { .ptr.native = envp };
    int nl_send_len = 0;
    struct sk_buff *skb = NULL;
    struct nlmsghdr *nlh = NULL;
    struct file *file = NULL;
    char *tmp = kmalloc(PATH_MAX, GFP_KERNEL);
    char *path1 = NULL;

    path = tmp_getname(filename);
    // printk(&quot;path:%s\n&quot;,path-&gt;name);
    error = PTR_ERR(path);
    if (IS_ERR(path)) {
        goto err;
    }

    file = open_exec(path-&gt;name);
    if (!IS_ERR(file) &amp;&amp; tmp) {
        memset(tmp, 0, PATH_MAX);
        path1 = d_path(&amp;file-&gt;f_path, tmp, PATH_MAX);
        if (IS_ERR(path1)) {
            path1 = NULL;
        }
        fput(file);
    }

    error = 0;

    tmp_argc = tmp_count(argvx, MAX_ARG_STRINGS);
    if(tmp_argc &lt; 0) {
        error = tmp_argc;
        goto err;
    }

    for(i = 0; i &lt; tmp_argc; i ++) {
        native = get_user_arg_ptr(argvx, i);
        if(IS_ERR(native)) {
            error = -EFAULT;
            goto err;
        }
        // printk(&quot;native0:%s\n&quot;,native);
        len = strnlen_user(native, MAX_ARG_STRLEN);
        if(!len) {
            error = -EFAULT;
            goto err;
        }

        total_argc_len += len;
        printk(&quot;len:%d\n&quot;,len);
        printk(&quot;total_len:%d\n&quot;,total_argc_len);
    }

    total_argc_ptr = kmalloc(total_argc_len + 16 * tmp_argc, GFP_ATOMIC);
    if(!total_argc_ptr) {
        error = -ENOMEM;
        goto err;
    }
    memset(total_argc_ptr, 0, total_argc_len + 16 * tmp_argc);

    for(i = 0; i &lt; tmp_argc; i ++) {
        if(i == 0) {
            continue;
        }
        native = get_user_arg_ptr(argvx, i);
        if(IS_ERR(native)) {
            error = -EFAULT;
            goto err;
        }

        len = strnlen_user(native, MAX_ARG_STRLEN);
        if(!len) {
            error = -EFAULT;
            goto err;
        }

        if(offset + len &gt; total_argc_len + 16 * tmp_argc) {
            break;
        }

        if (copy_from_user(total_argc_ptr + offset, native, len)) {
            error = -EFAULT;
            goto err;
        }
        offset += len - 1;
        *(total_argc_ptr + offset) = &#39; &#39;;
        offset += 1;
        printk(&quot;total_argc_ptr_f:%s\n&quot;,total_argc_ptr);
    }
    printk(&quot;total_argc_ptr:%s\n&quot;,total_argc_ptr);
    /*--------envpx--------------*/
    len = 0;
    offset = 0;
    tmp_envpc = tmp_count(envpx, MAX_ARG_STRINGS);
    if(tmp_envpc &lt; 0) {
        error = tmp_envpc;
        goto err;
    }

    for(i = 0; i &lt; tmp_envpc; i ++) {
        native = get_user_arg_ptr(envpx, i);
        if(IS_ERR(native)) {
            error = -EFAULT;
            goto err;
        }

        len = strnlen_user(native, MAX_ARG_STRLEN);
        if(!len) {
            error = -EFAULT;
            goto err;
        }

        if(len &gt; max_len) {
            max_len = len;
        }

        total_envpc_len += len;
    }

    per_envp = kmalloc(max_len + 16, GFP_KERNEL);
    if(!per_envp) {
        error = -ENOMEM;
        goto err;
    }

    total_envpc_ptr = kmalloc(total_envpc_len + 16 * tmp_envpc, GFP_KERNEL);
    if(!total_envpc_ptr) {
        error = -ENOMEM;
        goto err;
    }
    memset(total_envpc_ptr, 0, total_envpc_len + 16 * tmp_envpc);

    for(i = 0; i &lt; tmp_envpc; i ++) {
        native = get_user_arg_ptr(envpx, i);
        if(IS_ERR(native)) {
            error = -EFAULT;
            goto err;
        }

        len = strnlen_user(native, MAX_ARG_STRLEN);
        if(!len) {
            error = -EFAULT;
            goto err;
        }

        if(offset + len &gt; total_envpc_len + 16 * tmp_envpc) {
            break;
        }

        memset(per_envp, 0, max_len);
        if(copy_from_user(per_envp, native, len)) {
            error = -EFAULT;
            goto err;
        }

        if(!strstr(per_envp, &quot;PWD&quot;) &amp;&amp; !strstr(per_envp, &quot;LOGNAME&quot;) &amp;&amp; !strstr(per_envp, &quot;USER&quot;)) {
            continue;
        }

        //printk(&quot;total_envpc_ptr0:%s\n&quot;,total_envpc_ptr);
        if (copy_from_user(total_envpc_ptr + offset, native, len)) {
            error = -EFAULT;
            goto err;
        }
        offset += len - 1;
        *(total_envpc_ptr + offset) = &#39; &#39;;
        offset += 1;
    }

    nl_send_len = (path1 != NULL ? strlen(path1) : strlen(path-&gt;name)) + strlen(current-&gt;parent-&gt;comm) + 128;
    if(!ZERO_OR_NULL_PTR(total_envpc_ptr)) {
        nl_send_len += strlen(total_envpc_ptr);
    }   
    printk(&quot;total_envpc_ptr1:%s\n&quot;,total_envpc_ptr);
    if(!ZERO_OR_NULL_PTR(total_argc_ptr)) {
        nl_send_len += strlen(total_argc_ptr);
    }
    nl_send_len = nl_send_len &lt; PATH_MAX + 2048 ? nl_send_len : PATH_MAX + 2048;
    skb = alloc_skb(NLMSG_SPACE(nl_send_len), GFP_ATOMIC);
    if(!skb) {
        error = -ENOMEM;
        goto err;
    }

    nlh = (struct nlmsghdr *)skb-&gt;data;
    nlh-&gt;nlmsg_len = NLMSG_SPACE(nl_send_len);
    nlh-&gt;nlmsg_pid = 0;
    nlh-&gt;nlmsg_flags = 0;
    nlh = nlmsg_put(skb, 0, 0, 0, NLMSG_SPACE(nl_send_len) - sizeof (struct nlmsghdr), 0);
    if(!nlh) {
        kfree_skb(skb);
        pr_err(&quot;nlh get failed.\n&quot;);
        goto err;
    }

    snprintf(NLMSG_DATA(nlh), nl_send_len, &quot;%s%c%s%c%u%c%s%c%d%c%s&quot;, path1 != NULL ? path1 : path-&gt;name, 0x1, (uint64_t)total_argc_ptr == 0x10 ? &quot;N/A&quot; : total_argc_ptr, 0x1, current-&gt;tgid, 0x1, current-&gt;parent-&gt;comm, 0x1, current-&gt;parent-&gt;tgid, 0x1, (uint64_t)total_envpc_ptr == 0x10 ? &quot;N/A&quot; : total_envpc_ptr);
    printk(&quot;%s|%s|%u|%s|%d|%s\n&quot;,path-&gt;name,total_argc_ptr,current-&gt;tgid,current-&gt;parent-&gt;comm,current-&gt;parent-&gt;tgid,total_envpc_ptr);
    NETLINK_CB(skb).portid = 0;
    NETLINK_CB(skb).dst_group = 1;
    error = netlink_broadcast(syshook_nl_sk, skb, 0, 1, 0);
    if(error != 0 &amp;&amp; error != -3) {
        pr_err(&quot;send nl broadcast failed.\n&quot;);
        goto err;
    }

    //pr_err(&quot;%s|%s|%u|%s|%d|%s\n&quot;, path-&gt;name, total_argc_ptr, current-&gt;tgid, current-&gt;parent-&gt;comm, current-&gt;parent-&gt;tgid, total_envpc_ptr);

err:
    if(tmp) {
        kfree(tmp);
        tmp = NULL;
    }
    if(per_envp) {
        kfree(per_envp);
        per_envp = NULL;
    }
    if(total_argc_ptr) {
        kfree(total_argc_ptr);
        total_argc_ptr = NULL;
    }
    if(total_envpc_ptr) {
        kfree(total_envpc_ptr);
        total_envpc_ptr = NULL;
    }

    tmp_putname(path);
    return 0;
}
#else
asmlinkage long monitor_execve_hook(void)
{
    return 0;
}
#endif

static int __init monitor_execve_init(void)
{
    int i = 0;

    if (!(sys_call_table_ptr = find_sys_call_table())){
        pr_err(&quot;Get sys_call_table failed.\n&quot;);
        return -1;
    }

#if LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 32)
    /*NetLink do not recv from userSpace*/
    syshook_nl_sk = netlink_kernel_create(&amp;init_net, SYSHOOK_NL_NUM, 0, NULL, NULL, THIS_MODULE);
    if(!syshook_nl_sk) {
        pr_err(&quot;syshook: can not create netlink socket.\n&quot;);
        return -EIO;
    }
#elif LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 10, 0)
    syshook_nl_sk = netlink_kernel_create(&amp;init_net, SYSHOOK_NL_NUM, NULL);
    if(!syshook_nl_sk) {
        pr_err(&quot;syshook: can not create netlink socket.\n&quot;);
        return -EIO;
    }
#endif
    pr_err(&quot;syshook: create netlink success.\n&quot;);


#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 10, 0)
    tmp_getname = (void *)kallsyms_lookup_name(&quot;getname&quot;);
    if(!tmp_getname) {
        pr_err(&quot;unknow Symbol getname\n&quot;);
        return -1;
    }

    tmp_putname = (void *)kallsyms_lookup_name(&quot;putname&quot;);
    if(!tmp_putname) {
        pr_err(&quot;unknow Symbol putname\n&quot;);
        return -1;
    }
#endif

    original_cr0 = read_cr0();
    write_cr0(original_cr0 &amp; ~0x00010000);
    pr_err(&quot;Loading module monitor_execve, sys_call_table at %p\n&quot;, sys_call_table_ptr);

    for(i = 0; i &lt; NR_syscalls - 1; i ++) {
        orig_sys_call_table[i] = sys_call_table_ptr[i];
    }

    orig_stub_execve = (void *)(sys_call_table_ptr[__NR_execve]);
    sys_call_table_ptr[__NR_execve]= (void *)monitor_stub_execve_hook;

    write_cr0(original_cr0);
    return 0;
}

static void __exit monitor_execve_exit(void)
{
    netlink_kernel_release(syshook_nl_sk);

    if (!sys_call_table_ptr){
        return;
    }

    write_cr0(original_cr0 &amp; ~0x00010000);
    sys_call_table_ptr[__NR_execve] = (void *)orig_stub_execve;
    write_cr0(original_cr0);

    sys_call_table_ptr = NULL;
    pr_err(&quot;unload syshook_execve succ.\n&quot;);
}

module_init(monitor_execve_init);
module_exit(monitor_execve_exit);

MODULE_LICENSE(&quot;GPL&quot;);
MODULE_AUTHOR(&quot;mlsm &lt;454667707@qq.com&gt;&quot;);
MODULE_DESCRIPTION(&quot;Monitor Syscall sys_execve&quot;);</code></pre><p><strong>sys_call_stub_hook.S</strong></p>
<pre><code>.text
.global monitor_stub_execve_hook

monitor_stub_execve_hook:
pushq   %rbx
pushq   %rdi
pushq   %rsi
pushq   %rdx
pushq   %rcx
pushq   %rax
pushq   %r8 
pushq   %r9 
pushq   %r10
pushq   %r11

call monitor_execve_hook

pop     %r11
pop     %r10
pop     %r9 
pop     %r8 
pop     %rax
pop     %rcx
pop     %rdx
pop     %rsi
pop     %rdi

pop     %rbx
jmp     *orig_sys_call_table(, %rax, 8)</code></pre><p><strong>Makefile</strong></p>
<pre><code>obj-m := syshook_execve.o

syshook_execve-objs := syscall_hook.o syscall_stub_hook.o

KERNEL := /lib/modules/`uname -r`/build

all:
    make -C $(KERNEL)   M=`pwd` modules

install:
    make -C $(KERNEL)   M=`pwd` modules_install
    depmod -A

clean:
    make -C $(KERNEL)   M=`pwd` clean
</code></pre><p>从makefile可以看到最终的syshook_execve.ko是由syscall_hook和syscall_stub_hook共同编译的</p>
<p>先从module_init宏开始看起，可以看到内核模块初始化时调用了monitor_execve_init，跟进：</p>
<pre><code>module_init(monitor_execve_init);
module_exit(monitor_execve_exit);

MODULE_LICENSE(&quot;GPL&quot;);
MODULE_AUTHOR(&quot;mlsm &lt;454667707@qq.com&gt;&quot;);
MODULE_DESCRIPTION(&quot;Monitor Syscall sys_execve&quot;);
</code></pre><p><strong>monitor_execve_init</strong></p>
<p>跟进函数首先可以看到有个find_sys_call_table的操作；一般hook系统调用都会首先拿到系统调用表syscall_table地址，然后才能进行系统调用表覆写：</p>
<pre><code>static int __init monitor_execve_init(void)
{
    int i = 0;

    if (!(sys_call_table_ptr = find_sys_call_table())){
        pr_err(&quot;Get sys_call_table failed.\n&quot;);
        return -1;
    }</code></pre><p>发现是通过暴力搜索的方式从sys_close出发寻找对应地址+__NR_close指针指向的内存空间存储的数据 == sys_close的地址项，对应地址项就是sys_call_table起始地址；这边是从sys_close地址出发的，不是很理解，后续需要调研下：</p>
<pre><code>unsigned long **find_sys_call_table(void) {
    unsigned long ptr;
    unsigned long *p;

    pr_err(&quot;Start found sys_call_table.\n&quot;);

    for (ptr = (unsigned long)sys_close;
         ptr &lt; (unsigned long)&amp;loops_per_jiffy;
         ptr += sizeof(void *)) {

        p = (unsigned long *)ptr;

        if (p[__NR_close] == (unsigned long)sys_close) {
            pr_err(&quot;Found the sys_call_table!!! __NR_close[%d] sys_close[%lx]\n&quot;
                    &quot; __NR_execve[%d] sct[__NR_execve][0x%lx]\n&quot;,
                    __NR_close,
                    (unsigned long)sys_close,
                    __NR_execve,
                    p[__NR_execve]);
            return (unsigned long **)p;
        }
    }

    return NULL;
}</code></pre><p>内核版本不同，相关内核函数也会有一些差异，主要是参数这块，参数传递出问题可能导致内核hang死；代码中有对2.6.32和3.10.0内核版本做区分，这边以3.10.0为准；netlink_kernel_create是内核创建netlink的api，SYSHOOK_NL_NUM宏为31，结合用户态netlink socket那块可知是自定义的netlink协议类型，netlink_kernel_create创建时也需要指定：</p>
<pre><code>#if LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 32)
    /*NetLink do not recv from userSpace*/
    syshook_nl_sk = netlink_kernel_create(&amp;init_net, SYSHOOK_NL_NUM, 0, NULL, NULL, THIS_MODULE);
    if(!syshook_nl_sk) {
        pr_err(&quot;syshook: can not create netlink socket.\n&quot;);
        return -EIO;
    }
#elif LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 10, 0)
    syshook_nl_sk = netlink_kernel_create(&amp;init_net, SYSHOOK_NL_NUM, NULL);
    if(!syshook_nl_sk) {
        pr_err(&quot;syshook: can not create netlink socket.\n&quot;);
        return -EIO;
    }
#endif
    pr_err(&quot;syshook: create netlink success.\n&quot;);</code></pre><p>调kallsyms_lookup_name获取getname和putname的内核函数地址：</p>
<pre><code>#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 10, 0)
    tmp_getname = (void *)kallsyms_lookup_name(&quot;getname&quot;);
    if(!tmp_getname) {
        pr_err(&quot;unknow Symbol getname\n&quot;);
        return -1;
    }

    tmp_putname = (void *)kallsyms_lookup_name(&quot;putname&quot;);
    if(!tmp_putname) {
        pr_err(&quot;unknow Symbol putname\n&quot;);
        return -1;
    }
#endif</code></pre><p>然后就是函数尾部的syscall_table的覆写了，系统调用表在内核中是只读的，直接写会导致内核oops，设置cr0寄存器中内存写保护的状态位；之后将64位系统下全量的系统调用地址和execve系统调用地址分别进行保存，方便hook后的恢复，这边为啥要全量没搞懂，按理说保存hook的那个就好了；最终，覆写系统调用表中execve地址为monitor_stub_execve_hook函数地址；覆写完毕后恢复cr0：</p>
<pre><code>    original_cr0 = read_cr0();
    write_cr0(original_cr0 &amp; ~0x00010000);
    pr_err(&quot;Loading module monitor_execve, sys_call_table at %p\n&quot;, sys_call_table_ptr);

    for(i = 0; i &lt; NR_syscalls - 1; i ++) {
        orig_sys_call_table[i] = sys_call_table_ptr[i];
    }

    orig_stub_execve = (void *)(sys_call_table_ptr[__NR_execve]);
    sys_call_table_ptr[__NR_execve]= (void *)monitor_stub_execve_hook;

    write_cr0(original_cr0);
    return 0;
**monitor_stub_execve_hook**</code></pre><p>monitor_stub_execve_hook函数在syscall_stub_hook.S中，函数逻辑是这样的，首先全部寄存器压栈保存环境，防止真正execve执行时候出问题；调用monitor_execve_hook函数，恢复寄存器环境，跳到orig_sys_call_table表中index为rax（系统调用号）的地址执行，即原生的execve系统调用：</p>
<pre><code>.text
.global monitor_stub_execve_hook

monitor_stub_execve_hook:
pushq   %rbx
pushq   %rdi
pushq   %rsi
pushq   %rdx
pushq   %rcx
pushq   %rax
pushq   %r8 
pushq   %r9 
pushq   %r10
pushq   %r11

call monitor_execve_hook

pop     %r11
pop     %r10
pop     %r9 
pop     %r8 
pop     %rax
pop     %rcx
pop     %rdx
pop     %rsi
pop     %rdi

pop     %rbx
jmp     *orig_sys_call_table(, %rax, 8)</code></pre><p><strong>monitor_execve_hook</strong></p>
<p>首先是一些初始化动作：</p>
<pre><code>asmlinkage long monitor_execve_hook(const char __user *filename, 
                          const char __user *const __user *argv,
                          const char __user *const __user *envp)
{
    int error = 0, i = 0, len = 0, offset = 0, max_len = 0;
    struct filename *path = NULL;
    const char __user * native = NULL;
    char *total_argc_ptr = NULL;
    char *total_envpc_ptr = NULL;
    char *per_envp = NULL;
    int tmp_argc = 0, total_argc_len = 0;
    int tmp_envpc = 0, total_envpc_len = 0;
    struct user_arg_ptr argvx = { .ptr.native = argv };
    struct user_arg_ptr envpx = { .ptr.native = envp };
    int nl_send_len = 0;
    struct sk_buff *skb = NULL;
    struct nlmsghdr *nlh = NULL;
    struct file *file = NULL;
    char *tmp = kmalloc(PATH_MAX, GFP_KERNEL);
    char *path1 = NULL;</code></pre><p>tmp_getname保存了getname内核函数的地址，用其获取filename指针指向的路径名，之所以无法直接使用filename是因为本质上filename指针指向的用户空间地址，得先用getname拷贝到内核空间中；利用open_exec获取文件对应的file结构指针，调d_path获取文件绝对路径，最后用fput减少文件对象的引用计数并判断是否进行释放：</p>
<pre><code>        path = tmp_getname(filename);
    // printk(&quot;path:%s\n&quot;,path-&gt;name);
    error = PTR_ERR(path);
    if (IS_ERR(path)) {
        goto err;
    }

    file = open_exec(path-&gt;name);
    if (!IS_ERR(file) &amp;&amp; tmp) {
        memset(tmp, 0, PATH_MAX);
        path1 = d_path(&amp;file-&gt;f_path, tmp, PATH_MAX);
        if (IS_ERR(path1)) {
            path1 = NULL;
        }
        fput(file);
    }

    error = 0;</code></pre><p>首先调tmp_count判断execve执行进程对应的参数数量，tmp_count内部逻辑是这样的，遍历argv索引，调get_user_arg_ptr从用户态拿对应索引处的字符串指针，一旦检测到指针为null，则返回i，即程序执行的参数数量；返回值赋值给tmp_argc；之后根据argc值循环获取每一个参数长度并累加；最后根据total_argc_len长度分配内核空间并memset置位：</p>
<pre><code>        tmp_argc = tmp_count(argvx, MAX_ARG_STRINGS);
    if(tmp_argc &lt; 0) {
        error = tmp_argc;
        goto err;
    }

    for(i = 0; i &lt; tmp_argc; i ++) {
        native = get_user_arg_ptr(argvx, i);
        if(IS_ERR(native)) {
            error = -EFAULT;
            goto err;
        }
        // printk(&quot;native0:%s\n&quot;,native);
        len = strnlen_user(native, MAX_ARG_STRLEN);
        if(!len) {
            error = -EFAULT;
            goto err;
        }

        total_argc_len += len;
        printk(&quot;total_len:%n\n&quot;,total_argc_len);
    }
    total_argc_ptr = kmalloc(total_argc_len + 16 * tmp_argc, GFP_ATOMIC);
    if(!total_argc_ptr) {
        error = -ENOMEM;
        goto err;
    }
    memset(total_argc_ptr, 0, total_argc_len + 16 * tmp_argc);</code></pre><pre><code>static int tmp_count(struct user_arg_ptr argv, int max)
{
    int i = 0;

    if (argv.ptr.native != NULL) {
        for (;;) {
            const char __user *p = get_user_arg_ptr(argv, i); 

            if (!p)
                break;

            if (IS_ERR(p))
                return -EFAULT;

            if (i &gt;= max)
                return -E2BIG;
            ++i;

            if (fatal_signal_pending(current))
                return -ERESTARTNOHAND;
            cond_resched();
        }   
    }   
    return i;
}</code></pre><p>根据参数数量获取每一个参数字符串指针，再用copy_from_user完成字符串从用户态到内核态的内存的覆写：</p>
<pre><code>        for(i = 0; i &lt; tmp_argc; i ++) {
        if(i == 0) {
            continue;
        }
        native = get_user_arg_ptr(argvx, i);
        if(IS_ERR(native)) {
            error = -EFAULT;
            goto err;
        }

        len = strnlen_user(native, MAX_ARG_STRLEN);
        if(!len) {
            error = -EFAULT;
            goto err;
        }

        if(offset + len &gt; total_argc_len + 16 * tmp_argc) {
            break;
        }

        if (copy_from_user(total_argc_ptr + offset, native, len)) {
            error = -EFAULT;
            goto err;
        }
        offset += len - 1;
        *(total_argc_ptr + offset) = &#39; &#39;;
        offset += 1;
    }</code></pre><p>下面的envpx环境变量和argv的获取是基本一致的，不再赘述</p>
<p>计算需要发送的数据长度，检查对应指针是否正确，分配socket buffer（skb），设置netlink msg格式，包括msg length、pid、flags等；调用nlmsg_put把一个新的netlink message放到skb中；根据task_struct获取pexe、参数、pid、pname、ppid、环境变量并将其格式化（0x1组合）放到netlink header后，同时设置skb相关参数，其中，portid表示源，dst_group代表skb传输的目标组id：</p>
<pre><code>        nl_send_len = (path1 != NULL ? strlen(path1) : strlen(path-&gt;name)) + strlen(current-&gt;parent-&gt;comm) + 128;
    if(!ZERO_OR_NULL_PTR(total_envpc_ptr)) {
        nl_send_len += strlen(total_envpc_ptr);
    }   
    if(!ZERO_OR_NULL_PTR(total_argc_ptr)) {
        nl_send_len += strlen(total_argc_ptr);
    }
    nl_send_len = nl_send_len &lt; PATH_MAX + 2048 ? nl_send_len : PATH_MAX + 2048;
    skb = alloc_skb(NLMSG_SPACE(nl_send_len), GFP_ATOMIC);
    if(!skb) {
        error = -ENOMEM;
        goto err;
    }

    nlh = (struct nlmsghdr *)skb-&gt;data;
    nlh-&gt;nlmsg_len = NLMSG_SPACE(nl_send_len);
    nlh-&gt;nlmsg_pid = 0;
    nlh-&gt;nlmsg_flags = 0;
    nlh = nlmsg_put(skb, 0, 0, 0, NLMSG_SPACE(nl_send_len) - sizeof (struct nlmsghdr), 0);
    if(!nlh) {
        kfree_skb(skb);
        pr_err(&quot;nlh get failed.\n&quot;);
        goto err;
    }
    snprintf(NLMSG_DATA(nlh), nl_send_len, &quot;%s%c%s%c%u%c%s%c%d%c%s&quot;, path1 != NULL ? path1 : path-&gt;name, 0x1, (uint64_t)total_argc_ptr == 0x10 ? &quot;N/A&quot; : total_argc_ptr, 0x1, current-&gt;tgid, 0x1, current-&gt;parent-&gt;comm, 0x1, current-&gt;parent-&gt;tgid, 0x1, (uint64_t)total_envpc_ptr == 0x10 ? &quot;N/A&quot; : total_envpc_ptr);
    NETLINK_CB(skb).portid = 0;
    NETLINK_CB(skb).dst_group = 1;</code></pre><p><strong>netlink_broadcast</strong></p>
<p>调用netlink_broadcast向连接到netlink的多播组1进行广播（多播），传输的消息体存放在skb中，skb的data段保存了要发送的netlink消息结构：</p>
<pre><code>    error = netlink_broadcast(syshook_nl_sk, skb, 0, 1, 0);</code></pre><p><strong>debug</strong></p>
<p>Dmesg</p>
<p><img src="./image-20201023183519589.png" alt="image-20201023183519589"></p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>分析到这边就结束了， 总结一下：</p>
<p>1、go调用层监听本地的udp:65530端口并循环从socket中读取lkm捕获的进程事件，上层做事件解析和过滤；</p>
<p>2、c调用层创建自定义协议的netlink socket并不断从中获取来自内核的事件；同时创建本地udp socket，将从内核获取的事件通过udp socket传输发送给另一方</p>
<p>3、kernel实现层通过hook execve捕获进程创建事件并将消息放入skb中，之后通过netlink_broadcast进行广播，将消息发送给指定播组</p>
<p>关于netlink这块的一些细节还不是特别清楚，之后会继续学习源码，期待后面的netlink通信原理分析</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag"># 源码分析</a>
              <a href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" rel="tag"># 二进制</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/10/20/Yulong-Hids%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" rel="prev" title="Yulong-Hids架构设计与功能原理分析">
                  <i class="fa fa-chevron-left"></i> Yulong-Hids架构设计与功能原理分析
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/10/28/Osquery%E6%A3%80%E6%B5%8B%E6%A1%86%E6%9E%B6%E5%88%9D%E6%8E%A2/" rel="next" title="Osquery检测框架初探">
                  Osquery检测框架初探 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XDW</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>



    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/prismjs@1.21.0/components/prism-core.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/prismjs@1.21.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  















  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  

</body>
</html>
