<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic|Lobster+Two:300,300italic,400,400italic,700,700italic|EB+Garamond:300,300italic,400,400italic,700,700italic|Roboto+Slab:300,300italic,400,400italic,700,700italic|Source+Code+Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"driverxdw.github.io","root":"/","scheme":"Muse","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="一、前言公司hids平台目前的事件监控维度相对较少，于是老大借鉴sysdig手撸了一个内核模块从kernel解析syscall事件，以此增加监控的事件类型，也为后续的产品检测能力增强提供了数据基础。但是dalao手撸的内核模块存在一些bug，在帮dalao找bug、保证内核模块稳定性的过程中深入了解了sysdig这个项目本身的一些代码层面的东西，同时也解开了之前看falco时候的许多代码执行流程上">
<meta property="og:type" content="article">
<meta property="og:title" content="Sysdig Source Code Analysis">
<meta property="og:url" content="https://driverxdw.github.io/2021/05/29/Sysdig-Source-Code-Analysis/index.html">
<meta property="og:site_name" content="in0va&#39;S Blog  JustLearnM0re">
<meta property="og:description" content="一、前言公司hids平台目前的事件监控维度相对较少，于是老大借鉴sysdig手撸了一个内核模块从kernel解析syscall事件，以此增加监控的事件类型，也为后续的产品检测能力增强提供了数据基础。但是dalao手撸的内核模块存在一些bug，在帮dalao找bug、保证内核模块稳定性的过程中深入了解了sysdig这个项目本身的一些代码层面的东西，同时也解开了之前看falco时候的许多代码执行流程上">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://driverxdw.github.io/2021/05/29/Sysdig-Source-Code-Analysis/image-20210529182714338.png">
<meta property="article:published_time" content="2021-05-29T09:46:27.000Z">
<meta property="article:modified_time" content="2021-06-02T16:25:12.613Z">
<meta property="article:author" content="XDW">
<meta property="article:tag" content="源码分析">
<meta property="article:tag" content="二进制">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://driverxdw.github.io/2021/05/29/Sysdig-Source-Code-Analysis/image-20210529182714338.png">


<link rel="canonical" href="https://driverxdw.github.io/2021/05/29/Sysdig-Source-Code-Analysis/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Sysdig Source Code Analysis | in0va'S Blog  JustLearnM0re</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">in0va'S Blog  JustLearnM0re</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">犯二</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">89</span></a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、前言"><span class="nav-number">1.</span> <span class="nav-text">一、前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、架构"><span class="nav-number">2.</span> <span class="nav-text">二、架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、源码分析"><span class="nav-number">3.</span> <span class="nav-text">三、源码分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、总结"><span class="nav-number">4.</span> <span class="nav-text">四、总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五、参考链接"><span class="nav-number">5.</span> <span class="nav-text">五、参考链接</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XDW"
      src="/images/author.jpg">
  <p class="site-author-name" itemprop="name">XDW</p>
  <div class="site-description" itemprop="description">一枚很菜但是仍在学习的二进制菜逼</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">89</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.ixuchao.cn/" title="https:&#x2F;&#x2F;blog.ixuchao.cn&#x2F;" rel="noopener" target="_blank">Archerx's Blog</a>
        </li>
    </ul>
  </div>

      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://driverxdw.github.io/2021/05/29/Sysdig-Source-Code-Analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="XDW">
      <meta itemprop="description" content="一枚很菜但是仍在学习的二进制菜逼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="in0va'S Blog  JustLearnM0re">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Sysdig Source Code Analysis
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-29 17:46:27" itemprop="dateCreated datePublished" datetime="2021-05-29T17:46:27+08:00">2021-05-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-03 00:25:12" itemprop="dateModified" datetime="2021-06-03T00:25:12+08:00">2021-06-03</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/HIDS/" itemprop="url" rel="index"><span itemprop="name">HIDS</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>公司hids平台目前的事件监控维度相对较少，于是老大借鉴sysdig手撸了一个内核模块从kernel解析syscall事件，以此增加监控的事件类型，也为后续的产品检测能力增强提供了数据基础。但是dalao手撸的内核模块存在一些bug，在帮dalao找bug、保证内核模块稳定性的过程中深入了解了sysdig这个项目本身的一些代码层面的东西，同时也解开了之前看falco时候的许多代码执行流程上的困惑，非常愉悦，这边做下记录和总结。</p>
<a id="more"></a>

<h1 id="二、架构"><a href="#二、架构" class="headerlink" title="二、架构"></a>二、架构</h1><p>放一下sysdig整体架构图并做下大概说明：</p>
<p>主要是用户态、内核态两块，sysdig-probe在内核态通过tracepoint解析syscalls做事件收集，封装好的事件数据写入一个sysdig自己实现的ringbuffer；用户态scap从ringbuffer取数据放入特定结构体交给sinsp解析组成具体事件，sinsp将组装好的事件继续向上传递给sysdig CLI，由其根据用户输入的参数通过规则引擎对上传的事件进行过滤等，将用户想要的事件结果进行输出展示。sysdig最基本的流程和主要功能就是这样。</p>
<p><img src="./image-20210529182714338.png" alt="image-20210529182714338"></p>
<p>流程理解了，现在有一些细节需要去深入，总结出如下几个问题：</p>
<p>1、内核模块是如何通过tracepoint收集事件的</p>
<p>2、sysdig中ringbuffer是如何实现的</p>
<p>3、scap如何从ringbuffer中取事件的，取出来的是什么，并且还做了什么操作</p>
<p>4、sinsp如何通过scap传递的数据解析出事件的，除了解析事件，还做了什么操作</p>
<p>主要就是如上几个问题，sysdig CLI的命令解析那边比较简单且暂时没有需求接触到，所以暂时不会进行深入分析。</p>
<h1 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h1><p><strong>driver-main.c-sysdig_init</strong></p>
<p>首先看driver的初始执行函数sysdig_init，其中在开头执行了get_tracepoint_handles函数，进入其中查看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysdig_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">dev_t</span> dev;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num_cpus;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">int</span> acrret = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(4, 10, 0))</span></span><br><span class="line">	<span class="keyword">int</span> hp_ret;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">int</span> n_created_devices = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt; KERNEL_VERSION(2, 6, 20)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">class_device</span> *<span class="title">device</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	pr_info(<span class="string">"driver loading, "</span> PROBE_NAME <span class="string">" "</span> PROBE_VERSION <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	ret = get_tracepoint_handles();</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> init_module_err;</span><br><span class="line"></span><br><span class="line">	num_cpus = <span class="number">0</span>;</span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		++num_cpus;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>进入get_tracepoint_handles，发现调用了<code>for_each_kernel_tracepoint(visit_tracepoint, NULL);</code>操作，内核源码树里找一下，发现<code>for_each_kernel_tracepoint</code>函数的定义，对所有内核tracepoint点做迭代，同时将一个回调函数地址作为参数；继续进入visit_tracepoint查看，发现会在for_each_kernel_tracepoint迭代内核tracepoint点的过程中调用此回调函数，与sysdig指定的tracepoint名做比较，若一致，则将内核tracepoint结构体指针复制给全局变量；这些指定的tracepoint即为sysdig需要去做监控的tracepoint，通过这种方式拿到所有内核tracepoint结构信息；<code>for_each_kernel_tracepoint</code>函数返回后会对全局结构体指针是否成功获取做检测：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_tracepoint_handles</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	for_each_kernel_tracepoint(visit_tracepoint, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!tp_sys_enter) &#123;</span><br><span class="line">		pr_err(<span class="string">"failed to find sys_enter tracepoint\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!tp_sys_exit) &#123;</span><br><span class="line">		pr_err(<span class="string">"failed to find sys_exit tracepoint\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!tp_sched_process_exit) &#123;</span><br><span class="line">		pr_err(<span class="string">"failed to find sched_process_exit tracepoint\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPTURE_CONTEXT_SWITCHES</span></span><br><span class="line">	<span class="keyword">if</span> (!tp_sched_switch) &#123;</span><br><span class="line">		pr_err(<span class="string">"failed to find sched_switch tracepoint\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPTURE_SIGNAL_DELIVERIES</span></span><br><span class="line">	<span class="keyword">if</span> (!tp_signal_deliver) &#123;</span><br><span class="line">		pr_err(<span class="string">"failed to find signal_deliver tracepoint\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPTURE_PAGE_FAULTS</span></span><br><span class="line">	<span class="keyword">if</span> (!tp_page_fault_user) &#123;</span><br><span class="line">		pr_notice(<span class="string">"failed to find page_fault_user tracepoint, disabling page-faults\n"</span>);</span><br><span class="line">		g_fault_tracepoint_disabled = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!tp_page_fault_kernel) &#123;</span><br><span class="line">		pr_notice(<span class="string">"failed to find page_fault_kernel tracepoint, disabling page-faults\n"</span>);</span><br><span class="line">		g_fault_tracepoint_disabled = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * for_each_kernel_tracepoint - iteration on all kernel tracepoints</span></span><br><span class="line"><span class="comment"> * @fct: callback</span></span><br><span class="line"><span class="comment"> * @priv: private data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">for_each_kernel_tracepoint</span><span class="params">(<span class="keyword">void</span> (*fct)(struct tracepoint *tp, <span class="keyword">void</span> *priv),</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">void</span> *priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	for_each_tracepoint_range(__start___tracepoints_ptrs,</span><br><span class="line">		__stop___tracepoints_ptrs, fct, priv);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(for_each_kernel_tracepoint);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visit_tracepoint</span><span class="params">(struct tracepoint *tp, <span class="keyword">void</span> *priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tp-&gt;name, <span class="string">"sys_enter"</span>))</span><br><span class="line">		tp_sys_enter = tp;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tp-&gt;name, <span class="string">"sys_exit"</span>))</span><br><span class="line">		tp_sys_exit = tp;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tp-&gt;name, <span class="string">"sched_process_exit"</span>))</span><br><span class="line">		tp_sched_process_exit = tp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPTURE_CONTEXT_SWITCHES</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tp-&gt;name, <span class="string">"sched_switch"</span>))</span><br><span class="line">		tp_sched_switch = tp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPTURE_SIGNAL_DELIVERIES</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tp-&gt;name, <span class="string">"signal_deliver"</span>))</span><br><span class="line">		tp_signal_deliver = tp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPTURE_PAGE_FAULTS</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tp-&gt;name, <span class="string">"page_fault_user"</span>))</span><br><span class="line">		tp_page_fault_user = tp;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tp-&gt;name, <span class="string">"page_fault_kernel"</span>))</span><br><span class="line">		tp_page_fault_kernel = tp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>alloc_chrdev_region</code>函数向内核动态申请设备号，其中参数含义如下，dev：函数向内核申请下来的设备号，baseminor：次设备号的起始，count：申请次设备号个数，name：设备名（cat /proc/devices中显示的设备名称）；之后使用<code>kmalloc_array</code>函数以g_ppm_numbers变量的值作为长度，ppm_device结构体的size作为大小创建结构体数组，返回一个指向创建数组所在内存首地址的指针给g_ppm_devs；g_ppm_numdevs是cpu核数，放在这边应该是想创建对应数量的ringbuffer：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">	acrret = alloc_chrdev_region(&amp;dev, <span class="number">0</span>, num_cpus + <span class="number">1</span>, PROBE_DEVICE_NAME);</span><br><span class="line">	<span class="keyword">if</span> (acrret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		pr_err(<span class="string">"could not allocate major number for %s\n"</span>, PROBE_DEVICE_NAME);</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> init_module_err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g_ppm_class = class_create(THIS_MODULE, PROBE_DEVICE_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(g_ppm_class)) &#123;</span><br><span class="line">		pr_err(<span class="string">"can't allocate device class\n"</span>);</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> init_module_err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt; KERNEL_VERSION(2, 6, 20)</span></span><br><span class="line">	g_ppm_class-&gt;devnode = ppm_devnode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	g_ppm_major = MAJOR(dev);</span><br><span class="line">	g_ppm_numdevs = num_cpus;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(3, 4, 0)</span></span><br><span class="line">	g_ppm_devs = kmalloc(g_ppm_numdevs * <span class="keyword">sizeof</span>(struct ppm_device), GFP_KERNEL);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	g_ppm_devs = kmalloc_array(g_ppm_numdevs, <span class="keyword">sizeof</span>(struct ppm_device), GFP_KERNEL);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (!g_ppm_devs) &#123;</span><br><span class="line">		pr_err(<span class="string">"can't allocate devices\n"</span>);</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> init_module_err;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>cdev_init</code>函数初始化cdev字符设备，第一个参数为将要被初始化的设备结构体指针，第二个参数为该设备对应的文件操作函数地址，cdev_init执行完成后，cdev即与file_operations完成绑定，完成绑定后，用户态应用程序可以通过cdev设备绑定的这些函数（系统调用）操纵此字符设备；使用<code>cdev_add</code>向系统添加初始化后的cdev设备以完成注册：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g_ppm_numdevs; ++j) &#123;</span><br><span class="line">		cdev_init(&amp;g_ppm_devs[j].cdev, &amp;g_ppm_fops);</span><br><span class="line">		g_ppm_devs[j].dev = MKDEV(g_ppm_major, j);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (cdev_add(&amp;g_ppm_devs[j].cdev, g_ppm_devs[j].dev, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			pr_err(<span class="string">"could not allocate chrdev for %s\n"</span>, PROBE_DEVICE_NAME);</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> init_module_err;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt; KERNEL_VERSION(2, 6, 20)</span></span><br><span class="line">		device = device_create(</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">		device = class_device_create(</span><br><span class="line">#endif</span><br><span class="line">						g_ppm_class, <span class="literal">NULL</span>, <span class="comment">/* no parent device */</span></span><br><span class="line">						g_ppm_devs[j].dev,</span><br><span class="line">						<span class="literal">NULL</span>, <span class="comment">/* no additional data */</span></span><br><span class="line">						PROBE_DEVICE_NAME <span class="string">"%d"</span>,</span><br><span class="line">						j);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(device)) &#123;</span><br><span class="line">			pr_err(<span class="string">"error creating the device for  %s\n"</span>, PROBE_DEVICE_NAME);</span><br><span class="line">			cdev_del(&amp;g_ppm_devs[j].cdev);</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> init_module_err;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		init_waitqueue_head(&amp;g_ppm_devs[j].read_queue);</span><br><span class="line">		n_created_devices++;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cdev_init() - initialize a cdev structure</span></span><br><span class="line"><span class="comment"> * @cdev: the structure to initialize</span></span><br><span class="line"><span class="comment"> * @fops: the file_operations for this device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Initializes @cdev, remembering @fops, making it ready to add to the</span></span><br><span class="line"><span class="comment"> * system with cdev_add().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_init</span><span class="params">(struct cdev *cdev, <span class="keyword">const</span> struct file_operations *fops)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(cdev, <span class="number">0</span>, <span class="keyword">sizeof</span> *cdev);</span><br><span class="line">	INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);</span><br><span class="line">	kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);</span><br><span class="line">	cdev-&gt;ops = fops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cdev_add() - add a char device to the system</span></span><br><span class="line"><span class="comment"> * @p: the cdev structure for the device</span></span><br><span class="line"><span class="comment"> * @dev: the first device number for which this device is responsible</span></span><br><span class="line"><span class="comment"> * @count: the number of consecutive minor numbers corresponding to this</span></span><br><span class="line"><span class="comment"> *         device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * cdev_add() adds the device represented by @p to the system, making it</span></span><br><span class="line"><span class="comment"> * live immediately.  A negative error code is returned on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cdev_add</span><span class="params">(struct cdev *p, <span class="keyword">dev_t</span> dev, <span class="keyword">unsigned</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">	p-&gt;dev = dev;</span><br><span class="line">	p-&gt;count = count;</span><br><span class="line"></span><br><span class="line">	error = kobj_map(cdev_map, dev, count, <span class="literal">NULL</span>,</span><br><span class="line">			 exact_match, exact_lock, p);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">	kobject_get(p-&gt;kobj.parent);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sysdig_init模块初始化函数的后半部分主要是一些初始化模块异常处理、字符设备卸载等操作，重要程度相对较低，暂不分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> (dpi_lookahead_init() != PPM_SUCCESS) &#123;</span><br><span class="line">		pr_err(<span class="string">"initializing lookahead-based snaplen failed\n"</span>);</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> init_module_err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set up our callback in case we get a hotplug even while we are</span></span><br><span class="line"><span class="comment">	 * initializing the cpu structures</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(4, 10, 0))</span></span><br><span class="line">	hp_ret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,</span><br><span class="line">					   <span class="string">"sysdig/probe:online"</span>,</span><br><span class="line">					   sysdig_cpu_online,</span><br><span class="line">					   sysdig_cpu_offline);</span><br><span class="line">	<span class="keyword">if</span> (hp_ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		pr_err(<span class="string">"error registering cpu hotplug callback\n"</span>);</span><br><span class="line">		ret = hp_ret;</span><br><span class="line">		<span class="keyword">goto</span> init_module_err;</span><br><span class="line">	&#125;</span><br><span class="line">	hp_state = hp_ret;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	register_cpu_notifier(&amp;cpu_notifier);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * All ok. Final initializations.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	g_tracepoint_registered = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">init_module_err:</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n_created_devices; ++j) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt; KERNEL_VERSION(2, 6, 20)</span></span><br><span class="line">		device_destroy(</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">		class_device_destroy(</span><br><span class="line">#endif</span><br><span class="line">				g_ppm_class, g_ppm_devs[j].dev);</span><br><span class="line"></span><br><span class="line">		cdev_del(&amp;g_ppm_devs[j].cdev);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (g_ppm_class)</span><br><span class="line">		class_destroy(g_ppm_class);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (acrret == <span class="number">0</span>)</span><br><span class="line">		unregister_chrdev_region(dev, g_ppm_numdevs);</span><br><span class="line"></span><br><span class="line">	kfree(g_ppm_devs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后主要是看用户态应用程序在对字符设备文件做特定系统调用时（open、ioctl、etc.）触发的内核回调了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">g_ppm_fops</span> = &#123;</span></span><br><span class="line">	.<span class="built_in">open</span> = ppm_open,</span><br><span class="line">	.<span class="built_in">release</span> = ppm_release,</span><br><span class="line">	.mmap = ppm_mmap,</span><br><span class="line">	.unlocked_ioctl = ppm_ioctl,</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ppm_open：</p>
<p>主要看下tracepoint注册相关（其实除了tracepoint注册，还有很多像ringbuffer初始化，consumer结构初始化、cpu调度、同步等等操作，但是太菜还不是很了解，这边主要看下函数的核心逻辑），都是调内核函数tracepoint_probe_register完成tracepoint注册回调，不再赘述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">	reset_ring_buffer(ring);</span><br><span class="line">	ring-&gt;<span class="built_in">open</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!g_tracepoint_registered) &#123;</span><br><span class="line">		pr_info(<span class="string">"starting capture\n"</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Enable the tracepoints</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt; KERNEL_VERSION(2, 6, 20)</span></span><br><span class="line">		ret = compat_register_trace(syscall_exit_probe, <span class="string">"sys_exit"</span>, tp_sys_exit);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		ret = register_trace_syscall_exit(syscall_exit_probe);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			pr_err(<span class="string">"can't create the sys_exit tracepoint\n"</span>);</span><br><span class="line">			<span class="keyword">goto</span> err_sys_exit;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt; KERNEL_VERSION(2, 6, 20)</span></span><br><span class="line">		ret = compat_register_trace(syscall_enter_probe, <span class="string">"sys_enter"</span>, tp_sys_enter);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		ret = register_trace_syscall_enter(syscall_enter_probe);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			pr_err(<span class="string">"can't create the sys_enter tracepoint\n"</span>);</span><br><span class="line">			<span class="keyword">goto</span> err_sys_enter;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret = compat_register_trace(syscall_procexit_probe, <span class="string">"sched_process_exit"</span>, tp_sched_process_exit);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			pr_err(<span class="string">"can't create the sched_process_exit tracepoint\n"</span>);</span><br><span class="line">			<span class="keyword">goto</span> err_sched_procexit;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPTURE_CONTEXT_SWITCHES</span></span><br><span class="line">		ret = compat_register_trace(sched_switch_probe, <span class="string">"sched_switch"</span>, tp_sched_switch);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			pr_err(<span class="string">"can't create the sched_switch tracepoint\n"</span>);</span><br><span class="line">			<span class="keyword">goto</span> err_sched_switch;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPTURE_SIGNAL_DELIVERIES</span></span><br><span class="line">		ret = compat_register_trace(signal_deliver_probe, <span class="string">"signal_deliver"</span>, tp_signal_deliver);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			pr_err(<span class="string">"can't create the signal_deliver tracepoint\n"</span>);</span><br><span class="line">			<span class="keyword">goto</span> err_signal_deliver;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		g_tracepoint_registered = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> cleanup_open;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPTURE_SIGNAL_DELIVERIES</span></span><br><span class="line">err_signal_deliver:</span><br><span class="line">	compat_unregister_trace(sched_switch_probe, <span class="string">"sched_switch"</span>, tp_sched_switch);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">err_sched_switch:</span><br><span class="line">	compat_unregister_trace(syscall_procexit_probe, <span class="string">"sched_process_exit"</span>, tp_sched_process_exit);</span><br><span class="line">err_sched_procexit:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt; KERNEL_VERSION(2, 6, 20)</span></span><br><span class="line">	compat_unregister_trace(syscall_enter_probe, <span class="string">"sys_enter"</span>, tp_sys_enter);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	unregister_trace_syscall_enter(syscall_enter_probe);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">err_sys_enter:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt; KERNEL_VERSION(2, 6, 20)</span></span><br><span class="line">	compat_unregister_trace(syscall_exit_probe, <span class="string">"sys_exit"</span>, tp_sys_exit);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	unregister_trace_syscall_exit(syscall_exit_probe);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">err_sys_exit:</span><br><span class="line">	ring-&gt;<span class="built_in">open</span> = <span class="literal">false</span>;</span><br><span class="line">err_init_ring_buffer:</span><br><span class="line">	check_remove_consumer(consumer, in_list);</span><br><span class="line">cleanup_open:</span><br><span class="line">	mutex_unlock(&amp;g_consumer_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compat_register_trace</span><span class="params">(<span class="keyword">void</span> *func, <span class="keyword">const</span> <span class="keyword">char</span> *probename, struct tracepoint *tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (LINUX_VERSION_CODE &lt; KERNEL_VERSION(3, 15, 0))</span></span><br><span class="line">	<span class="keyword">return</span> TRACEPOINT_PROBE_REGISTER(probename, func);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> tracepoint_probe_register(tp, func, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择最典型的sys_enter进行分析：</p>
<p>sys_enter可以看作是一个总入口，用户态做任何系统调用都会经过sys_enter这个tracepoint，通过sys_enter所在上下文的regs和task_struct结构，调syscall_get_nr拿到所执行对应系统调用的特定系统调用号；将此系统调用号作为cur_g_syscall_table的idx，从g_syscall_table中拿到used、drop_flags状态码以及enter_event_type类型；将其它数据如事件类型category（系统调用｜上下文切换｜信号｜缺页中断）、寄存器组结构regs、系统调用号id等赋给event_data事件结构体；调用record_event_all_consumers函数，猜测是将事件发送给对应consumer所在的ringbuffer处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">TRACEPOINT_PROBE(syscall_exit_probe, struct pt_regs *regs, <span class="keyword">long</span> ret)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">long</span> table_index;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">syscall_evt_pair</span> *<span class="title">cur_g_syscall_table</span> = <span class="title">g_syscall_table</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">enum</span> ppm_syscall_code *cur_g_syscall_code_routing_table = g_syscall_code_routing_table;</span><br><span class="line">	<span class="keyword">bool</span> compat = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __NR_socketcall</span></span><br><span class="line">	<span class="keyword">int</span> socketcall_syscall = __NR_socketcall;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">int</span> socketcall_syscall = <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	id = syscall_get_nr(current, regs);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_X86_64) &amp;&amp; defined(CONFIG_IA32_EMULATION)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When a process does execve from 64bit to 32bit, TS_COMPAT is marked true</span></span><br><span class="line"><span class="comment">	 * but the id of the syscall is __NR_execve, so to correctly parse it we need to</span></span><br><span class="line"><span class="comment">	 * use 64bit syscall table. On 32bit __NR_execve is equal to __NR_ia32_oldolduname</span></span><br><span class="line"><span class="comment">	 * which is a very old syscall, not used anymore by most applications</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(4, 9, 0)</span></span><br><span class="line">	<span class="keyword">if</span> (in_ia32_syscall() &amp;&amp; id != __NR_execve) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">if</span> (unlikely((task_thread_info(current)-&gt;status &amp; TS_COMPAT) &amp;&amp; id != __NR_execve)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		cur_g_syscall_table = g_syscall_ia32_table;</span><br><span class="line">		cur_g_syscall_code_routing_table = g_syscall_ia32_code_routing_table;</span><br><span class="line">		socketcall_syscall = __NR_ia32_socketcall;</span><br><span class="line">		compat = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	g_n_tracepoint_hit_inc();</span><br><span class="line"></span><br><span class="line">	table_index = id - SYSCALL_TABLE_ID0;</span><br><span class="line">	<span class="keyword">if</span> (likely(table_index &gt;= <span class="number">0</span> &amp;&amp; table_index &lt; SYSCALL_TABLE_SIZE)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">event_data_t</span> <span class="title">event_data</span>;</span></span><br><span class="line">		<span class="keyword">int</span> used = cur_g_syscall_table[table_index].flags &amp; UF_USED;</span><br><span class="line">		<span class="keyword">enum</span> syscall_flags drop_flags = cur_g_syscall_table[table_index].flags;</span><br><span class="line">		<span class="keyword">enum</span> ppm_event_type type;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Simple mode event filtering</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (g_simple_mode_enabled) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((drop_flags &amp; UF_SIMPLEDRIVER_KEEP) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _HAS_SOCKETCALL</span></span><br><span class="line">		<span class="keyword">if</span> (id == socketcall_syscall) &#123;</span><br><span class="line">			used = <span class="literal">true</span>;</span><br><span class="line">			drop_flags = UF_NEVER_DROP;</span><br><span class="line">			type = PPME_GENERIC_X;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			type = cur_g_syscall_table[table_index].exit_event_type;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		type = cur_g_syscall_table[table_index].exit_event_type;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		event_data.category = PPMC_SYSCALL;</span><br><span class="line">		event_data.event_info.syscall_data.regs = regs;</span><br><span class="line">		event_data.event_info.syscall_data.id = id;</span><br><span class="line">		event_data.event_info.syscall_data.cur_g_syscall_code_routing_table = cur_g_syscall_code_routing_table;</span><br><span class="line">		event_data.socketcall_syscall = socketcall_syscall;</span><br><span class="line">		event_data.compat = compat;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (used)</span><br><span class="line">			record_event_all_consumers(type, drop_flags, &amp;event_data);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			record_event_all_consumers(PPME_GENERIC_X, UF_ALWAYS_DROP, &amp;event_data);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * syscall_get_nr - find what system call a task is executing</span></span><br><span class="line"><span class="comment"> * @task:	task of interest, must be blocked</span></span><br><span class="line"><span class="comment"> * @regs:	task_pt_regs() of @task</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If @task is executing a system call or is at system call</span></span><br><span class="line"><span class="comment"> * tracing about to attempt one, returns the system call number.</span></span><br><span class="line"><span class="comment"> * If @task is not executing a system call, i.e. it's blocked</span></span><br><span class="line"><span class="comment"> * inside the kernel for a fault or signal, returns -1.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note this returns int even on 64-bit machines.  Only 32 bits of</span></span><br><span class="line"><span class="comment"> * system call number can be meaningful.  If the actual arch value</span></span><br><span class="line"><span class="comment"> * is 64 bits, this truncates to 32 bits so 0xffffffff means -1.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It's only valid to call this when @task is known to be blocked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">syscall_get_nr</span><span class="params">(struct task_struct *task, struct pt_regs *regs)</span></span>;</span><br></pre></td></tr></table></figure>

<p>record_event_all_consumers调用了record_event_consumer，首先对事件类型做过滤，检测对应类型的事件是否需要被丢弃；需要注意的是，这边对capture_enabled做了检查，而这个变量是需要用户态应用程序主动ioctl发送特定信号来置位的，具体可参考file_operations中的ppm_ioctl回调：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!test_bit(event_type, g_events_mask))</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (event_type != PPME_DROP_E &amp;&amp; event_type != PPME_DROP_X) &#123;</span><br><span class="line">	<span class="keyword">if</span> (consumer-&gt;need_to_insert_drop_e == <span class="number">1</span>)</span><br><span class="line">		record_drop_e(consumer, ns, drop_flags);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (consumer-&gt;need_to_insert_drop_x == <span class="number">1</span>)</span><br><span class="line">		record_drop_x(consumer, ns, drop_flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (drop_event(consumer,</span><br><span class="line">	               event_type,</span><br><span class="line">	               drop_flags,</span><br><span class="line">	               ns,</span><br><span class="line">	               event_datap-&gt;event_info.syscall_data.regs))</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * FROM THIS MOMENT ON, WE HAVE TO BE SUPER FAST</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">cpu = get_cpu();</span><br><span class="line">ring = per_cpu_ptr(consumer-&gt;ring_buffers, cpu);</span><br><span class="line">ASSERT(ring);</span><br><span class="line"></span><br><span class="line">ring_info = ring-&gt;info;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ring-&gt;capture_enabled) &#123;</span><br><span class="line">	put_cpu();</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ring_info-&gt;n_evts++;</span><br><span class="line"><span class="keyword">if</span> (event_datap-&gt;category == PPMC_CONTEXT_SWITCH &amp;&amp; event_datap-&gt;event_info.context_data.sched_prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (event_type != PPME_SYSDIGEVENT_E &amp;&amp; event_type != PPME_CPU_HOTPLUG_E) &#123;</span><br><span class="line">		ASSERT(event_datap-&gt;event_info.context_data.sched_prev != <span class="literal">NULL</span>);</span><br><span class="line">		ASSERT(event_datap-&gt;event_info.context_data.sched_next != <span class="literal">NULL</span>);</span><br><span class="line">		ring_info-&gt;n_context_switches++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对ringbuffer的剩余空间进行计算，需要注意的是，sysdig是从head指针指向的位置写，从tail指针指向的位置开始读，这和常用的读写标志应用的正好相反；ringbuffer是环形的，需要根据head和tail的相对位置将其分为两种状态对freespace进行计算，freespace计算出后，自然就能得到usedspace：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">head = ring_info-&gt;head;</span><br><span class="line">ttail = ring_info-&gt;tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ttail &gt; head)</span><br><span class="line">	freespace = ttail - head - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	freespace = RING_BUF_SIZE + ttail - head - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">usedspace = RING_BUF_SIZE - freespace - <span class="number">1</span>;</span><br><span class="line">delta_from_end = RING_BUF_SIZE + (<span class="number">2</span> * PAGE_SIZE) - head - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ASSERT(freespace &lt;= RING_BUF_SIZE);</span><br><span class="line">ASSERT(usedspace &lt;= RING_BUF_SIZE);</span><br><span class="line">ASSERT(ttail &lt;= RING_BUF_SIZE);</span><br><span class="line">ASSERT(head &lt;= RING_BUF_SIZE);</span><br><span class="line">ASSERT(delta_from_end &lt; RING_BUF_SIZE + (<span class="number">2</span> * PAGE_SIZE));</span><br><span class="line">ASSERT(delta_from_end &gt; (<span class="number">2</span> * PAGE_SIZE) - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>新建一个专用于事件参数过滤解析的结构体args，根据事件类型从g_event_info表中将对应事件的参数数量取出，并根据参数个数*2字节得到一个arg_data_offset的偏移，猜测是要用于后面的写buffer；之后计算freespace是否大于ppm_evt_hdr结构体和arg_data_offset的和之大小，判断ringbuffer的剩余空间能否再写入一个事件结构数据；若能继续写入，则将ringbuffer+head指针给hdr，将ns、pid、event_type、nargs等evt_header（即事件头）写入ringbuffer，然后将ringbuffer指针移位（累加上之前的evt_header大小）；否则drop此事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">args.nargs = g_event_info[event_type].nparams;</span><br><span class="line">	args.arg_data_offset = args.nargs * <span class="keyword">sizeof</span>(u16);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure we have enough space for the event header.</span></span><br><span class="line"><span class="comment">	 * We need at least space for the header plus 16 bit per parameter for the lengths.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(freespace &gt;= <span class="keyword">sizeof</span>(struct ppm_evt_hdr) + args.arg_data_offset)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Populate the header</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ppm_evt_hdr</span> *<span class="title">hdr</span> = (<span class="title">struct</span> <span class="title">ppm_evt_hdr</span> *)(<span class="title">ring</span>-&gt;<span class="title">buffer</span> + <span class="title">head</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PPM_ENABLE_SENTINEL</span></span><br><span class="line">		hdr-&gt;sentinel_begin = ring-&gt;nevents;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		hdr-&gt;ts = ns;</span><br><span class="line">		hdr-&gt;tid = current-&gt;pid;</span><br><span class="line">		hdr-&gt;type = event_type;</span><br><span class="line">		hdr-&gt;nparams = args.nargs;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Populate the parameters for the filler callback</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		args.consumer = consumer;</span><br><span class="line">		args.<span class="built_in">buffer</span> = ring-&gt;<span class="built_in">buffer</span> + head + <span class="keyword">sizeof</span>(struct ppm_evt_hdr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PPM_ENABLE_SENTINEL</span></span><br><span class="line">		args.sentinel = ring-&gt;nevents;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		args.buffer_size = <span class="built_in">min</span>(freespace, delta_from_end) - <span class="keyword">sizeof</span>(struct ppm_evt_hdr); <span class="comment">/* freespace is guaranteed to be bigger than sizeof(struct ppm_evt_hdr) */</span></span><br><span class="line">		args.event_type = event_type;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (event_datap-&gt;category == PPMC_SYSCALL) &#123;</span><br><span class="line">			args.regs = event_datap-&gt;event_info.syscall_data.regs;</span><br><span class="line">			args.syscall_id = event_datap-&gt;event_info.syscall_data.id;</span><br><span class="line">			args.cur_g_syscall_code_routing_table = event_datap-&gt;event_info.syscall_data.cur_g_syscall_code_routing_table;</span><br><span class="line">			args.compat = event_datap-&gt;compat;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			args.regs = <span class="literal">NULL</span>;</span><br><span class="line">			args.syscall_id = <span class="number">-1</span>;</span><br><span class="line">			args.cur_g_syscall_code_routing_table = <span class="literal">NULL</span>;</span><br><span class="line">			args.compat = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (event_datap-&gt;category == PPMC_CONTEXT_SWITCH) &#123;</span><br><span class="line">			args.sched_prev = event_datap-&gt;event_info.context_data.sched_prev;</span><br><span class="line">			args.sched_next = event_datap-&gt;event_info.context_data.sched_next;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			args.sched_prev = <span class="literal">NULL</span>;</span><br><span class="line">			args.sched_next = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (event_datap-&gt;category == PPMC_SIGNAL) &#123;</span><br><span class="line">			args.signo = event_datap-&gt;event_info.signal_data.sig;</span><br><span class="line">			<span class="keyword">if</span> (event_datap-&gt;event_info.signal_data.info == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				args.spid = (<span class="keyword">__kernel_pid_t</span>) <span class="number">0</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (args.signo == SIGKILL) &#123;</span><br><span class="line">				args.spid = event_datap-&gt;event_info.signal_data.info-&gt;_sifields._kill._pid;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (args.signo == SIGTERM || args.signo == SIGHUP || args.signo == SIGINT ||</span><br><span class="line">					args.signo == SIGTSTP || args.signo == SIGQUIT) &#123;</span><br><span class="line">				<span class="keyword">if</span> (event_datap-&gt;event_info.signal_data.info-&gt;si_code == SI_USER ||</span><br><span class="line">						event_datap-&gt;event_info.signal_data.info-&gt;si_code == SI_QUEUE ||</span><br><span class="line">						event_datap-&gt;event_info.signal_data.info-&gt;si_code &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">					args.spid = event_datap-&gt;event_info.signal_data.info-&gt;si_pid;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (args.signo == SIGCHLD) &#123;</span><br><span class="line">				args.spid = event_datap-&gt;event_info.signal_data.info-&gt;_sifields._sigchld._pid;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (args.signo &gt;= SIGRTMIN &amp;&amp; args.signo &lt;= SIGRTMAX) &#123;</span><br><span class="line">				args.spid = event_datap-&gt;event_info.signal_data.info-&gt;_sifields._rt._pid;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				args.spid = (<span class="keyword">__kernel_pid_t</span>) <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			args.signo = <span class="number">0</span>;</span><br><span class="line">			args.spid = (<span class="keyword">__kernel_pid_t</span>) <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		args.dpid = current-&gt;pid;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (event_datap-&gt;category == PPMC_PAGE_FAULT)</span><br><span class="line">			args.fault_data = event_datap-&gt;event_info.fault_data;</span><br><span class="line"></span><br><span class="line">		args.curarg = <span class="number">0</span>;</span><br><span class="line">		args.arg_data_size = args.buffer_size - args.arg_data_offset;</span><br><span class="line">		args.nevents = ring-&gt;nevents;</span><br><span class="line">		args.str_storage = ring-&gt;str_storage;</span><br><span class="line">		args.enforce_snaplen = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>根据事件类型从g_ppm_events表中找到对应事件的回调函数，将args结构体地址作为参数传入，在回调函数中将获取此事件的所有参数并填充到args结构体中；需要注意的是，这边用了多次宏，导致一开始较难发现实际指向的回调，认真分析后发现定义在ppm_filllers.c中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (likely(g_ppm_events[event_type].filler_callback)) &#123;</span><br><span class="line">			cbres = g_ppm_events[event_type].filler_callback(&amp;args);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pr_err(<span class="string">"corrupted filler for event type %d: NULL callback\n"</span>, event_type);</span><br><span class="line">			ASSERT(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ppm_event_entry</span> <span class="title">g_ppm_events</span>[<span class="title">PPM_EVENT_MAX</span>] = &#123;</span></span><br><span class="line">	[PPME_GENERIC_E] = &#123;FILLER_REF(sys_generic)&#125;,</span><br><span class="line">	[PPME_GENERIC_X] = &#123;FILLER_REF(sys_generic)&#125;,</span><br><span class="line">	[PPME_SYSCALL_OPEN_E] = &#123;FILLER_REF(sys_empty)&#125;,</span><br><span class="line">	[PPME_SYSCALL_OPEN_X] = &#123;FILLER_REF(sys_open_x)&#125;,</span><br><span class="line">	[PPME_SYSCALL_CLOSE_E] = &#123;FILLER_REF(sys_single)&#125;,</span><br><span class="line">	[PPME_SYSCALL_CLOSE_X] = &#123;FILLER_REF(sys_single_x)&#125;,</span><br><span class="line">	[PPME_SYSCALL_READ_E] = &#123;FILLER_REF(sys_autofill), <span class="number">2</span>, APT_REG, &#123;&#123;<span class="number">0</span>&#125;, &#123;<span class="number">2</span>&#125; &#125; &#125;,</span><br><span class="line">	[PPME_SYSCALL_READ_X] = &#123;FILLER_REF(sys_read_x)&#125;,</span><br><span class="line">	[PPME_SYSCALL_WRITE_E] = &#123;FILLER_REF(sys_autofill), <span class="number">2</span>, APT_REG, &#123;&#123;<span class="number">0</span>&#125;, &#123;<span class="number">2</span>&#125; &#125; &#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__KERNEL__) || defined(UDIG)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILLER_REF(x) f_##x, PPM_FILLER_##x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILLER_REF(x) 0, PPM_FILLER_##x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __KERNEL__ */</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILLER_ENUM_FN(x) PPM_FILLER_##x,</span></span><br><span class="line"><span class="keyword">enum</span> ppm_filler_id &#123;</span><br><span class="line">	FILLER_LIST_MAPPER(FILLER_ENUM_FN)</span><br><span class="line">	PPM_FILLER_MAX</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> FILLER_ENUM_FN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILLER_PROTOTYPE_FN(x) int f_##x(struct event_filler_arguments *args);</span></span><br><span class="line">FILLER_LIST_MAPPER(FILLER_PROTOTYPE_FN)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> FILLER_PROTOTYPE_FN</span></span><br></pre></td></tr></table></figure>

<p>仔细看可以发现此回调中获取并写入ringbuffer的数据全部是event_table.c中g_event_info里定义的特定系统调用事件结构中的参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f_sys_openat_x</span><span class="params">(struct event_filler_arguments *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> val;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> modes;</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line">	<span class="keyword">int64_t</span> retval;</span><br><span class="line"></span><br><span class="line">	retval = (<span class="keyword">int64_t</span>)syscall_get_return_value(current, args-&gt;regs);</span><br><span class="line">	res = val_to_ring(args, retval, <span class="number">0</span>, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(res != PPM_SUCCESS))</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * dirfd</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	syscall_get_arguments_deprecated(current, args-&gt;regs, <span class="number">0</span>, <span class="number">1</span>, &amp;val);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">int</span>)val == AT_FDCWD)</span><br><span class="line">		val = PPM_AT_FDCWD;</span><br><span class="line"></span><br><span class="line">	res = val_to_ring(args, val, <span class="number">0</span>, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(res != PPM_SUCCESS))</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * name</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	syscall_get_arguments_deprecated(current, args-&gt;regs, <span class="number">1</span>, <span class="number">1</span>, &amp;val);</span><br><span class="line">	res = val_to_ring(args, val, <span class="number">0</span>, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(res != PPM_SUCCESS))</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Flags</span></span><br><span class="line"><span class="comment">	 * Note that we convert them into the ppm portable representation before pushing them to the ring</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	syscall_get_arguments_deprecated(current, args-&gt;regs, <span class="number">2</span>, <span class="number">1</span>, &amp;flags);</span><br><span class="line">	res = val_to_ring(args, open_flags_to_scap(flags), <span class="number">0</span>, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(res != PPM_SUCCESS))</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *  mode</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	syscall_get_arguments_deprecated(current, args-&gt;regs, <span class="number">3</span>, <span class="number">1</span>, &amp;modes);</span><br><span class="line">	res = val_to_ring(args, open_modes_to_scap(flags, modes), <span class="number">0</span>, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(res != PPM_SUCCESS))</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * dev</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	res = val_to_ring(args, get_fd_dev(retval), <span class="number">0</span>, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(res != PPM_SUCCESS))</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> add_sentinel(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要特别说明的是val_to_ring这个参数值入ringbuffer函数，它主要由对应事件的回调函数调用并将每一个参数解析后写入ringbuffer；与前面的代码对应起来，其实就是在ringbuffer中本次事件的evt_header后依次写入每一个参数对应的字节码，写入的长度都在各分支中指定；每次入参到ringbuffer前都会检查本次写事件中ringbuffer的剩余长度是否足够支撑本次参数的写入，处于临界状态时就会返回PPM_FAILURE_BUFFER_FULL来drop掉此次事件，防止在临界状态下覆写tail后的数据造成ringbuffer数据错乱：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">val_to_ring</span><span class="params">(struct event_filler_arguments *args, <span class="keyword">uint64_t</span> val, u32 val_len, <span class="keyword">bool</span> fromuser, u8 dyn_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ppm_param_info</span> *<span class="title">param_info</span>;</span></span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">-1</span>;</span><br><span class="line">	u16 *psize = (u16 *)(args-&gt;<span class="built_in">buffer</span> + args-&gt;curarg * <span class="keyword">sizeof</span>(u16));</span><br><span class="line">	u32 max_arg_size = args-&gt;arg_data_size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(args-&gt;curarg &gt;= args-&gt;nargs)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UDIG</span></span><br><span class="line">		pr_err(<span class="string">"(%u)val_to_ring: too many arguments for event #%u, type=%u, curarg=%u, nargs=%u tid:%u\n"</span>,</span><br><span class="line">			smp_processor_id(),</span><br><span class="line">			args-&gt;nevents,</span><br><span class="line">			(u32)args-&gt;event_type,</span><br><span class="line">			args-&gt;curarg,</span><br><span class="line">			args-&gt;nargs,</span><br><span class="line">			current-&gt;pid);</span><br><span class="line">		memory_dump(args-&gt;<span class="built_in">buffer</span> - <span class="keyword">sizeof</span>(struct ppm_evt_hdr), <span class="number">32</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>		</span></span><br><span class="line">		ASSERT(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> PPM_FAILURE_BUG;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(args-&gt;arg_data_size == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> PPM_FAILURE_BUFFER_FULL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (max_arg_size &gt; PPM_MAX_ARG_SIZE)</span><br><span class="line">		max_arg_size = PPM_MAX_ARG_SIZE;</span><br><span class="line"></span><br><span class="line">	param_info = &amp;(g_event_info[args-&gt;event_type].params[args-&gt;curarg]);</span><br><span class="line">	<span class="keyword">if</span> (param_info-&gt;type == PT_DYN &amp;&amp; param_info-&gt;info != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ppm_param_info</span> *<span class="title">dyn_params</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(dyn_idx &gt;= param_info-&gt;ninfo)) &#123;</span><br><span class="line">			ASSERT(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> PPM_FAILURE_BUG;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UDIG</span></span><br><span class="line">		dyn_params = (<span class="keyword">const</span> struct ppm_param_info *)patch_pointer((<span class="keyword">uint8_t</span>*)param_info-&gt;info);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		dyn_params = (<span class="keyword">const</span> struct ppm_param_info *)param_info-&gt;info;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		param_info = &amp;dyn_params[dyn_idx];</span><br><span class="line">		<span class="keyword">if</span> (likely(max_arg_size &gt;= <span class="keyword">sizeof</span>(u8)))	&#123;</span><br><span class="line">			*(u8 *)(args-&gt;<span class="built_in">buffer</span> + args-&gt;arg_data_offset) = dyn_idx;</span><br><span class="line">			len = <span class="keyword">sizeof</span>(u8);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> PPM_FAILURE_BUFFER_FULL;</span><br><span class="line">		&#125;</span><br><span class="line">		args-&gt;arg_data_offset += len;</span><br><span class="line">		args-&gt;arg_data_size -= len;</span><br><span class="line">		max_arg_size -= len;</span><br><span class="line">		*psize = (u16)len;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		*psize = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (param_info-&gt;type) &#123;</span><br><span class="line">	<span class="keyword">case</span> PT_CHARBUF:</span><br><span class="line">	<span class="keyword">case</span> PT_FSPATH:</span><br><span class="line">		<span class="keyword">if</span> (likely(val != <span class="number">0</span>)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (fromuser) &#123;</span><br><span class="line">				len = ppm_strncpy_from_user(args-&gt;<span class="built_in">buffer</span> + args-&gt;arg_data_offset,</span><br><span class="line">					(<span class="keyword">const</span> <span class="keyword">char</span> __user *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)val, max_arg_size);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (unlikely(len &lt; <span class="number">0</span>))</span><br><span class="line">					<span class="keyword">return</span> PPM_FAILURE_INVALID_USER_MEMORY;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				len = strlcpy(args-&gt;<span class="built_in">buffer</span> + args-&gt;arg_data_offset,</span><br><span class="line">								(<span class="keyword">const</span> <span class="keyword">char</span> *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)val,</span><br><span class="line">								max_arg_size);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (++len &gt; max_arg_size)</span><br><span class="line">					len = max_arg_size;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Make sure the string is null-terminated</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			*(<span class="keyword">char</span> *)(args-&gt;<span class="built_in">buffer</span> + args-&gt;arg_data_offset + len) = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Handle NULL pointers</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			len = strlcpy(args-&gt;<span class="built_in">buffer</span> + args-&gt;arg_data_offset,</span><br><span class="line">				<span class="string">"(NULL)"</span>,</span><br><span class="line">				max_arg_size);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (++len &gt; max_arg_size)</span><br><span class="line">				len = max_arg_size;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PT_BYTEBUF:</span><br><span class="line">		<span class="keyword">if</span> (likely(val != <span class="number">0</span>)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (fromuser) &#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Copy the lookahead portion of the buffer that we will use DPI-based</span></span><br><span class="line"><span class="comment">				 * snaplen calculation</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				u32 dpi_lookahead_size = DPI_LOOKAHEAD_SIZE;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (dpi_lookahead_size &gt; val_len)</span><br><span class="line">					dpi_lookahead_size = val_len;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (unlikely(dpi_lookahead_size &gt;= max_arg_size))</span><br><span class="line">					<span class="keyword">return</span> PPM_FAILURE_BUFFER_FULL;</span><br><span class="line"></span><br><span class="line">				len = (<span class="keyword">int</span>)ppm_copy_from_user(args-&gt;<span class="built_in">buffer</span> + args-&gt;arg_data_offset,</span><br><span class="line">						(<span class="keyword">const</span> <span class="keyword">void</span> __user *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)val,</span><br><span class="line">						dpi_lookahead_size);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (unlikely(len != <span class="number">0</span>))</span><br><span class="line">					<span class="keyword">return</span> PPM_FAILURE_INVALID_USER_MEMORY;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Check if there's more to copy</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">if</span> (likely((dpi_lookahead_size != val_len))) &#123;</span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					 * Calculate the snaplen</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">					<span class="keyword">if</span> (likely(args-&gt;enforce_snaplen)) &#123;</span><br><span class="line">						u32 sl = args-&gt;consumer-&gt;snaplen;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UDIG</span></span><br><span class="line">						sl = compute_snaplen(args, args-&gt;<span class="built_in">buffer</span> + args-&gt;arg_data_offset, dpi_lookahead_size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">						<span class="keyword">if</span> (val_len &gt; sl)</span><br><span class="line">							val_len = sl;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (unlikely((val_len) &gt;= max_arg_size))</span><br><span class="line">						val_len = max_arg_size;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (val_len &gt; dpi_lookahead_size) &#123;</span><br><span class="line">						len = (<span class="keyword">int</span>)ppm_copy_from_user(args-&gt;<span class="built_in">buffer</span> + args-&gt;arg_data_offset + dpi_lookahead_size,</span><br><span class="line">								(<span class="keyword">const</span> <span class="keyword">void</span> __user *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)val + dpi_lookahead_size,</span><br><span class="line">								val_len - dpi_lookahead_size);</span><br><span class="line"></span><br><span class="line">						<span class="keyword">if</span> (unlikely(len != <span class="number">0</span>))</span><br><span class="line">							<span class="keyword">return</span> PPM_FAILURE_INVALID_USER_MEMORY;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				len = val_len;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (likely(args-&gt;enforce_snaplen)) &#123;</span><br><span class="line">#ifdef UDIG</span><br><span class="line">					u32 sl = args-&gt;consumer-&gt;snaplen;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">					u32 sl = compute_snaplen(args, (<span class="keyword">char</span> *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)val, val_len);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">					<span class="keyword">if</span> (val_len &gt; sl)</span><br><span class="line">						val_len = sl;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (unlikely(val_len &gt;= max_arg_size))</span><br><span class="line">					<span class="keyword">return</span> PPM_FAILURE_BUFFER_FULL;</span><br><span class="line"></span><br><span class="line">				<span class="built_in">memcpy</span>(args-&gt;<span class="built_in">buffer</span> + args-&gt;arg_data_offset,</span><br><span class="line">					(<span class="keyword">void</span> *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)val, val_len);</span><br><span class="line"></span><br><span class="line">				len = val_len;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Handle NULL pointers</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			len = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PT_SOCKADDR:</span><br><span class="line">	<span class="keyword">case</span> PT_SOCKTUPLE:</span><br><span class="line">	<span class="keyword">case</span> PT_FDLIST:</span><br><span class="line">		<span class="keyword">if</span> (likely(val != <span class="number">0</span>)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (unlikely(val_len &gt;= max_arg_size))</span><br><span class="line">				<span class="keyword">return</span> PPM_FAILURE_BUFFER_FULL;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (fromuser) &#123;</span><br><span class="line">				len = (<span class="keyword">int</span>)ppm_copy_from_user(args-&gt;<span class="built_in">buffer</span> + args-&gt;arg_data_offset,</span><br><span class="line">						(<span class="keyword">const</span> <span class="keyword">void</span> __user *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)val,</span><br><span class="line">						val_len);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (unlikely(len != <span class="number">0</span>))</span><br><span class="line">					<span class="keyword">return</span> PPM_FAILURE_INVALID_USER_MEMORY;</span><br><span class="line"></span><br><span class="line">				len = val_len;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">memcpy</span>(args-&gt;<span class="built_in">buffer</span> + args-&gt;arg_data_offset,</span><br><span class="line">					(<span class="keyword">void</span> *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)val, val_len);</span><br><span class="line"></span><br><span class="line">				len = val_len;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Handle NULL pointers</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			len = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PT_FLAGS8:</span><br><span class="line">	<span class="keyword">case</span> PT_UINT8:</span><br><span class="line">	<span class="keyword">case</span> PT_SIGTYPE:</span><br><span class="line">		<span class="keyword">if</span> (likely(max_arg_size &gt;= <span class="keyword">sizeof</span>(u8)))	&#123;</span><br><span class="line">			*(u8 *)(args-&gt;<span class="built_in">buffer</span> + args-&gt;arg_data_offset) = (u8)val;</span><br><span class="line">			len = <span class="keyword">sizeof</span>(u8);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> PPM_FAILURE_BUFFER_FULL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PT_FLAGS16:</span><br><span class="line">	<span class="keyword">case</span> PT_UINT16:</span><br><span class="line">	<span class="keyword">case</span> PT_SYSCALLID:</span><br><span class="line">		<span class="keyword">if</span> (likely(max_arg_size &gt;= <span class="keyword">sizeof</span>(u16))) &#123;</span><br><span class="line">			*(u16 *)(args-&gt;<span class="built_in">buffer</span> + args-&gt;arg_data_offset) = (u16)val;</span><br><span class="line">			len = <span class="keyword">sizeof</span>(u16);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> PPM_FAILURE_BUFFER_FULL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PT_FLAGS32:</span><br><span class="line">	<span class="keyword">case</span> PT_UINT32:</span><br><span class="line">	<span class="keyword">case</span> PT_MODE:</span><br><span class="line">	<span class="keyword">case</span> PT_UID:</span><br><span class="line">	<span class="keyword">case</span> PT_GID:</span><br><span class="line">	<span class="keyword">case</span> PT_SIGSET:</span><br><span class="line">		<span class="keyword">if</span> (likely(max_arg_size &gt;= <span class="keyword">sizeof</span>(u32))) &#123;</span><br><span class="line">			*(u32 *)(args-&gt;<span class="built_in">buffer</span> + args-&gt;arg_data_offset) = (u32)val;</span><br><span class="line">			len = <span class="keyword">sizeof</span>(u32);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> PPM_FAILURE_BUFFER_FULL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PT_RELTIME:</span><br><span class="line">	<span class="keyword">case</span> PT_ABSTIME:</span><br><span class="line">	<span class="keyword">case</span> PT_UINT64:</span><br><span class="line">		<span class="keyword">if</span> (likely(max_arg_size &gt;= <span class="keyword">sizeof</span>(u64))) &#123;</span><br><span class="line">			*(u64 *)(args-&gt;<span class="built_in">buffer</span> + args-&gt;arg_data_offset) = (u64)val;</span><br><span class="line">			len = <span class="keyword">sizeof</span>(u64);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> PPM_FAILURE_BUFFER_FULL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PT_INT8:</span><br><span class="line">		<span class="keyword">if</span> (likely(max_arg_size &gt;= <span class="keyword">sizeof</span>(s8))) &#123;</span><br><span class="line">			*(s8 *)(args-&gt;<span class="built_in">buffer</span> + args-&gt;arg_data_offset) = (s8)(<span class="keyword">long</span>)val;</span><br><span class="line">			len = <span class="keyword">sizeof</span>(s8);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> PPM_FAILURE_BUFFER_FULL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PT_INT16:</span><br><span class="line">		<span class="keyword">if</span> (likely(max_arg_size &gt;= <span class="keyword">sizeof</span>(s16))) &#123;</span><br><span class="line">			*(s16 *)(args-&gt;<span class="built_in">buffer</span> + args-&gt;arg_data_offset) = (s16)(<span class="keyword">long</span>)val;</span><br><span class="line">			len = <span class="keyword">sizeof</span>(s16);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> PPM_FAILURE_BUFFER_FULL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PT_INT32:</span><br><span class="line">		<span class="keyword">if</span> (likely(max_arg_size &gt;= <span class="keyword">sizeof</span>(s32))) &#123;</span><br><span class="line">			*(s32 *)(args-&gt;<span class="built_in">buffer</span> + args-&gt;arg_data_offset) = (s32)(<span class="keyword">long</span>)val;</span><br><span class="line">			len = <span class="keyword">sizeof</span>(s32);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> PPM_FAILURE_BUFFER_FULL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PT_INT64:</span><br><span class="line">	<span class="keyword">case</span> PT_ERRNO:</span><br><span class="line">	<span class="keyword">case</span> PT_FD:</span><br><span class="line">	<span class="keyword">case</span> PT_PID:</span><br><span class="line">		<span class="keyword">if</span> (likely(max_arg_size &gt;= <span class="keyword">sizeof</span>(s64))) &#123;</span><br><span class="line">			*(s64 *)(args-&gt;<span class="built_in">buffer</span> + args-&gt;arg_data_offset) = (s64)(<span class="keyword">long</span>)val;</span><br><span class="line">			len = <span class="keyword">sizeof</span>(s64);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> PPM_FAILURE_BUFFER_FULL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		ASSERT(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UDIG</span></span><br><span class="line">		pr_err(<span class="string">"val_to_ring: invalid argument type %d. Event %u (%s) might have less parameters than what has been declared in nparams\n"</span>,</span><br><span class="line">			(<span class="keyword">int</span>)g_event_info[args-&gt;event_type].params[args-&gt;curarg].type,</span><br><span class="line">			(u32)args-&gt;event_type,</span><br><span class="line">			g_event_info[args-&gt;event_type].name);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>			</span></span><br><span class="line">		<span class="keyword">return</span> PPM_FAILURE_BUG;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ASSERT(len &lt;= PPM_MAX_ARG_SIZE);</span><br><span class="line">	ASSERT(len &lt;= max_arg_size);</span><br><span class="line"></span><br><span class="line">	*psize += (u16)len;</span><br><span class="line">	args-&gt;curarg++;</span><br><span class="line">	args-&gt;arg_data_offset += len;</span><br><span class="line">	args-&gt;arg_data_size -= len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> PPM_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回调结束回到main，计算header_size+参数数量*2的size（存放两字节参数长度），即总共写入ringbuffer的数据大小，包括evt_header + evt_body，并将其更新到ringbuffer中（hdr当前也还是指向ringbuffer head指向位置的）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> (likely(cbres == PPM_SUCCESS)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Validate that the filler added the right number of parameters</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (likely(args.curarg == args.nargs)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * The event was successfully inserted in the buffer</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			event_size = <span class="keyword">sizeof</span>(struct ppm_evt_hdr) + args.arg_data_offset;</span><br><span class="line">			hdr-&gt;len = event_size;</span><br><span class="line">			drop = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pr_err(<span class="string">"corrupted filler for event type %d (added %u args, should have added %u)\n"</span>,</span><br><span class="line">			       event_type,</span><br><span class="line">			       args.curarg,</span><br><span class="line">			       args.nargs);</span><br><span class="line">			ASSERT(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查写入ringbuffer的数据长度是否超过RING_BUF_SIZE，若超过，则将超出部分覆写到ringbuffer头；更新next，并将其作为下一次写入ringbuffer的head指针；ring中的nevents事件+1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (likely(!drop)) &#123;</span><br><span class="line">	res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	next = head + event_size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(next &gt;= RING_BUF_SIZE)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If something has been written in the cushion space at the end of</span></span><br><span class="line"><span class="comment">		 * the buffer, copy it to the beginning and wrap the head around.</span></span><br><span class="line"><span class="comment">		 * Note, we don't check that the copy fits because we assume that</span></span><br><span class="line"><span class="comment">		 * filler_callback failed if the space was not enough.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (next &gt; RING_BUF_SIZE) &#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(ring-&gt;<span class="built_in">buffer</span>,</span><br><span class="line">			ring-&gt;<span class="built_in">buffer</span> + RING_BUF_SIZE,</span><br><span class="line">			next - RING_BUF_SIZE);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		next -= RING_BUF_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure all the memory has been written in real memory before</span></span><br><span class="line"><span class="comment">	 * we update the head and the user space process (on another CPU)</span></span><br><span class="line"><span class="comment">	 * can access the buffer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_wmb();</span><br><span class="line"></span><br><span class="line">	ring_info-&gt;head = next;</span><br><span class="line"></span><br><span class="line">	++ring-&gt;nevents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据回调返回值的一系列异常处理（buffer满了、无效用户态内存等），对应状态计数器++：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (cbres == PPM_SUCCESS) &#123;</span><br><span class="line">			ASSERT(freespace &lt; <span class="keyword">sizeof</span>(struct ppm_evt_hdr) + args.arg_data_offset);</span><br><span class="line">			ring_info-&gt;n_drops_buffer++;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cbres == PPM_FAILURE_INVALID_USER_MEMORY) &#123;</span><br><span class="line">#ifdef _DEBUG</span><br><span class="line">			pr_err(<span class="string">"Invalid read from user for event %d\n"</span>, event_type);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">			ring_info-&gt;n_drops_pf++;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cbres == PPM_FAILURE_BUFFER_FULL) &#123;</span><br><span class="line">			ring_info-&gt;n_drops_buffer++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ASSERT(<span class="literal">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>有些东西不去看永远觉得难，认真钻研之后发现其实并没有非常难以理解；sysdig主要是事件相关的结构体太多，一步步去跟代码逻辑会觉得非常绕，沉下心来看就好了；另外在分析的过程中可以在内核模块代码中加一些调试语句，查看事件/结构体成员/etc.内容，能更快的去理解其含义；sysdig项目太大了，上面的分析过程也没有太细，基本上都是代码整体流程这一层的记录，主要是觉得每个点都记录的太细确实有点花费时间了，后续重温的话基本看整体执行流程就知道是怎么回事了。这篇只分析了driver，后面会抽空把scap和inspect的补上；另外还打算出一篇讲ringbuffer的，以及最近用到的内核模块自动化编译工具driverkit……学海无涯，人生苦短。</p>
<h1 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h1><p><a href="https://blog.csdn.net/zqixiao_09/article/details/50839042" target="_blank" rel="noopener">https://blog.csdn.net/zqixiao_09/article/details/50839042</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag"># 源码分析</a>
              <a href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" rel="tag"># 二进制</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/03/15/Docker-Container-Escapes-Research/" rel="prev" title="Docker Container Escapes Research">
                  <i class="fa fa-chevron-left"></i> Docker Container Escapes Research
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/06/27/Observe-Kprobe-And-Tracepoint-Under-Ftrace/" rel="next" title="Observe Kprobe And Tracepoint Under Ftrace">
                  Observe Kprobe And Tracepoint Under Ftrace <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XDW</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>



    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  















  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  

</body>
</html>
